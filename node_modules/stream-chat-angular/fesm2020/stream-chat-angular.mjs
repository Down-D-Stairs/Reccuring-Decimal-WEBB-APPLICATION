import * as i0 from '@angular/core';
import { Injectable, Component, Input, EventEmitter, Output, ViewChild, HostBinding, ChangeDetectionStrategy, InjectionToken, Directive, Inject, NgModule } from '@angular/core';
import { BehaviorSubject, ReplaySubject, combineLatest, take as take$1, Subject, timer } from 'rxjs';
import { StreamChat } from 'stream-chat';
import { take, shareReplay, map, first, filter, tap, debounceTime, throttleTime } from 'rxjs/operators';
import { v4 } from 'uuid';
import * as i10 from '@ngx-translate/core';
import { TranslateModule } from '@ngx-translate/core';
import * as i4 from '@angular/common';
import { CommonModule } from '@angular/common';
import Dayjs from 'dayjs';
import calendar from 'dayjs/plugin/calendar';
import relativeTime from 'dayjs/plugin/relativeTime';
import emojiRegex from 'emoji-regex';
import * as i8 from 'ngx-float-ui';
import { NgxFloatUiModule } from 'ngx-float-ui';
import prettybytes from 'pretty-bytes';
import transliterate from '@stream-io/transliterate';
import * as i8$1 from 'angular-mentions';
import { MentionModule } from 'angular-mentions';

const version = '5.0.0';

/**
 * The `NotificationService` can be used to add or remove notifications. By default the [`NotificationList`](../components/NotificationListComponent.mdx) component displays the currently active notifications.
 */
class NotificationService {
    constructor() {
        this.notificationsSubject = new BehaviorSubject([]);
        this.notifications$ = this.notificationsSubject.asObservable();
    }
    /**
     * Displays a notification for the given amount of time.
     * @param content The text of the notification or the HTML template for the notification
     * @param type The type of the notification
     * @param timeout The number of milliseconds while the notification should be visible
     * @param translateParams Translation parameters for the `content` (for text notifications)
     * @param templateContext The input of the notification template (for HTML notifications)
     * @returns A method to clear the notification (before the timeout).
     */
    addTemporaryNotification(content, type = 'error', timeout = 5000, translateParams, templateContext) {
        const notification = this.createNotification(content, type, translateParams, templateContext);
        const id = setTimeout(() => this.removeNotification(notification.id), timeout);
        notification.dismissFn = () => {
            clearTimeout(id);
            this.removeNotification(notification.id);
        };
        this.notificationsSubject.next([
            ...this.notificationsSubject.getValue(),
            notification,
        ]);
        return notification.dismissFn;
    }
    /**
     * Displays a notification, that will be visible until it's removed.
     * @param content The text of the notification or the HTML template for the notification
     * @param type The type of the notification
     * @param translateParams Translation parameters for the `content` (for text notifications)
     * @param templateContext The input of the notification template (for HTML notifications)
     * @returns A method to clear the notification.
     */
    addPermanentNotification(content, type = 'error', translateParams, templateContext) {
        const notification = this.createNotification(content, type, translateParams, templateContext);
        this.notificationsSubject.next([
            ...this.notificationsSubject.getValue(),
            notification,
        ]);
        return notification.dismissFn;
    }
    createNotification(content, type, translateParams, templateContext) {
        const id = new Date().getTime().toString() + Math.random().toString();
        return {
            id,
            [typeof content === 'string' ? 'text' : 'template']: content,
            type,
            translateParams,
            templateContext: templateContext ?? {},
            dismissFn: () => this.removeNotification(id),
        };
    }
    removeNotification(id) {
        const notifications = this.notificationsSubject.getValue();
        const index = notifications.findIndex((n) => n.id === id);
        if (index === -1) {
            return;
        }
        notifications.splice(index, 1);
        this.notificationsSubject.next([...notifications]);
    }
}
NotificationService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: NotificationService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
NotificationService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: NotificationService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: NotificationService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return []; } });

/**
 * The `ChatClient` service connects the user to the Stream chat.
 */
class ChatClientService {
    constructor(ngZone, notificationService) {
        this.ngZone = ngZone;
        this.notificationService = notificationService;
        this.notificationSubject = new ReplaySubject(1);
        this.connectionStateSubject = new ReplaySubject(1);
        this.appSettingsSubject = new BehaviorSubject(undefined);
        this.pendingInvitesSubject = new BehaviorSubject([]);
        this.userSubject = new ReplaySubject(1);
        this.subscriptions = [];
        this.trackPendingChannelInvites = true;
        this.events$ = this.notificationSubject.asObservable();
        this.connectionState$ = this.connectionStateSubject.asObservable();
        this.appSettings$ = this.appSettingsSubject.asObservable();
        this.pendingInvites$ = this.pendingInvitesSubject.asObservable();
        this.user$ = this.userSubject.asObservable();
    }
    /**
     * Creates a [`StreamChat`](https://github.com/GetStream/stream-chat-js/blob/668b3e5521339f4e14fc657834531b4c8bf8176b/src/client.ts#L124) instance using the provided `apiKey`, and connects a user with the given meta data and token. More info about [connecting users](https://getstream.io/chat/docs/javascript/init_and_users/?language=javascript) can be found in the platform documentation.
     * @param apiKey
     * @param userOrId you can emit this for anonymous logins
     * @param userTokenOrProvider You can provide:<ul>
     *  <li> a token, </li>
     *  <li> a token provider, a method that returns `Promise<string>`, which can be called when the previous token expires (recommended setup for production applications)</li>
     *  <li> the keyword 'guest' to connect as [guest user](https://getstream.io/chat/docs/javascript/authless_users/?language=javascript#guest-users) </li>
     *  <li> the keyword 'anonymous' to connect as [anonymous user](https://getstream.io/chat/docs/javascript/authless_users/?language=javascript#anonymous-users) </li>
     *  </ul>
     * @param clientOptions Setting to provide to the Stream client instance
     */
    async init(apiKey, userOrId, userTokenOrProvider, clientOptions) {
        if (this.chatClient && this.chatClient.key !== apiKey) {
            this.appSettingsSubject.next(undefined);
            this.appSettingsPromise = undefined;
        }
        this.trackPendingChannelInvites =
            clientOptions?.trackPendingChannelInvites === true;
        this.chatClient = StreamChat.getInstance(apiKey, clientOptions);
        const sdkPrefix = 'stream-chat-angular';
        if (!this.chatClient.getUserAgent().includes(sdkPrefix)) {
            this.chatClient.setUserAgent(`${sdkPrefix}-${version}-${this.chatClient.getUserAgent()}`);
        }
        this.chatClient.recoverStateOnReconnect = false;
        this.chatClient.devToken;
        let result;
        await this.ngZone.runOutsideAngular(async () => {
            const user = typeof userOrId === 'string' ? { id: userOrId } : userOrId;
            try {
                result = await ({
                    guest: () => this.chatClient.setGuestUser(user),
                    anonymous: () => this.chatClient.connectAnonymousUser(),
                    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
                }[`${userTokenOrProvider}`] ??
                    (() => this.chatClient.connectUser(user, userTokenOrProvider)))();
            }
            catch (error) {
                this.notificationService.addPermanentNotification('streamChat.Error connecting to chat, refresh the page to try again.', 'error');
                throw error;
            }
            this.userSubject.next(this.chatClient.user ? { ...this.chatClient.user } : undefined);
        });
        if (this.chatClient.user?.id && this.trackPendingChannelInvites) {
            const channels = await this.chatClient.queryChannels({
                invite: 'pending',
                members: { $in: [this.chatClient.user?.id] },
            } // TODO: find out why we need this typecast
            );
            this.pendingInvitesSubject.next(channels);
        }
        this.subscriptions.push(this.chatClient.on((e) => {
            this.updateUser(e);
            this.updatePendingInvites(e);
            this.notificationSubject.next({
                eventType: e.type,
                event: e,
            });
        }));
        let removeNotification;
        this.subscriptions.push(this.chatClient.on('connection.changed', (e) => {
            this.ngZone.run(() => {
                const isOnline = e.online;
                if (isOnline) {
                    if (removeNotification) {
                        removeNotification();
                    }
                }
                else {
                    removeNotification =
                        this.notificationService.addPermanentNotification('streamChat.Connection failure, reconnecting now...');
                }
                this.connectionStateSubject.next(isOnline ? 'online' : 'offline');
            });
        }));
        return result;
    }
    /**
     * Disconnects the current user, and closes the WebSocket connection. Useful when disconnecting a chat user, use in combination with [`reset`](./ChannelService.mdx/#reset).
     */
    async disconnectUser() {
        this.pendingInvitesSubject.next([]);
        await this.chatClient.disconnectUser();
        this.userSubject.next(undefined);
        this.subscriptions.forEach((s) => s.unsubscribe());
    }
    /**
     * Loads the current [application settings](https://getstream.io/chat/docs/javascript/app_setting_overview/?language=javascript), if the application settings have already been loaded, it does nothing.
     */
    async getAppSettings() {
        if (this.appSettingsPromise) {
            return;
        }
        if (this.appSettingsSubject.getValue()) {
            return;
        }
        this.appSettingsPromise = this.chatClient.getAppSettings();
        void this.appSettingsPromise.finally(() => {
            this.appSettingsPromise = undefined;
        });
        const settings = await this.appSettingsPromise;
        this.appSettingsSubject.next(settings.app || {});
    }
    /**
     * Flag the message with the given ID. If you want to know [more about flags](https://getstream.io/chat/docs/javascript/moderation/?language=javascript) check out the platform documentation.
     * @param messageId
     */
    async flagMessage(messageId) {
        await this.chatClient.flagMessage(messageId);
    }
    /**
     * Searches for users in the application that have ID or name matching the provided search term
     * @param searchTerm
     * @returns The users matching the search
     */
    async autocompleteUsers(searchTerm) {
        if (!searchTerm) {
            return [];
        }
        const result = await this.chatClient.queryUsers({
            $or: [
                { id: { $autocomplete: searchTerm } },
                { name: { $autocomplete: searchTerm } },
            ],
            id: { $ne: this.chatClient.userID },
        }); // TODO: find out why we need this typecast
        return result.users;
    }
    updatePendingInvites(e) {
        if (!this.trackPendingChannelInvites) {
            return;
        }
        if (e.member?.user?.id === this.chatClient.user?.id && e.channel) {
            const pendingInvites = this.pendingInvitesSubject.getValue();
            if (e.type === 'notification.invited') {
                const channel = this.chatClient.channel(e.channel?.type, e.channel?.id);
                this.pendingInvitesSubject.next([...pendingInvites, channel]);
            }
            else if (e.type === 'notification.invite_accepted' ||
                e.type === 'notification.invite_rejected') {
                const index = pendingInvites.findIndex((i) => i?.cid === e.channel?.cid);
                if (index !== -1) {
                    pendingInvites.splice(index, 1);
                    this.pendingInvitesSubject.next([...pendingInvites]);
                }
            }
        }
    }
    updateUser(e) {
        if (typeof e.total_unread_count !== 'undefined') {
            let user;
            this.userSubject.pipe(take(1)).subscribe((u) => {
                user = u;
            });
            if (user && user.total_unread_count !== e.total_unread_count) {
                this.userSubject.next({
                    ...user,
                    total_unread_count: e.total_unread_count,
                });
            }
        }
        if (typeof e.unread_channels !== 'undefined') {
            let user;
            this.userSubject.pipe(take(1)).subscribe((u) => {
                user = u;
            });
            if (user && user.unread_channels !== e.unread_channels) {
                this.userSubject.next({
                    ...user,
                    unread_channels: e.unread_channels,
                });
            }
        }
        if (typeof e.unread_count !== 'undefined') {
            let user;
            this.userSubject.pipe(take(1)).subscribe((u) => {
                user = u;
            });
            if (user && user.unread_count !== e.unread_count) {
                this.userSubject.next({
                    ...user,
                    unread_count: e.unread_count,
                });
            }
        }
        if (e.type === 'user.updated' &&
            this.chatClient.user &&
            e.user?.id === this.chatClient.user.id) {
            this.userSubject.next({ ...this.chatClient.user });
        }
    }
}
ChatClientService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: ChatClientService, deps: [{ token: i0.NgZone }, { token: NotificationService }], target: i0.ɵɵFactoryTarget.Injectable });
ChatClientService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: ChatClientService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: ChatClientService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i0.NgZone }, { type: NotificationService }]; } });

const getMessageTranslation = (message, channel, user) => {
    const language = user?.language ||
        channel?.data?.auto_translation_language;
    if (language && message?.i18n && message?.user?.id !== user?.id) {
        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions, @typescript-eslint/no-base-to-string
        return message.i18n[`${language}_text`];
    }
    else {
        return undefined;
    }
};

const createMessagePreview = (user, text, attachments = [], mentionedUsers = [], parentId = undefined, quotedMessageId = undefined, customData) => {
    const clientSideId = `${user.id}-${v4()}`;
    return {
        __html: text,
        created_at: new Date(),
        html: text,
        id: clientSideId,
        reactions: [],
        status: 'sending',
        text,
        type: 'regular',
        user,
        attachments,
        mentioned_users: mentionedUsers,
        parent_id: parentId,
        quoted_message_id: quotedMessageId,
        ...customData,
    };
};

const getReadBy = (message, channel) => {
    const readBy = [];
    Object.keys(channel.state.read).forEach((key) => {
        if (channel.state.read[key].last_read.getTime() >=
            message.created_at.getTime() &&
            message.user?.id !== key) {
            readBy.push(channel.state.read[key].user);
        }
    });
    return readBy;
};

/**
 * This class allows you to make paginated channel query requests.
 */
class ChannelQuery {
    constructor(chatService, channelService, filters, sort = { last_message_at: -1 }, options = {
        limit: 25,
        state: true,
        presence: true,
        watch: true,
    }) {
        this.chatService = chatService;
        this.channelService = channelService;
        this.filters = filters;
        this.sort = sort;
        this.options = options;
    }
    async query(queryType) {
        if (queryType === 'first-page' || queryType === 'recover-state') {
            this.nextPageConfiguration = undefined;
        }
        const prevChannels = queryType === 'recover-state' ? [] : this.channelService.channels;
        let filters;
        let options;
        if (this.nextPageConfiguration) {
            if (this.nextPageConfiguration.type === 'filter') {
                filters = {
                    ...this.filters,
                    ...this.nextPageConfiguration.paginationFilter,
                };
                options = this.options;
            }
            else {
                options = {
                    ...this.options,
                    offset: this.nextPageConfiguration.offset,
                };
                filters = this.filters;
            }
        }
        else {
            filters = this.filters;
            options = this.options;
        }
        const channels = await this.chatService.chatClient.queryChannels(filters, this.sort || {}, options);
        this.setNextPageConfiguration(channels);
        const currentActiveChannel = this.channelService.activeChannel;
        if (queryType === 'recover-state' &&
            currentActiveChannel &&
            !channels.find((c) => c.cid === currentActiveChannel?.cid)) {
            try {
                await currentActiveChannel.watch();
                channels.unshift(currentActiveChannel);
            }
            catch (error) {
                this.chatService.chatClient.logger('warn', 'Unable to refetch active channel after state recover', error);
            }
        }
        return {
            channels: [...prevChannels, ...channels],
            hasMorePage: channels.length >= this.options.limit,
        };
    }
    setNextPageConfiguration(channelQueryResult) {
        if (this.customPaginator) {
            this.nextPageConfiguration = this.customPaginator(channelQueryResult);
        }
        else {
            this.nextPageConfiguration = {
                type: 'offset',
                offset: (this.nextPageConfiguration?.type === 'offset'
                    ? this.nextPageConfiguration.offset
                    : 0) + channelQueryResult.length,
            };
        }
    }
}

/**
 * The `ChannelService` provides data and interaction for the channel list and message list.
 */
class ChannelService {
    constructor(chatClientService, ngZone, notificationService) {
        this.chatClientService = chatClientService;
        this.ngZone = ngZone;
        this.notificationService = notificationService;
        this.channelsSubject = new BehaviorSubject(undefined);
        this.activeChannelSubject = new BehaviorSubject(undefined);
        this.activeChannelMessagesSubject = new BehaviorSubject([]);
        this.activeChannelPinnedMessagesSubject = new BehaviorSubject([]);
        this.hasMoreChannelsSubject = new ReplaySubject(1);
        this.activeChannelSubscriptions = [];
        this.channelSubscriptions = {};
        this.activeParentMessageIdSubject = new BehaviorSubject(undefined);
        this.activeThreadMessagesSubject = new BehaviorSubject([]);
        this.jumpToMessageSubject = new BehaviorSubject({ id: undefined, parentId: undefined });
        this.latestMessageDateByUserByChannelsSubject = new BehaviorSubject({});
        this.messagePageSize = 25;
        this.attachmentMaxSizeFallbackInMB = 100;
        this.messageToQuoteSubject = new BehaviorSubject(undefined);
        this.usersTypingInChannelSubject = new BehaviorSubject([]);
        this.usersTypingInThreadSubject = new BehaviorSubject([]);
        this._shouldMarkActiveChannelAsRead = true;
        this.isStateRecoveryInProgress = false;
        this.channelQueryStateSubject = new BehaviorSubject(undefined);
        this.channelListSetter = (channels, shouldStopWatchingRemovedChannels = true) => {
            const currentChannels = this.channelsSubject.getValue() || [];
            const deletedChannels = currentChannels.filter((c) => !channels?.find((channel) => channel.cid === c.cid));
            for (let i = 0; i < channels.length; i++) {
                const channel = channels[i];
                if (!this.channelSubscriptions[channel.cid]) {
                    this.watchForChannelEvents(channel);
                }
                if (deletedChannels.includes(channel)) {
                    if (shouldStopWatchingRemovedChannels) {
                        if (this.channelSubscriptions[channel.cid]) {
                            this.channelSubscriptions[channel.cid]();
                            delete this.channelSubscriptions.cid;
                        }
                        void this.chatClientService.chatClient.activeChannels[channel.cid]
                            ?.stopWatching()
                            .catch((err) => this.chatClientService.chatClient.logger('warn', 'Failed to unwatch channel', err));
                    }
                }
            }
            const nextChannels = channels;
            this.channelsSubject.next(nextChannels);
            if (!nextChannels.find((c) => c.cid === this.activeChannelSubject.getValue()?.cid)) {
                if (nextChannels.length > 0) {
                    this.setAsActiveChannel(nextChannels[0]);
                }
                else {
                    this.activeChannelSubject.next(undefined);
                }
            }
        };
        this.messageListSetter = (messages) => {
            this.activeChannelMessagesSubject.next(messages);
        };
        this.threadListSetter = (messages) => {
            this.activeThreadMessagesSubject.next(messages);
        };
        this.parentMessageSetter = (message) => {
            this.activeParentMessageIdSubject.next(message?.id);
        };
        this.areReadEventsPaused = false;
        this.channels$ = this.channelsSubject.asObservable().pipe(shareReplay(1));
        this.activeChannel$ = this.activeChannelSubject
            .asObservable()
            .pipe(shareReplay(1));
        this.activeChannelMessages$ = this.activeChannelMessagesSubject.pipe(map((messages) => {
            const channel = this.activeChannelSubject.getValue();
            return messages.map((message) => this.transformToStreamMessage(message, channel));
        }), shareReplay(1));
        this.bouncedMessage$ = new BehaviorSubject(undefined);
        this.hasMoreChannels$ = this.hasMoreChannelsSubject
            .asObservable()
            .pipe(shareReplay(1));
        this.activeParentMessageId$ = this.activeParentMessageIdSubject
            .asObservable()
            .pipe(shareReplay(1));
        this.activeThreadMessages$ = this.activeThreadMessagesSubject.pipe(map((messages) => {
            const channel = this.activeChannelSubject.getValue();
            return messages.map((message) => this.transformToStreamMessage(message, channel));
        }), shareReplay(1));
        this.activeParentMessage$ = combineLatest([
            this.activeChannelMessages$,
            this.activeParentMessageId$,
        ]).pipe(map(([messages, parentMessageId]) => {
            if (!parentMessageId) {
                return undefined;
            }
            else {
                const message = messages.find((m) => m.id === parentMessageId);
                if (!message) {
                    void this.setAsActiveParentMessage(undefined);
                    return undefined;
                }
                else {
                    return message;
                }
            }
        }), shareReplay(1));
        this.messageToQuote$ = this.messageToQuoteSubject
            .asObservable()
            .pipe(shareReplay(1));
        this.jumpToMessage$ = this.jumpToMessageSubject
            .asObservable()
            .pipe(shareReplay(1));
        this.usersTypingInChannel$ = this.usersTypingInChannelSubject
            .asObservable()
            .pipe(shareReplay(1));
        this.usersTypingInThread$ = this.usersTypingInThreadSubject
            .asObservable()
            .pipe(shareReplay(1));
        this.latestMessageDateByUserByChannels$ =
            this.latestMessageDateByUserByChannelsSubject
                .asObservable()
                .pipe(shareReplay(1));
        this.activeChannelPinnedMessages$ = this.activeChannelPinnedMessagesSubject
            .asObservable()
            .pipe(shareReplay(1));
        this.channelQueryState$ = this.channelQueryStateSubject
            .asObservable()
            .pipe(shareReplay(1));
    }
    /**
     * internal
     */
    removeOldMessageFromMessageList() {
        const channel = this.activeChannelSubject.getValue();
        const channelMessages = channel?.state.latestMessages;
        const targetLength = Math.ceil(ChannelService.MAX_MESSAGE_COUNT_IN_MESSAGE_LIST / 2);
        if (!channel ||
            !channelMessages ||
            channelMessages !== channel?.state.latestMessages ||
            channelMessages.length <= targetLength) {
            return;
        }
        const messages = channelMessages;
        messages.splice(0, messages.length - targetLength);
        this.activeChannelMessagesSubject.next(messages);
    }
    /**
     * If set to false, read events won't be sent as new messages are received. If set to true active channel (if any) will immediately be marked as read.
     */
    get shouldMarkActiveChannelAsRead() {
        return this._shouldMarkActiveChannelAsRead;
    }
    /**
     * If set to false, read events won't be sent as new messages are received. If set to true active channel (if any) will immediately be marked as read.
     */
    set shouldMarkActiveChannelAsRead(shouldMarkActiveChannelAsRead) {
        if (!this._shouldMarkActiveChannelAsRead && shouldMarkActiveChannelAsRead) {
            const activeChannel = this.activeChannelSubject.getValue();
            if (activeChannel && this.canSendReadEvents) {
                void activeChannel.markRead();
            }
        }
        this._shouldMarkActiveChannelAsRead = shouldMarkActiveChannelAsRead;
    }
    /**
     * By default the SDK uses an offset based pagination, you can change/extend this by providing your own custom paginator method.
     *
     * The method will be called with the result of the latest channel query.
     *
     * You can return either an offset, or a filter using the [`$lte`/`$gte` operator](https://getstream.io/chat/docs/javascript/query_syntax_operators/). If you return a filter, it will be merged with the filter provided for the `init` method.
     */
    set customPaginator(paginator) {
        this._customPaginator = paginator;
        if (this.channelQuery && 'customPaginator' in this.channelQuery) {
            this.channelQuery.customPaginator = this._customPaginator;
        }
    }
    /**
     * Sets the given `channel` as active and marks it as read.
     * If the channel wasn't previously part of the channel, it will be added to the beginning of the list.
     * @param channel
     */
    setAsActiveChannel(channel) {
        const prevActiveChannel = this.activeChannelSubject.getValue();
        if (prevActiveChannel?.cid === channel.cid) {
            return;
        }
        this.stopWatchForActiveChannelEvents(prevActiveChannel);
        this.areReadEventsPaused = false;
        const readState = channel.state.read[this.chatClientService.chatClient.user?.id || ''];
        this.activeChannelLastReadMessageId = readState?.last_read_message_id;
        if (channel.state.latestMessages[channel.state.latestMessages.length - 1]
            ?.id === this.activeChannelLastReadMessageId) {
            this.activeChannelLastReadMessageId = undefined;
        }
        this.activeChannelUnreadCount = readState?.unread_messages || 0;
        this.watchForActiveChannelEvents(channel);
        this.addChannel(channel);
        this.activeChannelSubject.next(channel);
        const channelStateLength = channel.state.latestMessages.length;
        if (channelStateLength > 2 * this.messagePageSize) {
            channel.state.latestMessages = channel.state.latestMessages.slice(channelStateLength - 2 * this.messagePageSize);
        }
        this.setChannelState(channel);
    }
    /**
     * Deselects the currently active (if any) channel
     */
    deselectActiveChannel() {
        const activeChannel = this.activeChannelSubject.getValue();
        if (!activeChannel) {
            return;
        }
        this.stopWatchForActiveChannelEvents(activeChannel);
        this.activeChannelMessagesSubject.next([]);
        this.activeChannelSubject.next(undefined);
        this.activeParentMessageIdSubject.next(undefined);
        this.activeThreadMessagesSubject.next([]);
        this.latestMessageDateByUserByChannelsSubject.next({});
        this.selectMessageToQuote(undefined);
        this.jumpToMessageSubject.next({ id: undefined, parentId: undefined });
        this.activeChannelPinnedMessagesSubject.next([]);
        this.usersTypingInChannelSubject.next([]);
        this.usersTypingInThreadSubject.next([]);
        this.activeChannelLastReadMessageId = undefined;
        this.activeChannelUnreadCount = undefined;
        this.areReadEventsPaused = false;
    }
    /**
     * Sets the given `message` as an active parent message. If `undefined` is provided, it will deleselect the current parent message.
     * @param message
     * @param loadMessagesForm
     */
    async setAsActiveParentMessage(message, loadMessagesForm = 'request') {
        const messageToQuote = this.messageToQuoteSubject.getValue();
        if (messageToQuote && !!messageToQuote.parent_id) {
            this.messageToQuoteSubject.next(undefined);
        }
        if (!message) {
            this.activeParentMessageIdSubject.next(undefined);
            this.activeThreadMessagesSubject.next([]);
            const messageToJumpTo = this.jumpToMessageSubject.getValue();
            if (messageToJumpTo && !!messageToJumpTo.parentId) {
                this.jumpToMessageSubject.next({ id: undefined, parentId: undefined });
            }
        }
        else {
            this.activeParentMessageIdSubject.next(message.id);
            const activeChannel = this.activeChannelSubject.getValue();
            if (loadMessagesForm === 'request') {
                const result = await activeChannel?.getReplies(message.id, {
                    limit: this.messagePageSize,
                });
                this.activeThreadMessagesSubject.next(result?.messages || []);
            }
            else {
                this.activeThreadMessagesSubject.next(activeChannel?.state.threads[message.id] || []);
            }
        }
    }
    /**
     * Loads the next page of messages of the active channel. The page size can be set in the [query option](https://getstream.io/chat/docs/javascript/query_channels/?language=javascript#query-options) object.
     * @param direction
     */
    loadMoreMessages(direction = 'older') {
        const activeChnannel = this.activeChannelSubject.getValue();
        const messages = this.activeChannelMessagesSubject.getValue();
        const lastMessageId = messages[direction === 'older' ? 0 : messages.length - 1]?.id;
        if (direction === 'newer' &&
            activeChnannel?.state?.latestMessages === activeChnannel?.state?.messages) {
            // If we are on latest message set, activeChannelMessages$ will be refreshed by WS events, no need for a request
            return false;
        }
        return activeChnannel
            ?.query({
            messages: {
                limit: this.messagePageSize,
                [direction === 'older' ? 'id_lt' : 'id_gt']: lastMessageId,
            },
            members: { limit: 0 },
            watchers: { limit: 0 },
        })
            .then((res) => {
            if (activeChnannel?.data?.id ===
                this.activeChannelSubject.getValue()?.data?.id) {
                this.activeChannelMessagesSubject.next([
                    ...activeChnannel.state.messages,
                ]);
            }
            return res;
        });
    }
    /**
     * Loads the next page of messages of the active thread. The page size can be set in the [query option](https://getstream.io/chat/docs/javascript/query_channels/?language=javascript#query-options) object.
     * @param direction
     */
    loadMoreThreadReplies(direction = 'older') {
        if (direction === 'newer') {
            // Thread replies aren't broke into different message sets, activeThreadMessages$ will be refreshed by WS events, no need for a request
            return false;
        }
        const activeChnannel = this.activeChannelSubject.getValue();
        const parentMessageId = this.activeParentMessageIdSubject.getValue();
        if (!parentMessageId || !activeChnannel) {
            return false;
        }
        const threadMessages = this.activeThreadMessagesSubject.getValue();
        const lastMessageId = threadMessages[direction === 'older' ? 0 : threadMessages.length - 1]?.id;
        return activeChnannel
            .getReplies(parentMessageId, {
            limit: this.messagePageSize,
            [direction === 'older' ? 'id_lt' : 'id_gt']: lastMessageId,
        })
            .then(() => {
            this.activeThreadMessagesSubject.next(activeChnannel?.state.threads[parentMessageId] || []);
        });
    }
    /**
     * Queries the channels with the given filters, sorts and options. More info about [channel querying](https://getstream.io/chat/docs/javascript/query_channels/?language=javascript) can be found in the platform documentation. By default the first channel in the list will be set as active channel and will be marked as read.
     * @param filters
     * @param sort
     * @param options
     * @param shouldSetActiveChannel Decides if the first channel in the result should be made as an active channel or not.
     * @returns the list of channels found by the query
     */
    init(filters, sort, options, shouldSetActiveChannel = true) {
        this.channelQuery = new ChannelQuery(this.chatClientService, this, filters, sort || { last_message_at: -1 }, {
            limit: 25,
            state: true,
            presence: true,
            watch: true,
            message_limit: this.messagePageSize,
            ...options,
        });
        this.channelQuery.customPaginator = this._customPaginator;
        return this._init({
            shouldSetActiveChannel,
            messagePageSize: options?.message_limit ?? this.messagePageSize,
        });
    }
    /**
     * Queries the channels with the given query function. More info about [channel querying](https://getstream.io/chat/docs/javascript/query_channels/?language=javascript) can be found in the platform documentation.
     * @param query
     * @param options
     * @param options.shouldSetActiveChannel The `shouldSetActiveChannel` specifies if the first channel in the result should be selected as the active channel or not. Default is `true`.
     * @param options.messagePageSize How many messages should we load? The default is 25
     * @returns the channels that were loaded
     */
    initWithCustomQuery(query, options = {
        shouldSetActiveChannel: true,
        messagePageSize: this.messagePageSize,
    }) {
        this.channelQuery = query;
        return this._init(options);
    }
    /**
     * Resets the `activeChannel$`, `channels$` and `activeChannelMessages$` Observables. Useful when disconnecting a chat user, use in combination with [`disconnectUser`](./ChatClientService.mdx/#disconnectuser).
     */
    reset() {
        this.deselectActiveChannel();
        this.channelsSubject.next(undefined);
        this.channelQueryStateSubject.next(undefined);
        this.clientEventsSubscription?.unsubscribe();
        this.dismissErrorNotification?.();
        this.dismissErrorNotification = undefined;
        Object.keys(this.channelSubscriptions).forEach((cid) => {
            this.channelSubscriptions[cid]();
        });
        this.channelSubscriptions = {};
    }
    /**
     * Loads the next page of channels. The page size can be set in the [query option](https://getstream.io/chat/docs/javascript/query_channels/?language=javascript#query-options) object.
     */
    async loadMoreChannels() {
        await this.queryChannels(false, 'next-page');
    }
    /**
     * Adds a reaction to a message.
     * @param messageId The id of the message to add the reaction to
     * @param reactionType The type of the reaction
     * @param customData
     */
    async addReaction(messageId, reactionType, customData) {
        await this.activeChannelSubject.getValue()?.sendReaction(messageId, {
            type: reactionType,
            ...customData,
        });
    }
    /**
     * Removes a reaction from a message.
     * @param messageId The id of the message to remove the reaction from
     * @param reactionType Thr type of reaction to remove
     */
    async removeReaction(messageId, reactionType) {
        await this.activeChannelSubject
            .getValue()
            ?.deleteReaction(messageId, reactionType);
    }
    /**
     * Sends a message to the active channel. The message is immediately added to the message list, if an error occurs and the message can't be sent, the error is indicated in `state` of the message.
     * @param text The text of the message
     * @param attachments The attachments
     * @param mentionedUsers Mentioned users
     * @param parentId Id of the parent message (if sending a thread reply)
     * @param quotedMessageId Id of the message to quote (if sending a quote reply)
     * @param customData
     */
    async sendMessage(text, attachments = [], mentionedUsers = [], parentId = undefined, quotedMessageId = undefined, customData = undefined) {
        let input = {
            text,
            attachments,
            mentionedUsers,
            parentId,
            quotedMessageId,
            customData,
        };
        if (this.beforeSendMessage) {
            input = await this.beforeSendMessage(input);
        }
        const preview = createMessagePreview(this.chatClientService.chatClient.user, input.text, input.attachments, input.mentionedUsers, input.parentId, input.quotedMessageId, input.customData);
        const channel = this.activeChannelSubject.getValue();
        preview.readBy = [];
        channel.state.addMessageSorted(preview, true);
        const response = await this.sendMessageRequest(preview, input.customData);
        return response;
    }
    /**
     * Resends the given message to the active channel
     * @param message The message to resend
     */
    async resendMessage(message) {
        const channel = this.activeChannelSubject.getValue();
        channel.state.addMessageSorted({
            ...message,
            errorStatusCode: undefined,
            status: 'sending',
        }, true);
        return this.sendMessageRequest(message, undefined, true);
    }
    /**
     * Updates the message in the active channel
     * @param message Mesage to be updated
     */
    async updateMessage(message) {
        let messageToUpdate = { ...message };
        delete messageToUpdate.i18n;
        if (this.beforeUpdateMessage) {
            messageToUpdate = await this.beforeUpdateMessage(messageToUpdate);
        }
        if (message.moderation_details) {
            return this.resendMessage(message);
        }
        const response = await this.chatClientService.chatClient.updateMessage(messageToUpdate);
        const channel = this.channelsSubject
            .getValue()
            ?.find((c) => c.cid === message.cid);
        if (response.message.type === 'error' &&
            response.message.moderation_details) {
            this.notificationService.addTemporaryNotification('streamChat.This message did not meet our content guidelines');
            return message;
        }
        return this.transformToStreamMessage(response.message, channel);
    }
    /**
     * Deletes the message from the active channel
     * @param message Message to be deleted
     * @param isLocalDelete set this `true` if you want to delete a message that's only part of the local state, not yet saved on the backend
     */
    async deleteMessage(message, isLocalDelete = false) {
        if (isLocalDelete && this.activeChannel) {
            const result = this.activeChannel.state.removeMessage({
                id: message.id,
                parent_id: message.parent_id,
            });
            if (result) {
                message.parent_id
                    ? this.activeThreadMessagesSubject.next(this.activeChannel.state.threads[message.parent_id])
                    : this.activeChannelMessagesSubject.next(this.activeChannel.state.messages);
            }
            return;
        }
        if (this.messageDeleteConfirmationHandler) {
            const result = await this.messageDeleteConfirmationHandler(message);
            if (result) {
                await this.chatClientService.chatClient.deleteMessage(message.id);
            }
        }
        else {
            await this.chatClientService.chatClient.deleteMessage(message.id);
        }
    }
    /**
     * Uploads files to the channel. If you want to know more about [file uploads](https://getstream.io/chat/docs/javascript/file_uploads/?language=javascript) check out the platform documentation.
     * @param uploads the attachments to upload (output of the [`AttachmentService`](./AttachmentService.mdx))
     * @returns the result of file upload requests
     */
    async uploadAttachments(uploads) {
        const result = [];
        const channel = this.activeChannelSubject.getValue();
        const uploadResults = await Promise.allSettled(uploads.map((upload) => upload.type === 'image'
            ? this.customImageUploadRequest
                ? this.customImageUploadRequest(upload.file, channel)
                : channel.sendImage(upload.file, upload.file.name, upload.file.type)
            : this.customFileUploadRequest
                ? this.customFileUploadRequest(upload.file, channel)
                : channel.sendFile(upload.file, upload.file.name, upload.file.type)));
        uploadResults.forEach((uploadResult, i) => {
            const file = uploads[i].file;
            const type = uploads[i].type;
            if (uploadResult.status === 'fulfilled') {
                result.push({
                    file,
                    type,
                    state: 'success',
                    url: uploadResult.value.file,
                    /* eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any */
                    thumb_url: uploadResult.value.thumb_url,
                });
            }
            else {
                let reason = 'unknown';
                let extraData;
                /* eslint-disable-next-line @typescript-eslint/no-unsafe-assignment */
                const message = 
                /* eslint-disable-next-line @typescript-eslint/no-unsafe-member-access */
                uploadResult.reason.response?.data?.message;
                /* eslint-disable-next-line @typescript-eslint/no-unsafe-assignment */
                const code = 
                /* eslint-disable-next-line @typescript-eslint/no-unsafe-member-access */
                uploadResult.reason.response?.data?.code;
                if (code === 22 ||
                    (code === 4 && message?.toLowerCase()?.includes('bytes'))) {
                    reason = 'file-size';
                    extraData = {
                        param: /\d+MB|\d+\s?bytes/.exec(message || '')?.[0] ||
                            `${this.attachmentMaxSizeFallbackInMB}MB`,
                    };
                    if (extraData.param.includes('bytes')) {
                        const limitInBytes = +(/\d+/.exec(extraData.param)?.[0] ||
                            this.attachmentMaxSizeFallbackInMB * 1024 * 1024);
                        extraData.param = `${limitInBytes / (1024 * 1024)}MB`;
                    }
                }
                else if (code === 4 &&
                    message?.toLowerCase()?.includes('file extension')) {
                    reason = 'file-extension';
                    extraData = { param: /\.\w+/.exec(message)?.[0] || '' };
                }
                result.push({
                    file,
                    type,
                    state: 'error',
                    errorReason: reason,
                    errorExtraInfo: extraData ? [extraData] : undefined,
                });
            }
        });
        return result;
    }
    /**
     * Deletes an uploaded file by URL. If you want to know more about [file uploads](https://getstream.io/chat/docs/javascript/file_uploads/?language=javascript) check out the platform documentation
     * @param attachmentUpload Attachment to be deleted (output of the [`AttachmentService`](./AttachmentService.mdx))
     */
    async deleteAttachment(attachmentUpload) {
        const channel = this.activeChannelSubject.getValue();
        await (attachmentUpload.type === 'image'
            ? this.customImageDeleteRequest
                ? this.customImageDeleteRequest(attachmentUpload.url, channel)
                : channel.deleteImage(attachmentUpload.url)
            : this.customFileDeleteRequest
                ? this.customFileDeleteRequest(attachmentUpload.url, channel)
                : channel.deleteFile(attachmentUpload.url));
    }
    /**
     * Returns the autocomplete options for current channel members. If the channel has less than 100 members, it returns the channel members, otherwise sends a [search request](https://getstream.io/chat/docs/javascript/query_members/?language=javascript#pagination-and-ordering) with the given search term.
     * @param searchTerm Text to search for in the names of members
     * @returns The list of members matching the search filter
     */
    async autocompleteMembers(searchTerm) {
        const activeChannel = this.activeChannelSubject.getValue();
        if (!activeChannel) {
            return [];
        }
        if (Object.keys(activeChannel.state.members).length < 100) {
            return Object.values(activeChannel.state.members).filter((m) => m.user?.id !== this.chatClientService.chatClient.userID);
        }
        else {
            if (!searchTerm) {
                return [];
            }
            const result = await activeChannel.queryMembers({
                name: { $autocomplete: searchTerm },
                id: { $ne: this.chatClientService.chatClient.userID },
            }); // TODO: find out why we need typecast here
            return Object.values(result.members);
        }
    }
    /**
     * [Runs a message action](https://getstream.io/chat/docs/rest/#messages-runmessageaction) in the current channel. Updates the message list based on the action result (if no message is returned, the message will be removed from the message list).
     * @param messageId
     * @param formData
     * @param parentMessageId
     */
    async sendAction(messageId, formData, parentMessageId) {
        const channel = this.activeChannelSubject.getValue();
        const response = await channel.sendAction(messageId, formData);
        if (response?.message) {
            channel.state.addMessageSorted({
                ...response.message,
                status: 'received',
            });
            const isThreadReply = !!response.message.parent_id;
            isThreadReply
                ? this.activeThreadMessagesSubject.next([
                    ...channel.state.threads[response.message.parent_id],
                ])
                : this.activeChannelMessagesSubject.next([...channel.state.messages]);
        }
        else {
            channel.state.removeMessage({
                id: messageId,
                parent_id: parentMessageId,
            });
            if (parentMessageId) {
                this.activeThreadMessagesSubject.next(channel.state.threads[this.activeParentMessageIdSubject.getValue()]);
            }
            else {
                this.activeChannelMessagesSubject.next([...channel.state.messages]);
            }
        }
    }
    /**
     * Selects or deselects the current message to quote reply to
     * @param message The message to select, if called with `undefined`, it deselects the message
     */
    selectMessageToQuote(message) {
        this.messageToQuoteSubject.next(message);
    }
    /**
     * Add a new channel to the channel list
     * The channel will be added to the beginning of the channel list
     * @param channel
     */
    addChannel(channel) {
        if (!this.channels.find((c) => c.cid === channel.cid)) {
            this.channelsSubject.next([channel, ...this.channels]);
            this.watchForChannelEvents(channel);
        }
    }
    /**
     *
     * @param cid
     * @param shouldStopWatching
     */
    removeChannel(cid, shouldStopWatching = true) {
        const remainingChannels = this.channels.filter((c) => c.cid !== cid);
        if (shouldStopWatching) {
            if (this.channelSubscriptions[cid]) {
                this.channelSubscriptions[cid]();
                delete this.channelSubscriptions.cid;
            }
            void this.chatClientService.chatClient.activeChannels[cid]
                ?.stopWatching()
                .catch((err) => this.chatClientService.chatClient.logger('warn', 'Failed to unwatch channel', err));
        }
        if (remainingChannels.length < this.channels.length) {
            this.channelsSubject.next(remainingChannels);
            if (cid === this.activeChannelSubject.getValue()?.cid) {
                if (remainingChannels.length > 0) {
                    this.setAsActiveChannel(remainingChannels[0]);
                }
                else {
                    this.activeChannelSubject.next(undefined);
                }
            }
        }
    }
    async sendMessageRequest(preview, customData, isResend = false) {
        const channel = this.activeChannelSubject.getValue();
        const isThreadReply = !!preview.parent_id;
        isThreadReply
            ? this.activeThreadMessagesSubject.next([
                ...channel.state.threads[preview.parent_id],
            ])
            : this.activeChannelMessagesSubject.next([...channel.state.messages]);
        try {
            const response = await channel.sendMessage({
                id: preview.id,
                text: preview.text,
                attachments: preview.attachments,
                mentioned_users: preview.mentioned_users?.map((u) => u.id),
                parent_id: preview.parent_id,
                quoted_message_id: preview.quoted_message_id,
                ...customData,
            }); // TODO: find out why we need typecast here
            channel.state.addMessageSorted({
                ...response.message,
                status: 'received',
            }, true);
            isThreadReply
                ? this.activeThreadMessagesSubject.next([
                    ...channel.state.threads[preview.parent_id],
                ])
                : this.activeChannelMessagesSubject.next([...channel.state.messages]);
            let messages;
            (isThreadReply ? this.activeThreadMessages$ : this.activeChannelMessages$)
                .pipe(take(1))
                .subscribe((m) => (messages = m));
            const newMessage = messages[messages.length - 1];
            return newMessage;
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        }
        catch (error) {
            const stringError = JSON.stringify(error);
            const parsedError = stringError ? JSON.parse(stringError) : {};
            let isAlreadyExists = false;
            if (isResend) {
                if (parsedError.status === 400 &&
                    parsedError.code === 4 &&
                    parsedError?.response?.data?.message?.includes('already exists')) {
                    isAlreadyExists = true;
                }
            }
            channel.state.addMessageSorted({
                ...preview,
                errorStatusCode: isAlreadyExists
                    ? undefined
                    : parsedError.status || undefined,
                status: isAlreadyExists ? 'received' : 'failed',
            }, true);
            isThreadReply
                ? this.activeThreadMessagesSubject.next([
                    ...channel.state.threads[preview.parent_id],
                ])
                : this.activeChannelMessagesSubject.next([...channel.state.messages]);
            let messages;
            (isThreadReply ? this.activeThreadMessages$ : this.activeChannelMessages$)
                .pipe(take(1))
                .subscribe((m) => (messages = m));
            const newMessage = messages[messages.length - 1];
            return newMessage;
        }
    }
    /**
     * Jumps to the selected message inside the message list, if the message is not yet loaded, it'll load the message (and it's surroundings) from the API.
     * @param messageId The ID of the message to be loaded, 'latest' means jump to the latest messages
     * @param parentMessageId The ID of the parent message if we want to load a thread message
     */
    async jumpToMessage(messageId, parentMessageId) {
        const activeChannel = this.activeChannelSubject.getValue();
        try {
            await activeChannel?.state.loadMessageIntoState(messageId, parentMessageId);
            const messages = activeChannel?.state.messages || [];
            this.activeChannelMessagesSubject.next([...messages]);
            if (parentMessageId) {
                const parentMessage = messages.find((m) => m.id === parentMessageId);
                void this.setAsActiveParentMessage(parentMessage, 'state');
            }
            this.jumpToMessageSubject.next({
                id: messageId,
                parentId: parentMessageId,
            });
        }
        catch (error) {
            this.notificationService.addTemporaryNotification('streamChat.Message not found');
            throw error;
        }
    }
    /**
     * Clears the currently selected message to jump
     */
    clearMessageJump() {
        this.jumpToMessageSubject.next({ id: undefined, parentId: undefined });
    }
    /**
     * Pins the given message in the channel
     * @param message
     */
    async pinMessage(message) {
        try {
            await this.chatClientService.chatClient?.pinMessage(message);
            this.notificationService.addTemporaryNotification('streamChat.Message pinned', 'success');
        }
        catch (error) {
            this.notificationService.addTemporaryNotification('streamChat.Error pinning message');
            throw error;
        }
    }
    /**
     * Removes the given message from pinned messages
     * @param message
     */
    async unpinMessage(message) {
        try {
            await this.chatClientService.chatClient?.unpinMessage(message);
            this.notificationService.addTemporaryNotification('streamChat.Message unpinned', 'success');
        }
        catch (error) {
            this.notificationService.addTemporaryNotification('streamChat.Error removing message pin');
            throw error;
        }
    }
    handleNotification(clientEvent) {
        switch (clientEvent.eventType) {
            case 'connection.recovered': {
                void this.ngZone.run(async () => {
                    if (this.isStateRecoveryInProgress) {
                        return;
                    }
                    this.isStateRecoveryInProgress = true;
                    try {
                        // If channel list is not inited, we set the active channel
                        const shoulSetActiveChannel = this.shouldSetActiveChannel &&
                            !this.activeChannelSubject.getValue();
                        await this.queryChannels(shoulSetActiveChannel || false, 'recover-state');
                        if (this.activeChannelSubject.getValue()) {
                            // Thread messages are not refetched so active thread gets deselected to avoid displaying stale messages
                            void this.setAsActiveParentMessage(undefined);
                            // Update and reselect message to quote
                            const messageToQuote = this.messageToQuoteSubject.getValue();
                            this.setChannelState(this.activeChannelSubject.getValue());
                            let messages;
                            this.activeChannelMessages$
                                .pipe(take(1))
                                .subscribe((m) => (messages = m));
                            const updatedMessageToQuote = messages.find((m) => m.id === messageToQuote?.id);
                            if (updatedMessageToQuote) {
                                this.selectMessageToQuote(updatedMessageToQuote);
                            }
                        }
                        this.isStateRecoveryInProgress = false;
                    }
                    catch {
                        this.isStateRecoveryInProgress = false;
                    }
                });
                break;
            }
            case 'notification.message_new': {
                this.ngZone.run(() => {
                    if (this.customNewMessageNotificationHandler) {
                        this.customNewMessageNotificationHandler(clientEvent, this.channelListSetter);
                    }
                    else {
                        this.handleNewMessageNotification(clientEvent);
                    }
                });
                break;
            }
            case 'notification.added_to_channel': {
                this.ngZone.run(() => {
                    if (this.customAddedToChannelNotificationHandler) {
                        this.customAddedToChannelNotificationHandler(clientEvent, this.channelListSetter);
                    }
                    else {
                        this.handleAddedToChannelNotification(clientEvent);
                    }
                });
                break;
            }
            case 'notification.removed_from_channel': {
                this.ngZone.run(() => {
                    if (this.customRemovedFromChannelNotificationHandler) {
                        this.customRemovedFromChannelNotificationHandler(clientEvent, this.channelListSetter);
                    }
                    else {
                        this.handleRemovedFromChannelNotification(clientEvent);
                    }
                });
                break;
            }
            case 'user.updated': {
                this.ngZone.run(() => {
                    const updatedChannels = this.channelsSubject.getValue()?.map((c) => {
                        if (this.chatClientService.chatClient.activeChannels[c.cid]) {
                            return this.chatClientService.chatClient.activeChannels[c.cid];
                        }
                        else {
                            return c;
                        }
                    });
                    this.channelsSubject.next(updatedChannels);
                    const activeChannel = this.activeChannelSubject.getValue();
                    if (activeChannel) {
                        this.activeChannelSubject.next(this.chatClientService.chatClient.activeChannels[activeChannel.cid] || activeChannel);
                        this.activeChannelMessagesSubject.next(activeChannel.state.messages.map((m) => {
                            m.readBy = getReadBy(m, activeChannel);
                            return { ...m };
                        }));
                        const activeParentMessage = this.activeParentMessageIdSubject.getValue();
                        if (activeParentMessage) {
                            const messages = activeChannel.state.threads[activeParentMessage];
                            this.activeThreadMessagesSubject.next([...messages]);
                        }
                        this.activeChannelPinnedMessagesSubject.next([
                            ...activeChannel.state.pinnedMessages,
                        ]);
                    }
                });
                break;
            }
        }
    }
    handleRemovedFromChannelNotification(clientEvent) {
        const channelIdToBeRemoved = clientEvent.event.channel.cid;
        this.removeChannel(channelIdToBeRemoved, true);
    }
    handleNewMessageNotification(clientEvent) {
        if (clientEvent.event.channel) {
            void this.addChannelFromNotification(clientEvent.event.channel);
        }
    }
    handleAddedToChannelNotification(clientEvent) {
        if (clientEvent.event.channel) {
            void this.addChannelFromNotification(clientEvent.event.channel);
        }
    }
    async addChannelFromNotification(channelResponse) {
        const newChannel = this.chatClientService.chatClient.channel(channelResponse.type, channelResponse.id);
        let currentChannels = this.channelsSubject.getValue() || [];
        if (currentChannels.find((c) => c.cid === newChannel.cid)) {
            return;
        }
        await newChannel.watch().catch((err) => {
            this.chatClientService.chatClient.logger('error', 'Failed to add channel to channel list because watch request failed', err);
        });
        currentChannels = this.channelsSubject.getValue() || [];
        if (currentChannels.find((c) => c.cid === newChannel.cid)) {
            return;
        }
        this.watchForChannelEvents(newChannel);
        this.channelsSubject.next([newChannel, ...currentChannels]);
    }
    watchForActiveChannelEvents(channel) {
        this.activeChannelSubscriptions.push(channel.on('message.new', (event) => {
            this.ngZone.run(() => {
                event.message && event.message.parent_id
                    ? event.message.parent_id ===
                        this.activeParentMessageIdSubject.getValue()
                        ? this.activeThreadMessagesSubject.next([
                            ...channel.state.threads[event.message.parent_id],
                        ])
                        : null
                    : this.activeChannelMessagesSubject.next([
                        ...channel.state.messages,
                    ]);
                this.activeChannel$.pipe(first()).subscribe((c) => {
                    if (c) {
                        this.markRead(c);
                    }
                });
                this.updateLatestMessages(event);
            });
        }));
        this.activeChannelSubscriptions.push(channel.on('message.updated', (event) => this.messageUpdated(event)));
        this.activeChannelSubscriptions.push(channel.on('message.deleted', (event) => this.messageUpdated(event)));
        this.activeChannelSubscriptions.push(channel.on('reaction.new', (e) => this.messageReactionEventReceived(e)));
        this.activeChannelSubscriptions.push(channel.on('reaction.deleted', (e) => this.messageReactionEventReceived(e)));
        this.activeChannelSubscriptions.push(channel.on('reaction.updated', (e) => this.messageReactionEventReceived(e)));
        this.activeChannelSubscriptions.push(channel.on('message.read', (e) => {
            this.ngZone.run(() => {
                let latestMessage;
                let messages;
                this.activeChannelMessages$.pipe(first()).subscribe((m) => {
                    messages = m;
                    latestMessage = messages[messages.length - 1];
                });
                if (!latestMessage || !e.user) {
                    return;
                }
                if (latestMessage.readBy) {
                    latestMessage.readBy.splice(0, latestMessage.readBy.length);
                }
                else {
                    latestMessage.readBy = [];
                }
                latestMessage.readBy.push(...getReadBy(latestMessage, channel));
                messages[messages.length - 1] = { ...latestMessage };
                this.activeChannelMessagesSubject.next([...messages]);
            });
        }));
        this.activeChannelSubscriptions.push(this.chatClientService.events$
            .pipe(filter((e) => e.eventType === 'notification.mark_unread' &&
            e.event.channel_id === channel.id), map((e) => e.event))
            .subscribe((e) => {
            this.ngZone.run(() => {
                this.activeChannelLastReadMessageId = e.last_read_message_id;
                this.activeChannelUnreadCount = e.unread_messages;
                this.activeChannelSubject.next(this.activeChannel);
            });
        }));
        this.activeChannelSubscriptions.push(channel.on('typing.start', (e) => this.ngZone.run(() => this.handleTypingStartEvent(e))));
        this.activeChannelSubscriptions.push(channel.on('typing.stop', (e) => this.ngZone.run(() => this.handleTypingStopEvent(e))));
    }
    /**
     * Call this method if user started typing in the active channel
     * @param parentId The id of the parent message, if user is typing in a thread
     */
    async typingStarted(parentId) {
        const activeChannel = this.activeChannelSubject.getValue();
        await activeChannel?.keystroke(parentId);
    }
    /**
     * Call this method if user stopped typing in the active channel
     * @param parentId The id of the parent message, if user were typing in a thread
     */
    async typingStopped(parentId) {
        const activeChannel = this.activeChannelSubject.getValue();
        await activeChannel?.stopTyping(parentId);
    }
    /**
     * The current list of channels
     */
    get channels() {
        return this.channelsSubject.getValue() || [];
    }
    /**
     * The current active channel
     */
    get activeChannel() {
        return this.activeChannelSubject.getValue() || undefined;
    }
    /**
     * The current active channel messages
     */
    get activeChannelMessages() {
        return this.activeChannelMessagesSubject.getValue() || [];
    }
    /**
     * Get the last 1200 reactions of a message in the current active channel. If you need to fetch more reactions please use the [following endpoint](https://getstream.io/chat/docs/javascript/send_reaction/?language=javascript#paginating-reactions).
     * @param messageId
     * @returns all reactions of a message
     */
    async getMessageReactions(messageId) {
        const reactions = [];
        const limit = 300;
        let offset = 0;
        const reactionsLimit = ChannelService.MAX_MESSAGE_REACTIONS_TO_FETCH;
        let lastPageSize = limit;
        while (lastPageSize === limit && reactions.length < reactionsLimit) {
            try {
                const response = await this.activeChannel?.getReactions(messageId, {
                    offset,
                    limit,
                });
                lastPageSize = response?.reactions?.length || 0;
                if (lastPageSize > 0) {
                    reactions.push(...response.reactions);
                }
                offset += lastPageSize;
            }
            catch (e) {
                this.notificationService.addTemporaryNotification('streamChat.Error loading reactions');
                throw e;
            }
        }
        return reactions;
    }
    /**
     * Marks the channel from the given message as unread
     * @param messageId
     * @returns the result of the request
     */
    async markMessageUnread(messageId) {
        if (!this.activeChannel) {
            return;
        }
        try {
            const response = await this.activeChannel.markUnread({
                message_id: messageId,
            });
            this.areReadEventsPaused = true;
            return response;
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        }
        catch (e) {
            const error = JSON.parse(JSON.stringify(e));
            const data = error?.response?.data;
            if (data &&
                data.code === 4 &&
                data.StatusCode === 400 &&
                data.message?.includes('it is older than last')) {
                const count = /\d+ channel messages/
                    .exec(data.message)?.[0]
                    .match(/\d+/)?.[0];
                if (count) {
                    this.notificationService.addTemporaryNotification('streamChat.Error, only the first {{count}} message can be marked as unread', undefined, undefined, { count });
                    throw e;
                }
            }
            this.notificationService.addTemporaryNotification('streamChat.Error marking message as unread');
            throw e;
        }
    }
    messageUpdated(event) {
        this.ngZone.run(() => {
            const isThreadReply = event.message && event.message.parent_id;
            const channel = this.activeChannelSubject.getValue();
            if (!channel) {
                return;
            }
            // Get messages from state as message order could change, and message could've been deleted
            const messages = isThreadReply
                ? channel.state.threads[event?.message?.parent_id || '']
                : channel.state.messages;
            if (!messages) {
                return;
            }
            const messageIndex = messages.findIndex((m) => m.id === event?.message?.id);
            if (messageIndex !== -1) {
                isThreadReply
                    ? this.activeThreadMessagesSubject.next([...messages])
                    : this.activeChannelMessagesSubject.next([...messages]);
                this.activeChannelPinnedMessagesSubject.next([
                    ...channel.state.pinnedMessages,
                ]);
            }
        });
    }
    messageReactionEventReceived(e) {
        this.ngZone.run(() => {
            const isThreadMessage = e.message && e.message.parent_id;
            let messages;
            (isThreadMessage
                ? this.activeThreadMessages$
                : this.activeChannelMessages$)
                .pipe(first())
                .subscribe((m) => (messages = m));
            const messageIndex = messages.findIndex((m) => m.id === e?.message?.id);
            if (messageIndex === -1) {
                return;
            }
            const message = messages[messageIndex];
            message.reaction_counts = { ...e.message?.reaction_counts };
            message.reaction_scores = { ...e.message?.reaction_scores };
            message.latest_reactions = [...(e.message?.latest_reactions || [])];
            message.own_reactions = [...(e.message?.own_reactions || [])];
            messages[messageIndex] = { ...message };
            isThreadMessage
                ? this.activeThreadMessagesSubject.next([...messages])
                : this.activeChannelMessagesSubject.next([...messages]);
        });
    }
    formatMessage(message) {
        const m = message;
        m.pinned_at = message.pinned_at ? new Date(message.pinned_at) : null;
        m.created_at = message.created_at
            ? new Date(message.created_at)
            : new Date();
        m.updated_at = message.updated_at
            ? new Date(message.updated_at)
            : new Date();
        message.status = message.status || 'received';
        return m;
    }
    isStreamMessage(message) {
        return !!message.readBy;
    }
    isFormatMessageResponse(message) {
        return message.created_at instanceof Date;
    }
    stopWatchForActiveChannelEvents(channel) {
        if (!channel) {
            return;
        }
        this.activeChannelSubscriptions.forEach((s) => s.unsubscribe());
        this.activeChannelSubscriptions = [];
    }
    async queryChannels(shouldSetActiveChannel, queryType) {
        if (!this.channelQuery) {
            throw new Error('Query channels called before initializing ChannelQuery instance');
        }
        try {
            this.channelQueryStateSubject.next({ state: 'in-progress' });
            const { channels, hasMorePage } = await ('query' in this.channelQuery
                ? this.channelQuery.query(queryType)
                : this.channelQuery(queryType));
            const filteredChannels = channels.filter((channel, index) => !channels.slice(0, index).find((c) => c.cid === channel.cid));
            filteredChannels.forEach((c) => {
                if (!this.channelSubscriptions[c.cid]) {
                    this.watchForChannelEvents(c);
                }
            });
            this.channelsSubject.next(filteredChannels);
            const currentActiveChannel = this.activeChannelSubject.getValue();
            if (currentActiveChannel &&
                !filteredChannels.find((c) => c.cid === currentActiveChannel?.cid)) {
                this.deselectActiveChannel();
            }
            else if (filteredChannels.length > 0 &&
                !currentActiveChannel &&
                shouldSetActiveChannel) {
                this.setAsActiveChannel(filteredChannels[0]);
            }
            this.hasMoreChannelsSubject.next(hasMorePage);
            this.channelQueryStateSubject.next({ state: 'success' });
            this.dismissErrorNotification?.();
            return channels;
        }
        catch (error) {
            this.channelQueryStateSubject.next({
                state: 'error',
                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                error,
            });
            throw error;
        }
    }
    watchForChannelEvents(channel) {
        if (this.channelSubscriptions[channel.cid]) {
            this.channelSubscriptions[channel.cid]();
        }
        const unsubscribe = channel.on((event) => {
            // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion
            const type = event.type;
            switch (type) {
                case 'message.new': {
                    this.ngZone.run(() => {
                        if (this.customNewMessageHandler) {
                            this.customNewMessageHandler(event, channel, this.channelListSetter, this.messageListSetter, this.threadListSetter, this.parentMessageSetter);
                        }
                        else {
                            this.handleNewMessage(event, channel);
                        }
                    });
                    break;
                }
                case 'channel.hidden': {
                    this.ngZone.run(() => {
                        if (this.customChannelHiddenHandler) {
                            this.customChannelHiddenHandler(event, channel, this.channelListSetter, this.messageListSetter, this.threadListSetter, this.parentMessageSetter);
                        }
                        else {
                            this.handleChannelHidden(event);
                        }
                    });
                    break;
                }
                case 'channel.deleted': {
                    this.ngZone.run(() => {
                        if (this.customChannelDeletedHandler) {
                            this.customChannelDeletedHandler(event, channel, this.channelListSetter, this.messageListSetter, this.threadListSetter, this.parentMessageSetter);
                        }
                        else {
                            this.handleChannelDeleted(event);
                        }
                    });
                    break;
                }
                case 'channel.visible': {
                    this.ngZone.run(() => {
                        if (this.customChannelVisibleHandler) {
                            this.customChannelVisibleHandler(event, channel, this.channelListSetter, this.messageListSetter, this.threadListSetter, this.parentMessageSetter);
                        }
                        else {
                            this.handleChannelVisible(event, channel);
                        }
                    });
                    break;
                }
                case 'channel.updated': {
                    this.ngZone.run(() => {
                        if (this.customChannelUpdatedHandler) {
                            this.customChannelUpdatedHandler(event, channel, this.channelListSetter, this.messageListSetter, this.threadListSetter, this.parentMessageSetter);
                        }
                        else {
                            this.handleChannelUpdate(event);
                        }
                    });
                    break;
                }
                case 'channel.truncated': {
                    this.ngZone.run(() => {
                        if (this.customChannelTruncatedHandler) {
                            this.customChannelTruncatedHandler(event, channel, this.channelListSetter, this.messageListSetter, this.threadListSetter, this.parentMessageSetter);
                        }
                        else {
                            this.handleChannelTruncate(event);
                        }
                    });
                    break;
                }
                case 'capabilities.changed': {
                    this.ngZone.run(() => {
                        const cid = event.cid;
                        if (cid) {
                            const currentChannels = this.channelsSubject.getValue();
                            const index = currentChannels?.findIndex((c) => c.cid === cid);
                            if (index !== -1 && index !== undefined) {
                                this.channelsSubject.next([...currentChannels]);
                                if (cid === this.activeChannelSubject.getValue()?.cid) {
                                    this.activeChannelSubject.next(this.activeChannelSubject.getValue());
                                }
                            }
                        }
                    });
                    break;
                }
            }
        });
        this.channelSubscriptions[channel.cid] = unsubscribe.unsubscribe;
    }
    handleNewMessage(_, channel) {
        const channelIndex = this.channels.findIndex((c) => c.cid === channel.cid);
        this.channels.splice(channelIndex, 1);
        this.channelsSubject.next([channel, ...this.channels]);
    }
    handleChannelHidden(event) {
        this.removeChannel(event.channel.cid, false);
    }
    handleChannelDeleted(event) {
        this.removeChannel(event.channel.cid, false);
    }
    handleChannelVisible(event, channel) {
        if (!this.channels.find((c) => c.cid === event.cid)) {
            this.ngZone.run(() => this.channelsSubject.next([...this.channels, channel]));
        }
    }
    handleChannelUpdate(event) {
        const channelIndex = this.channels.findIndex((c) => c.cid === event.channel.cid);
        if (channelIndex !== -1) {
            const channel = this.channels[channelIndex];
            const notIncludedProperies = {
                hidden: channel.data?.hidden || false,
                own_capabilities: channel.data?.own_capabilities || [],
            };
            channel.data = {
                ...event.channel,
                ...notIncludedProperies,
            };
            this.channelsSubject.next([...this.channels]);
            if (event.channel?.cid === this.activeChannelSubject.getValue()?.cid) {
                this.activeChannelSubject.next(channel);
            }
        }
    }
    handleChannelTruncate(event) {
        const channelIndex = this.channels.findIndex((c) => c.cid === event.channel.cid);
        if (channelIndex !== -1) {
            this.channels[channelIndex].state.messages = [];
            this.channelsSubject.next([...this.channels]);
            if (event.channel?.cid === this.activeChannelSubject.getValue()?.cid) {
                const channel = this.activeChannelSubject.getValue();
                channel.state.messages = [];
                this.activeChannelSubject.next(channel);
                this.activeChannelMessagesSubject.next([]);
                this.activeParentMessageIdSubject.next(undefined);
                this.activeThreadMessagesSubject.next([]);
            }
        }
    }
    get canSendReadEvents() {
        const channel = this.activeChannelSubject.getValue();
        if (!channel) {
            return false;
        }
        const capabilites = channel.data?.own_capabilities;
        return capabilites.indexOf('read-events') !== -1;
    }
    transformToStreamMessage(message, channel) {
        const isThreadMessage = !!message.parent_id;
        if (this.isStreamMessage(message) &&
            this.isFormatMessageResponse(message)) {
            if (message.quoted_message) {
                message.quoted_message.translation = getMessageTranslation(message.quoted_message, channel, this.chatClientService.chatClient.user);
            }
            message.translation = getMessageTranslation(message, channel, this.chatClientService.chatClient.user);
            return message;
        }
        else {
            if (message.quoted_message) {
                message.quoted_message.translation = getMessageTranslation(message.quoted_message, channel, this.chatClientService.chatClient.user);
            }
            if (this.isFormatMessageResponse(message)) {
                message.readBy = isThreadMessage
                    ? []
                    : channel
                        ? getReadBy(message, channel)
                        : [];
                message.translation = getMessageTranslation(message, channel, this.chatClientService.chatClient.user);
                return message;
            }
            else {
                message = this.formatMessage(message);
                message.readBy = isThreadMessage
                    ? []
                    : channel
                        ? getReadBy(message, channel)
                        : [];
                message.translation = getMessageTranslation(message, channel, this.chatClientService.chatClient.user);
                return message;
            }
        }
    }
    handleTypingStartEvent(event) {
        if (event.user?.id === this.chatClientService.chatClient.user?.id) {
            return;
        }
        const isTypingInThread = !!event.parent_id;
        if (isTypingInThread &&
            event.parent_id !== this.activeParentMessageIdSubject.getValue()) {
            return;
        }
        const subject = isTypingInThread
            ? this.usersTypingInThreadSubject
            : this.usersTypingInChannelSubject;
        const users = subject.getValue();
        const user = event.user;
        if (user && !users.find((u) => u.id === user.id)) {
            users.push(user);
            subject.next([...users]);
        }
    }
    handleTypingStopEvent(event) {
        const usersTypingInChannel = this.usersTypingInChannelSubject.getValue();
        const usersTypingInThread = this.usersTypingInThreadSubject.getValue();
        const user = event.user;
        if (user && usersTypingInChannel.find((u) => u.id === user.id)) {
            usersTypingInChannel.splice(usersTypingInChannel.findIndex((u) => u.id === user.id), 1);
            this.usersTypingInChannelSubject.next([...usersTypingInChannel]);
            return;
        }
        if (user && usersTypingInThread.find((u) => u.id === user.id)) {
            usersTypingInThread.splice(usersTypingInThread.findIndex((u) => u.id === user.id), 1);
            this.usersTypingInThreadSubject.next([...usersTypingInThread]);
            return;
        }
    }
    updateLatestMessages(event) {
        if (event.message?.user?.id !== this.chatClientService?.chatClient.user?.id) {
            return;
        }
        const latestMessages = this.latestMessageDateByUserByChannelsSubject.getValue();
        if (!event.message?.created_at) {
            return;
        }
        const channelId = event?.message?.cid;
        if (!channelId) {
            return;
        }
        const messageDate = new Date(event.message.created_at);
        if (!latestMessages[channelId] ||
            latestMessages[channelId]?.getTime() < messageDate.getTime()) {
            latestMessages[channelId] = messageDate;
            this.latestMessageDateByUserByChannelsSubject.next({
                ...latestMessages,
            });
        }
    }
    setChannelState(channel) {
        channel.state.messages.forEach((m) => {
            m.readBy = getReadBy(m, channel);
            m.translation = getMessageTranslation(m, channel, this.chatClientService.chatClient.user);
            if (m.quoted_message) {
                m.quoted_message.translation = getMessageTranslation(m.quoted_message, channel, this.chatClientService.chatClient.user);
            }
        });
        this.markRead(channel);
        this.activeChannelMessagesSubject.next([...channel.state.messages]);
        this.activeChannelPinnedMessagesSubject.next([
            ...channel.state.pinnedMessages,
        ]);
        this.activeParentMessageIdSubject.next(undefined);
        this.activeThreadMessagesSubject.next([]);
        this.messageToQuoteSubject.next(undefined);
        this.usersTypingInChannelSubject.next([]);
        this.usersTypingInThreadSubject.next([]);
    }
    markRead(channel) {
        if (this.canSendReadEvents &&
            this.shouldMarkActiveChannelAsRead &&
            !this.areReadEventsPaused) {
            void channel.markRead();
        }
    }
    async _init(settings) {
        this.shouldSetActiveChannel = settings.shouldSetActiveChannel;
        this.messagePageSize = settings.messagePageSize;
        this.clientEventsSubscription = this.chatClientService.events$.subscribe((notification) => void this.handleNotification(notification));
        try {
            const result = await this.queryChannels(this.shouldSetActiveChannel, 'first-page');
            return result;
        }
        catch (error) {
            this.dismissErrorNotification =
                this.notificationService.addPermanentNotification('streamChat.Error loading channels', 'error');
            throw error;
        }
    }
}
/**
 * @internal
 */
ChannelService.MAX_MESSAGE_COUNT_IN_MESSAGE_LIST = 250;
/**
 * @internal
 */
ChannelService.MAX_MESSAGE_REACTIONS_TO_FETCH = 1200;
ChannelService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: ChannelService, deps: [{ token: ChatClientService }, { token: i0.NgZone }, { token: NotificationService }], target: i0.ɵɵFactoryTarget.Injectable });
ChannelService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: ChannelService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: ChannelService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: ChatClientService }, { type: i0.NgZone }, { type: NotificationService }]; } });

/**
 * The `ThemeService` can be used to change the theme of the chat UI and to customize the theme. Our [theming guide](../theming/introduction.mdx) gives a complete overview about the topic.
 */
class ThemeService {
    constructor() {
        /**
         * A Subject that can be used to get or set the currently active theme. By default light and dark themes are supported.
         */
        this.theme$ = new BehaviorSubject('light');
    }
}
ThemeService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: ThemeService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
ThemeService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: ThemeService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: ThemeService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return []; } });

const isImageFile = (file) => {
    // photoshop files begin with 'image/'
    return file.type.startsWith('image/') && !file.type.endsWith('.photoshop');
};

const isImageAttachment = (attachment) => {
    return (attachment.type === 'image' &&
        !attachment.title_link &&
        !attachment.og_scrape_url);
};

/**
 * The `AttachmentService` manages the uploads of a message input.
 *
 * You can read more about [uploads](https://getstream.io/chat/docs/javascript/file_uploads/?language=javascript&q=size) in the Stream API documentation. You can use Stream's API or the dashboard to customize the [file](https://getstream.io/chat/docs/javascript/app_setting_overview/?language=javascript&q=size#file-uploads) and [image upload](https://getstream.io/chat/docs/javascript/app_setting_overview/?language=javascript&q=size#image-uploads) configuration.
 */
class AttachmentService {
    constructor(channelService, notificationService, chatClientService) {
        this.channelService = channelService;
        this.notificationService = notificationService;
        this.chatClientService = chatClientService;
        this.attachmentUploadInProgressCounterSubject = new BehaviorSubject(0);
        this.attachmentUploadsSubject = new BehaviorSubject([]);
        this.attachmentUploadInProgressCounter$ =
            this.attachmentUploadInProgressCounterSubject.asObservable();
        this.attachmentUploads$ = this.attachmentUploadsSubject.asObservable();
        this.chatClientService.appSettings$.subscribe((appSettings) => (this.appSettings = appSettings));
    }
    /**
     * Resets the attachments uploads (for example after the message with the attachments sent successfully)
     */
    resetAttachmentUploads() {
        this.attachmentUploadsSubject.next([]);
    }
    /**
     * Uploads the selected files, and creates preview for image files. The result is propagated throught the `attachmentUploads$` stream.
     * @param fileList The files selected by the user, if you have Blobs instead of Files, you can convert them with this method: https://developer.mozilla.org/en-US/docs/Web/API/File/File
     * @returns A promise with true or false. If false is returned the upload was canceled because of a client side error. The error is emitted via the `NotificationService`.
     */
    async filesSelected(fileList) {
        if (!fileList) {
            return;
        }
        const files = Array.from(fileList);
        if (!(await this.areAttachmentsHaveValidExtension(files))) {
            return false;
        }
        if (!(await this.areAttachmentsHaveValidSize(files))) {
            return false;
        }
        const imageFiles = [];
        const dataFiles = [];
        const videoFiles = [];
        files.forEach((file) => {
            if (isImageFile(file)) {
                imageFiles.push(file);
            }
            else if (file.type.startsWith('video/')) {
                videoFiles.push(file);
            }
            else {
                dataFiles.push(file);
            }
        });
        imageFiles.forEach((f) => this.createPreview(f));
        const newUploads = [
            ...imageFiles.map((file) => ({
                file,
                state: 'uploading',
                type: 'image',
            })),
            ...videoFiles.map((file) => ({
                file,
                state: 'uploading',
                type: 'video',
            })),
            ...dataFiles.map((file) => ({
                file,
                state: 'uploading',
                type: 'file',
            })),
        ];
        this.attachmentUploadsSubject.next([
            ...this.attachmentUploadsSubject.getValue(),
            ...newUploads,
        ]);
        await this.uploadAttachments(newUploads);
        return true;
    }
    /**
     * You can add custom `image`, `video` and `file` attachments using this method.
     *
     * Note: If you just want to use your own CDN for file uploads, you don't necessary need this method, you can just specify you own upload function in the [`ChannelService`](./ChannelService.mdx)
     * @param attachment
     */
    addAttachment(attachment) {
        attachment.isCustomAttachment = true;
        this.createFromAttachments([attachment]);
    }
    /**
     * Retries to upload an attachment.
     * @param file
     * @returns A promise with the result
     */
    async retryAttachmentUpload(file) {
        const attachmentUploads = this.attachmentUploadsSubject.getValue();
        const upload = attachmentUploads.find((u) => u.file === file);
        if (!upload) {
            return;
        }
        upload.state = 'uploading';
        this.attachmentUploadsSubject.next([...attachmentUploads]);
        await this.uploadAttachments([upload]);
    }
    /**
     * Deletes an attachment, the attachment can have any state (`error`, `uploading` or `success`).
     * @param upload
     */
    async deleteAttachment(upload) {
        const attachmentUploads = this.attachmentUploadsSubject.getValue();
        let result;
        if (upload.state === 'success' &&
            !upload.fromAttachment?.isCustomAttachment) {
            try {
                await this.channelService.deleteAttachment(upload);
                result = [...attachmentUploads];
                const index = attachmentUploads.indexOf(upload);
                result.splice(index, 1);
            }
            catch (error) {
                result = attachmentUploads;
                this.notificationService.addTemporaryNotification('streamChat.Error deleting attachment');
            }
        }
        else {
            result = [...attachmentUploads];
            const index = attachmentUploads.indexOf(upload);
            result.splice(index, 1);
        }
        this.attachmentUploadsSubject.next([...result]);
    }
    /**
     * Maps the current uploads to a format that can be sent along with the message to the Stream API.
     * @returns the attachments
     */
    mapToAttachments() {
        const attachmentUploads = this.attachmentUploadsSubject.getValue();
        return attachmentUploads
            .filter((r) => r.state === 'success')
            .map((r) => {
            const attachment = {
                type: r.type,
            };
            if (r.fromAttachment) {
                return r.fromAttachment;
            }
            else {
                attachment.mime_type = r.file?.type;
                if (r.type === 'image') {
                    attachment.fallback = r.file?.name;
                    attachment.image_url = r.url;
                }
                else {
                    attachment.asset_url = r.url;
                    attachment.title = r.file?.name;
                    attachment.file_size = r.file?.size;
                    attachment.thumb_url = r.thumb_url;
                }
            }
            return attachment;
        });
    }
    /**
     * Maps attachments received from the Stream API to uploads. This is useful when editing a message.
     * @param attachments Attachemnts received with the message
     */
    createFromAttachments(attachments) {
        const attachmentUploads = [];
        attachments.forEach((attachment) => {
            if (isImageAttachment(attachment)) {
                attachmentUploads.push({
                    url: (attachment.img_url ||
                        attachment.thumb_url ||
                        attachment.image_url),
                    state: 'success',
                    type: 'image',
                    file: {
                        name: attachment.fallback,
                        type: attachment.mime_type,
                    },
                    fromAttachment: attachment,
                });
            }
            else if (attachment.type === 'file' || attachment.type === 'video') {
                attachmentUploads.push({
                    url: attachment.asset_url,
                    state: 'success',
                    file: {
                        name: attachment.title,
                        size: attachment.file_size,
                        type: attachment.mime_type,
                    },
                    type: attachment.type,
                    thumb_url: attachment.thumb_url,
                    fromAttachment: attachment,
                });
            }
        });
        if (attachmentUploads.length > 0) {
            this.attachmentUploadsSubject.next([
                ...this.attachmentUploadsSubject.getValue(),
                ...attachmentUploads,
            ]);
        }
    }
    createPreview(file) {
        const reader = new FileReader();
        reader.onload = (event) => {
            const attachmentUploads = this.attachmentUploadsSubject.getValue();
            const upload = attachmentUploads.find((upload) => upload.file === file);
            if (!upload) {
                return;
            }
            upload.previewUri = event.target?.result || undefined;
            this.attachmentUploadsSubject.next([...attachmentUploads]);
        };
        reader.readAsDataURL(file);
    }
    async uploadAttachments(uploads) {
        this.attachmentUploadInProgressCounterSubject.next(this.attachmentUploadInProgressCounterSubject.getValue() + 1);
        const result = await this.channelService.uploadAttachments(uploads);
        const attachmentUploads = this.attachmentUploadsSubject.getValue();
        result.forEach((r) => {
            const upload = attachmentUploads.find((upload) => upload.file === r.file);
            if (!upload) {
                if (r.url) {
                    void this.channelService.deleteAttachment(r);
                }
                return;
            }
            upload.state = r.state;
            upload.url = r.url;
            upload.thumb_url = r.thumb_url;
            if (upload.state === 'error') {
                upload.errorReason = r.errorReason;
                upload.errorExtraInfo = r.errorExtraInfo;
                let errorKey;
                const translateParams = { name: upload.file.name };
                switch (upload.errorReason) {
                    case 'file-extension':
                        errorKey =
                            'streamChat.Error uploading file, extension not supported';
                        translateParams.ext = upload.errorExtraInfo?.[0]?.param;
                        break;
                    case 'file-size':
                        errorKey =
                            'streamChat.Error uploading file, maximum file size exceeded';
                        translateParams.limit = upload.errorExtraInfo?.[0]?.param;
                        break;
                    default:
                        errorKey = 'streamChat.Error uploading file';
                }
                this.notificationService.addTemporaryNotification(errorKey, 'error', undefined, translateParams);
            }
        });
        this.attachmentUploadInProgressCounterSubject.next(this.attachmentUploadInProgressCounterSubject.getValue() - 1);
        this.attachmentUploadsSubject.next([...attachmentUploads]);
    }
    async areAttachmentsHaveValidExtension(files) {
        if (!this.appSettings) {
            try {
                await this.chatClientService.getAppSettings();
            }
            catch (error) {
                return true;
            }
        }
        let isValid = true;
        files.forEach((f) => {
            let hasBlockedExtension;
            let hasBlockedMimeType;
            let hasNotAllowedExtension;
            let hasNotAllowedMimeType;
            if (isImageFile(f)) {
                hasBlockedExtension =
                    !!this.appSettings?.image_upload_config?.blocked_file_extensions?.find((ext) => f.name.endsWith(ext));
                hasBlockedMimeType =
                    !!this.appSettings?.image_upload_config?.blocked_mime_types?.find((type) => f.type === type);
                hasNotAllowedExtension =
                    !!this.appSettings?.image_upload_config?.allowed_file_extensions
                        ?.length &&
                        !this.appSettings?.image_upload_config?.allowed_file_extensions?.find((ext) => f.name.endsWith(ext));
                hasNotAllowedMimeType =
                    !!this.appSettings?.image_upload_config?.allowed_mime_types?.length &&
                        !this.appSettings?.image_upload_config?.allowed_mime_types?.find((type) => f.type === type);
            }
            else {
                hasBlockedExtension =
                    !!this.appSettings?.file_upload_config?.blocked_file_extensions?.find((ext) => f.name.endsWith(ext));
                hasBlockedMimeType =
                    !!this.appSettings?.file_upload_config?.blocked_mime_types?.find((type) => f.type === type);
                hasNotAllowedExtension =
                    !!this.appSettings?.file_upload_config?.allowed_file_extensions
                        ?.length &&
                        !this.appSettings?.file_upload_config?.allowed_file_extensions?.find((ext) => f.name.endsWith(ext));
                hasNotAllowedMimeType =
                    !!this.appSettings?.file_upload_config?.allowed_mime_types?.length &&
                        !this.appSettings?.file_upload_config?.allowed_mime_types?.find((type) => f.type === type);
            }
            if (hasBlockedExtension ||
                hasBlockedMimeType ||
                hasNotAllowedExtension ||
                hasNotAllowedMimeType) {
                this.notificationService.addTemporaryNotification('streamChat.Error uploading file, extension not supported', undefined, undefined, { name: f.name, ext: f.type });
                isValid = false;
            }
        });
        return isValid;
    }
    async areAttachmentsHaveValidSize(files) {
        if (!this.appSettings) {
            try {
                await this.chatClientService.getAppSettings();
            }
            catch (error) {
                return true;
            }
        }
        const imageSizeLimitInBytes = this.appSettings?.image_upload_config?.size_limit || 0;
        const imageSizeLimiString = `${imageSizeLimitInBytes / (1024 * 1024)}MB`;
        const fileSizeLimitInBytes = this.appSettings?.file_upload_config?.size_limit || 0;
        const fileSizeLimitInString = `${fileSizeLimitInBytes / (1024 * 1024)}MB`;
        let isValid = true;
        files.forEach((f) => {
            let isOverSized = false;
            let limit = '';
            if (isImageFile(f) && imageSizeLimitInBytes > 0) {
                isOverSized = f.size > imageSizeLimitInBytes;
                limit = imageSizeLimiString;
            }
            else if (fileSizeLimitInBytes > 0) {
                isOverSized = f.size > fileSizeLimitInBytes;
                limit = fileSizeLimitInString;
            }
            if (isOverSized) {
                this.notificationService.addTemporaryNotification('streamChat.Error uploading file, maximum file size exceeded', undefined, undefined, { name: f.name, limit: limit });
                isValid = false;
            }
        });
        return isValid;
    }
}
AttachmentService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: AttachmentService, deps: [{ token: ChannelService }, { token: NotificationService }, { token: ChatClientService }], target: i0.ɵɵFactoryTarget.Injectable });
AttachmentService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: AttachmentService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: AttachmentService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: ChannelService }, { type: NotificationService }, { type: ChatClientService }]; } });

/**
 * The `AttachmentConfigurationService` provides customization for certain attributes of attachments displayed inside the message component. If you're using your own CDN, you can integrate resizing features of it by providing your own handlers.
 */
class AttachmentConfigurationService {
    constructor() {
        /**
         * You can turn on/off thumbnail generation for video attachments
         */
        this.shouldGenerateVideoThumbnail = true;
    }
    /**
     * Handles the configuration for image attachments, it's possible to provide your own function to override the default logic
     * @param attachment The attachment to configure
     * @param location Specifies where the image is being displayed
     * @param element The default resizing logics reads the height/max-height and max-width propperties of this element and reduces file size based on the given values. File size reduction is done by Stream's CDN.
     */
    getImageAttachmentConfiguration(attachment, location, element) {
        if (this.customImageAttachmentConfigurationHandler) {
            return this.customImageAttachmentConfigurationHandler(attachment, location, element);
        }
        const defaultOriginalDimension = 1000000;
        const urlString = (attachment.img_url ||
            attachment.thumb_url ||
            attachment.image_url ||
            '');
        let url;
        try {
            url = new URL(urlString);
        }
        catch (error) {
            return {
                url: urlString,
                width: '',
                height: '',
                originalHeight: defaultOriginalDimension,
                originalWidth: defaultOriginalDimension,
            };
        }
        const originalHeight = Number(url.searchParams.get('oh')) > 1
            ? Number(url.searchParams.get('oh'))
            : defaultOriginalDimension;
        const originalWidth = Number(url.searchParams.get('ow')) > 1
            ? Number(url.searchParams.get('ow'))
            : defaultOriginalDimension;
        const displayWarning = location === 'gallery' || location === 'single';
        const sizeRestriction = this.getSizingRestrictions(url, element, displayWarning);
        if (sizeRestriction) {
            // Apply 2x for retina displays
            sizeRestriction.height *= 2;
            sizeRestriction.width *= 2;
            this.addResizingParamsToUrl(sizeRestriction, url);
        }
        return {
            url: url.href,
            width: '',
            height: '',
            originalHeight,
            originalWidth,
        };
    }
    /**
     * Handles the configuration for video attachments, it's possible to provide your own function to override the default logic
     * @param attachment The attachment to configure
     * @param element The default resizing logics reads the height/max-height and max-width propperties of this element and reduces file size based on the given values. File size reduction is done by Stream's CDN.
     */
    getVideoAttachmentConfiguration(attachment, element) {
        if (this.customVideoAttachmentConfigurationHandler) {
            return this.customVideoAttachmentConfigurationHandler(attachment, element);
        }
        let thumbUrl = undefined;
        let originalHeight = 1000000;
        let originalWidth = 1000000;
        if (attachment.thumb_url && this.shouldGenerateVideoThumbnail) {
            let url;
            try {
                url = new URL(attachment.thumb_url);
                originalHeight =
                    Number(url.searchParams.get('oh')) > 1
                        ? Number(url.searchParams.get('oh'))
                        : originalHeight;
                originalWidth =
                    Number(url.searchParams.get('ow')) > 1
                        ? Number(url.searchParams.get('ow'))
                        : originalWidth;
                const displayWarning = true;
                const sizeRestriction = this.getSizingRestrictions(url, element, displayWarning);
                if (sizeRestriction) {
                    sizeRestriction.height *= 2;
                    sizeRestriction.width *= 2;
                    this.addResizingParamsToUrl(sizeRestriction, url);
                }
                thumbUrl = url.href;
            }
            catch {
                thumbUrl = attachment.thumb_url;
            }
        }
        return {
            url: attachment.asset_url || '',
            width: '',
            height: '',
            thumbUrl: thumbUrl,
            originalHeight,
            originalWidth,
        };
    }
    /**
     * Handles the configuration for giphy attachments, it's possible to provide your own function to override the default logic
     * @param attachment The attachment to configure
     */
    getGiphyAttachmentConfiguration(attachment) {
        if (this.customGiphyAttachmentConfigurationHandler) {
            return this.customGiphyAttachmentConfigurationHandler(attachment);
        }
        const giphy = attachment.giphy?.fixed_height_downsampled;
        return {
            url: giphy?.url || attachment.image_url || attachment.thumb_url || '',
            height: giphy?.height ? `${giphy?.height}px` : '300px',
            width: giphy?.width ? `${giphy?.width}px` : '',
        };
    }
    /**
     * Handles the configuration for scraped image attachments, it's possible to provide your own function to override the default logic
     * @param attachment The attachment to configure
     */
    getScrapedImageAttachmentConfiguration(attachment) {
        if (this.customScrapedImageAttachmentConfigurationHandler) {
            return this.customScrapedImageAttachmentConfigurationHandler(attachment);
        }
        return {
            url: attachment.image_url || attachment.thumb_url || '',
            width: '',
            height: '', // Set from CSS
        };
    }
    addResizingParamsToUrl(sizeRestriction, url) {
        url.searchParams.set('h', sizeRestriction.height.toString());
        url.searchParams.set('w', sizeRestriction.width.toString());
    }
    getSizingRestrictions(url, htmlElement, displayWarning = false) {
        const urlParams = url.searchParams;
        const originalHeight = Number(urlParams.get('oh')) || 1;
        const originalWidth = Number(urlParams.get('ow')) || 1;
        const cssSizeRestriction = this.getCSSSizeRestriction(htmlElement);
        let sizeRestriction;
        if ((cssSizeRestriction.maxHeight || cssSizeRestriction.height) &&
            cssSizeRestriction.maxWidth) {
            sizeRestriction = this.getSizeRestrictions(originalHeight, originalWidth, (cssSizeRestriction.maxHeight || cssSizeRestriction.height), cssSizeRestriction.maxWidth);
        }
        else {
            sizeRestriction = undefined;
            if (displayWarning) {
                console.warn(`Invalid value set for height/max-height and/or max-width for HTML element, this can cause scrolling issues inside the message list, more info https://getstream.io/chat/docs/sdk/angular/components/AttachmentListComponent/#image-and-video-sizing, attachment URL: ${url.toString()}`);
            }
        }
        return sizeRestriction;
    }
    getSizeRestrictions(originalHeight, originalWidth, maxHeight, maxWidth) {
        return {
            height: Math.round(Math.max(maxHeight, (maxWidth / originalWidth) * originalHeight)),
            width: Math.round(Math.max(maxHeight, (maxWidth / originalHeight) * originalWidth)),
        };
    }
    getCSSSizeRestriction(htmlElement) {
        const computedStylesheet = getComputedStyle(htmlElement);
        const height = this.getValueRepresentationOfCSSProperty(computedStylesheet.getPropertyValue('height'));
        const maxHeight = this.getValueRepresentationOfCSSProperty(computedStylesheet.getPropertyValue('max-height'));
        const maxWidth = this.getValueRepresentationOfCSSProperty(computedStylesheet.getPropertyValue('max-width'));
        return { height, maxHeight, maxWidth };
    }
    getValueRepresentationOfCSSProperty(property) {
        return Number(property.replace('px', '')) || undefined;
    }
}
AttachmentConfigurationService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: AttachmentConfigurationService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
AttachmentConfigurationService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: AttachmentConfigurationService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: AttachmentConfigurationService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

const en = {
    streamChat: {
        '1 reply': '1 reply',
        'Attach files': 'Attach files',
        Cancel: 'Cancel',
        'Channel Missing': 'Channel Missing',
        Close: 'Close',
        'Close emoji picker': 'Close emoji picker',
        'Commands matching': 'Commands matching',
        'Connection failure, reconnecting now...': 'Connection failure, reconnecting now...',
        Delete: 'Delete',
        Delivered: 'Delivered',
        'Edit Message': 'Edit Message',
        'Edit message request failed': 'Edit message request failed',
        'Emoji matching': 'Emoji matching',
        'Empty message...': 'Empty message...',
        'Error adding flag': 'Error adding flag',
        'Error connecting to chat, refresh the page to try again.': 'Error connecting to chat, refresh the page to try again',
        'Error deleting message': 'Error deleting message',
        'Error loading reactions': 'Error loading reactions',
        'Error muting a user ...': 'Error muting a user ...',
        'Error pinning message': 'Error pinning message',
        'Error removing message pin': 'Error removing message pin',
        'Error unmuting a user ...': 'Error unmuting a user ...',
        'Error uploading file': 'Error uploading file "{{ name }}"',
        'Error uploading file, maximum file size exceeded': 'Error uploading "{{ name }}", maximum file size {{ limit }} exceeded',
        'Error uploading file, extension not supported': 'Error uploading "{{ name }}", type {{ ext }} not supported',
        'Error deleting attachment': 'Error deleting attachment',
        'Error · Unsent': "Message couldn't be sent",
        'Error: {{ errorMessage }}': 'Error: {{ errorMessage }}',
        Flag: 'Flag',
        'Message Failed': 'Message Failed',
        'Message Failed · Unauthorized': 'Unauthorized to send message',
        'Message Failed · Click to try again': "Message couldn't be sent, click to try again",
        'Message deleted': 'Message deleted',
        'Message has been successfully flagged': 'Message has been successfully flagged',
        'Message pinned': 'Message pinned',
        'Message unpinned': 'Message unpinned',
        Mute: 'Mute',
        New: 'New',
        'New Messages!': 'New Messages!',
        'No results found': 'No results found',
        'Nothing yet...': 'Nothing yet...',
        'Only visible to you': 'Only visible to you',
        'Open emoji picker': 'Open emoji picker',
        'People matching': 'People matching',
        'Pick your emoji': 'Pick your emoji',
        Pin: 'Pin',
        'Pinned by': 'Pinned by',
        Reply: 'Quote Reply',
        'Reply to Message': 'Reply to Message',
        Search: 'Search',
        'Searching...': 'Searching...',
        Send: 'Send',
        'Send message request failed': 'Send message request failed',
        'Sending...': 'Sending...',
        'Slow Mode ON': 'Slow Mode ON',
        'Start of a new thread': 'Start of a new thread',
        'This message was deleted...': 'This message was deleted...',
        Thread: 'Thread reply',
        'Type your message': 'Type your message',
        Unmute: 'Unmute',
        Unpin: 'Unpin',
        'Wait until all attachments have uploaded': 'Wait until all attachments have uploaded',
        'You have no channels currently': 'You have no channels currently',
        "You've reached the maximum number of files": "You've reached the maximum number of files",
        live: 'live',
        'this content could not be displayed': 'this content could not be displayed',
        '{{ commaSeparatedUsers }} and {{ moreCount }} more': '{{ commaSeparatedUsers }} and {{ moreCount }} more',
        '{{ commaSeparatedUsers }}, and {{ lastUser }}': '{{ commaSeparatedUsers }}, and {{ lastUser }}',
        '{{ firstUser }} and {{ secondUser }}': '{{ firstUser }} and {{ secondUser }}',
        '{{ imageCount }} more': '{{ imageCount }} more',
        '{{ memberCount }} members': '{{ memberCount }} members',
        '{{ replyCount }} replies': '{{ replyCount }} replies',
        '{{ user }} has been muted': '{{ user }} has been muted',
        '{{ user }} has been unmuted': '{{ user }} has been unmuted',
        '{{ watcherCount }} online': '{{ watcherCount }} online',
        '🏙 Attachment...': '🏙 Attachment...',
        'Connection error': 'Connection error',
        'Load more': 'Load more',
        failed: 'failed',
        retry: 'retry',
        test: 'success',
        'Sending links is not allowed in this conversation': 'Sending links is not allowed in this conversation',
        "You can't send messages in this channel": "You can't send messages in this channel",
        "You can't send thread replies in this channel": "You can't send thread replies in this channel",
        'Message not found': 'Message not found',
        'No chats here yet…': 'No chats here yet…',
        'user is typing': '{{ user }} is typing',
        'users are typing': '{{ users }} are typing',
        'Error loading channels': 'Error loading channels',
        'See original (automatically translated)': 'See original (automatically translated)',
        'See translation': 'See translation',
        'Mark as unread': 'Mark as unread',
        'Error marking message as unread': 'Error marking message as unread',
        'Error, only the first {{count}} message can be marked as unread': 'Error, only the first {{count}} message can be marked as unread',
        'Unread messages': 'Unread messages',
        '{{count}} unread messages': '{{count}} unread messages',
        '{{count}} unread message': '{{count}} unread message',
        'This message did not meet our content guidelines': 'This message did not meet our content guidelines',
        'Send Anyway': 'Send Anyway',
        Edited: 'Edited',
        'Error playing audio': 'Error playing audio',
        'Copy text': 'Copy text',
    },
};

/**
 * The `StreamI18nService` can be used to customize the labels of the chat UI. Our [translation guide](../concepts/translation.mdx) covers this topic in detail.
 */
class StreamI18nService {
    constructor(translteService) {
        this.translteService = translteService;
    }
    /**
     * Registers the translation to the [ngx-translate](https://github.com/ngx-translate/core) TranslateService.
     * @param lang The language key to register the translation to
     * @param overrides An object which keys are translation keys, and the values are custom translations
     */
    setTranslation(lang = 'en', overrides) {
        if (!this.translteService.defaultLang) {
            this.translteService.defaultLang = lang;
        }
        this.translteService.setTranslation(lang, { streamChat: { ...en.streamChat, ...overrides } }, true);
    }
}
StreamI18nService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: StreamI18nService, deps: [{ token: i10.TranslateService }], target: i0.ɵɵFactoryTarget.Injectable });
StreamI18nService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: StreamI18nService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: StreamI18nService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i10.TranslateService }]; } });

/**
 * The `Avatar` component displays the provided image, with fallback to the first letter of the optional name input.
 */
class AvatarComponent {
    constructor(chatClientService, ngZone, cdRef) {
        this.chatClientService = chatClientService;
        this.ngZone = ngZone;
        this.cdRef = cdRef;
        /**
         * If a channel avatar is displayed, and if the channel has exactly two members a green dot is displayed if the other member is online. Set this flag to `false` to turn off this behavior.
         */
        this.showOnlineIndicator = true;
        /**
         * If channel/user image isn't provided the initials of the name of the channel/user is shown instead, you can choose how the initals should be computed
         */
        this.initialsType = 'first-letter-of-first-word';
        this.isError = false;
        this.isOnline = false;
        this.initials = '';
        this.isViewInited = false;
        this.subscriptions = [];
    }
    ngOnInit() {
        this.subscriptions.push(this.chatClientService.user$.subscribe((u) => {
            if (u?.id !== this.userId) {
                this.userId = u?.id;
                if (this.type || this.channel || this.name) {
                    this.setInitials();
                    this.setFallbackChannelImage();
                    this.updateIsOnlineSubscription();
                }
                if (this.isViewInited) {
                    this.cdRef.detectChanges();
                }
            }
        }));
    }
    ngOnChanges(changes) {
        if (changes['channel']) {
            this.updateIsOnlineSubscription();
        }
        if (changes.type || changes.name || changes.channel) {
            this.setInitials();
        }
        if (changes.type || changes.channel) {
            this.setFallbackChannelImage();
        }
    }
    setFallbackChannelImage() {
        if (this.type !== 'channel') {
            this.fallbackChannelImage = undefined;
        }
        else {
            const otherMember = this.getOtherMemberIfOneToOneChannel();
            if (otherMember) {
                this.fallbackChannelImage = otherMember.image;
            }
            else {
                this.fallbackChannelImage = undefined;
            }
        }
    }
    setInitials() {
        let result = '';
        if (this.type === 'user') {
            result = this.name?.toString() || '';
        }
        else if (this.type === 'channel') {
            if (this.channel?.data?.name) {
                result = this.channel?.data?.name;
            }
            else {
                const otherMember = this.getOtherMemberIfOneToOneChannel();
                if (otherMember) {
                    result = otherMember.name || otherMember.id || '';
                }
                else {
                    result = '#';
                }
            }
        }
        const words = result.split(' ');
        let initials;
        if (this.initialsType === 'first-letter-of-each-word') {
            initials = words.map((w) => w.charAt(0) || '').join('');
        }
        else {
            initials = words[0].charAt(0) || '';
        }
        this.initials = initials;
    }
    updateIsOnlineSubscription() {
        if (this.channel) {
            const otherMember = this.getOtherMemberIfOneToOneChannel();
            if (otherMember) {
                this.isOnline = otherMember.online || false;
                this.isOnlineSubscription = this.chatClientService.events$
                    .pipe(filter((e) => e.eventType === 'user.presence.changed'))
                    .subscribe((event) => {
                    if (event.event.user?.id === otherMember.id) {
                        this.ngZone.run(() => {
                            this.isOnline = event.event.user?.online || false;
                        });
                    }
                });
            }
            else {
                this.isOnline = false;
                this.isOnlineSubscription?.unsubscribe();
            }
        }
        else {
            this.isOnline = false;
            this.isOnlineSubscription?.unsubscribe();
        }
    }
    ngAfterViewInit() {
        this.isViewInited = true;
    }
    getOtherMemberIfOneToOneChannel() {
        const otherMembers = Object.values(this.channel?.state?.members || {}).filter((m) => m.user_id !== this.userId);
        if (otherMembers.length === 1) {
            return otherMembers[0].user;
        }
        else {
            return undefined;
        }
    }
}
AvatarComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: AvatarComponent, deps: [{ token: ChatClientService }, { token: i0.NgZone }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
AvatarComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.0.4", type: AvatarComponent, selector: "stream-avatar", inputs: { name: "name", imageUrl: "imageUrl", location: "location", channel: "channel", user: "user", type: "type", showOnlineIndicator: "showOnlineIndicator", initialsType: "initialsType" }, usesOnChanges: true, ngImport: i0, template: "<div\n  class=\"str-chat__avatar str-chat-angular__avatar str-chat__avatar--circle stream-chat__avatar--{{\n    location\n  }} stream-chat__avatar--{{\n    initialsType === 'first-letter-of-first-word'\n      ? 'one-letter'\n      : 'multiple-letters'\n  }}\"\n  title=\"{{ name }}\"\n>\n  <img\n    *ngIf=\"(imageUrl || fallbackChannelImage) && !isError; else fallback\"\n    class=\"str-chat__avatar-image\"\n    data-testid=\"avatar-img\"\n    fetchpriority=\"high\"\n    src=\"{{ imageUrl || fallbackChannelImage }}\"\n    alt=\"{{ initials }}\"\n    (error)=\"isError = true\"\n  />\n  <ng-template #fallback>\n    <div data-testid=\"fallback-img\" class=\"str-chat__avatar-fallback\">\n      {{ initials }}\n    </div>\n  </ng-template>\n  <div\n    *ngIf=\"isOnline && showOnlineIndicator\"\n    data-testid=\"online-indicator\"\n    class=\"str-chat__avatar--online-indicator\"\n  ></div>\n</div>\n", styles: [""], dependencies: [{ kind: "directive", type: i4.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: AvatarComponent, decorators: [{
            type: Component,
            args: [{ selector: 'stream-avatar', template: "<div\n  class=\"str-chat__avatar str-chat-angular__avatar str-chat__avatar--circle stream-chat__avatar--{{\n    location\n  }} stream-chat__avatar--{{\n    initialsType === 'first-letter-of-first-word'\n      ? 'one-letter'\n      : 'multiple-letters'\n  }}\"\n  title=\"{{ name }}\"\n>\n  <img\n    *ngIf=\"(imageUrl || fallbackChannelImage) && !isError; else fallback\"\n    class=\"str-chat__avatar-image\"\n    data-testid=\"avatar-img\"\n    fetchpriority=\"high\"\n    src=\"{{ imageUrl || fallbackChannelImage }}\"\n    alt=\"{{ initials }}\"\n    (error)=\"isError = true\"\n  />\n  <ng-template #fallback>\n    <div data-testid=\"fallback-img\" class=\"str-chat__avatar-fallback\">\n      {{ initials }}\n    </div>\n  </ng-template>\n  <div\n    *ngIf=\"isOnline && showOnlineIndicator\"\n    data-testid=\"online-indicator\"\n    class=\"str-chat__avatar--online-indicator\"\n  ></div>\n</div>\n" }]
        }], ctorParameters: function () { return [{ type: ChatClientService }, { type: i0.NgZone }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { name: [{
                type: Input
            }], imageUrl: [{
                type: Input
            }], location: [{
                type: Input
            }], channel: [{
                type: Input
            }], user: [{
                type: Input
            }], type: [{
                type: Input
            }], showOnlineIndicator: [{
                type: Input
            }], initialsType: [{
                type: Input
            }] } });

/**
 * A central location for registering your custom templates to override parts of the chat application.
 *
 * For code examples to the different customizations see our [customizations example application](https://github.com/GetStream/stream-chat-angular/tree/master/projects/customizations-example), specifically the [AppComponent](https://github.com/GetStream/stream-chat-angular/tree/master/projects/customizations-example/src/app) (see [README](https://github.com/GetStream/stream-chat-angular/blob/master/README.md#customization-examples) for instructions on how to start the application).
 *
 * You can find the type definitions of the context that is provided for each template [on GitHub](https://github.com/GetStream/stream-chat-angular/blob/master/projects/stream-chat-angu)
 */
class CustomTemplatesService {
    constructor() {
        /**
         * The autocomplete list item template for mentioning users (used in the [`AutocompleteTextareaComponent`](../components/AutocompleteTextareaComponent.mdx))
         */
        this.mentionAutocompleteItemTemplate$ = new BehaviorSubject(undefined);
        /**
         * The autocomplete list item template for commands (used in the [`AutocompleteTextareaComponent`](../components/AutocompleteTextareaComponent.mdx))
         */
        this.commandAutocompleteItemTemplate$ = new BehaviorSubject(undefined);
        /**
         * Template used to display an item in the [channel list](../components/ChannelListComponent.mdx) (instead of the default [channal list item](../components/ChannelPreviewComponent.mdx))
         *
         */
        this.channelPreviewTemplate$ = new BehaviorSubject(undefined);
        /**
         * The template used for displaying a [mention inside a message](../code-examples/mention-actions.mdx)
         *
         */
        this.mentionTemplate$ = new BehaviorSubject(undefined);
        /**
         * The template for [emoji picker](../code-examples/emoji-picker.mdx)
         *
         */
        this.emojiPickerTemplate$ = new BehaviorSubject(undefined);
        /**
         * The typing indicator template used in the [message list](../components/MessageListComponent.mdx)
         *
         */
        this.typingIndicatorTemplate$ = new BehaviorSubject(undefined);
        /**
         * The template used to display a message in the [message list](../components/MessageListComponent.mdx) (instead of the [default message component](../components/MessageComponent.mdx))
         *
         */
        this.messageTemplate$ = new BehaviorSubject(undefined);
        /**
         * The template for channel actions displayed in the [channel header](../components/ChannelHeaderComponent.mdx) (by default no channel action is displayed)
         *
         */
        this.channelActionsTemplate$ = new BehaviorSubject(undefined);
        /**
         * The template used to display attachments of a [message](../components/MessageComponent.mdx) (instead of the [default attachment list](../components/AttachmentListComponent.mdx))
         *
         */
        this.attachmentListTemplate$ = new BehaviorSubject(undefined);
        /**
         * The template used to display attachments in the [message input](../components/MessageInputComponent.mdx) component (instead of the [default attachment preview](../components/AttachmentPreviewListComponent.mdx))
         *
         */
        this.attachmentPreviewListTemplate$ = new BehaviorSubject(undefined);
        /**
         * The template used to display avatars for channels and users (instead of the [default avatar](../components/AvatarComponent.mdx))
         *
         */
        this.avatarTemplate$ = new BehaviorSubject(undefined);
        /**
         * Template for displaying icons (instead of the [default icon component](../components/IconComponent.mdx))
         *
         */
        this.iconTemplate$ = new BehaviorSubject(undefined);
        /**
         * Template for displaying the loading indicator (instead of the [default loading indicator](../components/LoadingIndicatorComponent.mdx))
         *
         */
        this.loadingIndicatorTemplate$ = new BehaviorSubject(undefined);
        /**
         * Template for displaying the message actions box (instead of the [default message actions box](../components/MessageActionsBoxComponent.mdx))
         *
         */
        this.messageActionsBoxTemplate$ = new BehaviorSubject(undefined);
        /**
         * The template used for displaying an item in the [message actions box](../components/MessageActionsBoxComponent.mdx)
         *
         */
        this.messageActionsBoxItemTemplate$ = new BehaviorSubject(undefined);
        /**
         * The template used to display the reactions of a [message](../components/MessageComponent.mdx), and the selector to add a reaction to a message (instead of the [default message reactions component](../components/MessageReactionsComponent.mdx))
         *
         */
        this.messageReactionsTemplate$ = new BehaviorSubject(undefined);
        /**
         * The template used to display the reactions of a [message](../components/MessageComponent.mdx), and the selector to add a reaction to a message (instead of the [default message reactions component](../components/MessageReactionsComponent.mdx))
         *
         */
        this.messageReactionsSelectorTemplate$ = new BehaviorSubject(undefined);
        /**
         * The template used to display a modal window (instead of the [default modal](../components/ModalComponent.mdx))
         *
         */
        this.modalTemplate$ = new BehaviorSubject(undefined);
        /**
         * The template used to override the [default notification component](../components/NotificationComponent.mdx)
         *
         */
        this.notificationTemplate$ = new BehaviorSubject(undefined);
        /**
         * The template used for header of a [thread](../components/ThreadComponent.mdx)
         *
         */
        this.threadHeaderTemplate$ = new BehaviorSubject(undefined);
        /**
         * The template used for displaying the delivered state of the message inside the [message component](../components/MessageComponent.mdx)
         *
         * Displayed for the last message sent by the current user, if the message isn't yet read by anyone
         *
         */
        this.deliveredStatusTemplate$ = new BehaviorSubject(undefined);
        /**
         * The template used for displaying the sending state of the message inside the [message component](../components/MessageComponent.mdx)
         *
         * Displayed for the last message sent by the current user, if the message is currently being sent
         *
         */
        this.sendingStatusTemplate$ = new BehaviorSubject(undefined);
        /**
         * The template used for displaying the sent state of the message inside the [message component](../components/MessageComponent.mdx)
         *
         * Displayed for the last message sent by the current user, if the message is read at least by one user
         *
         */
        this.readStatusTemplate$ = new BehaviorSubject(undefined);
        /**
         * Template to display custom metadata inside [message component](../components/MessageComponent.mdx)
         *
         */
        this.customMessageMetadataTemplate$ = new BehaviorSubject(undefined);
        /**
         * The template used to display additional information about a channel under the channel name inside the [channel header component](../components/ChannelHeaderComponent.mdx)
         *
         */
        this.channelHeaderInfoTemplate$ = new BehaviorSubject(undefined);
        /**
         * The template used for displaying file upload/attachment selector inside the [message input](../components/MessageInputComponent.mdx)
         *
         */
        this.customAttachmentUploadTemplate$ = new BehaviorSubject(undefined);
        /**
         * The template that can be used to override how a single image attachment is displayed inside the [attachment list](../components/AttachmentListComponent.mdx)
         */
        this.imageAttachmentTemplate$ = new BehaviorSubject(undefined);
        /**
         * The template that can be used to override how a voice recording attachment is displayed inside the [attachment list](../components/AttachmentListComponent.mdx), by default the [voice recording component](../components/VoiceRecordingComponent.mdx) is used
         */
        this.voiceRecordingAttachmentTemplate$ = new BehaviorSubject(undefined);
        /**
         * The template that can be used to override how a video attachment is displayed inside the [attachment list](../components/AttachmentListComponent.mdx)
         */
        this.videoAttachmentTemplate$ = new BehaviorSubject(undefined);
        /**
         * The template that can be used to override how image gallery is displayed inside the [attachment list](../components/AttachmentListComponent.mdx)
         */
        this.galleryAttachmentTemplate$ = new BehaviorSubject(undefined);
        /**
         * The template that can be used to override how a file attachment is displayed inside the [attachment list](../components/AttachmentListComponent.mdx)
         */
        this.fileAttachmentTemplate$ = new BehaviorSubject(undefined);
        /**
         * The template that can be used to override how a card attachment is displayed inside the [attachment list](../components/AttachmentListComponent.mdx)
         */
        this.cardAttachmentTemplate$ = new BehaviorSubject(undefined);
        /**
         * The template that can be used to override how attachment actions are displayed inside the [attachment list](../components/AttachmentListComponent.mdx)
         */
        this.attachmentActionsTemplate$ = new BehaviorSubject(undefined);
        /**
         * The template used to display [system messages](https://getstream.io/chat/docs/javascript/silent_messages/?language=javascript&q=system) indise the [message component](../components/MessageComponent.mdx)
         */
        this.systemMessageTemplate$ = new BehaviorSubject(undefined);
        /**
         * The template used to display the date separator inside the [message list](../components/MessageListComponent.mdx)
         */
        this.dateSeparatorTemplate$ = new BehaviorSubject(undefined);
        /**
         * The template used to display unread messages indicator inside the [message list](../components/MessageListComponent.mdx) when the channel is opened
         *
         * This UI element is used to separate unread messages from read messages
         */
        this.newMessagesIndicatorTemplate$ = new BehaviorSubject(undefined);
        /**
         * The template used to display unread messages notification inside the [message list](../components/MessageListComponent.mdx) when the channel is opened
         *
         * Users can use this notification to jump to the first unread message when it's clicked
         */
        this.newMessagesNotificationTemplate$ = new BehaviorSubject(undefined);
        /**
         * The template to show if the main message list is empty
         */
        this.emptyMainMessageListPlaceholder$ = new BehaviorSubject(undefined);
        /**
         * The template to show if the thread message list is empty
         */
        this.emptyThreadMessageListPlaceholder$ = new BehaviorSubject(undefined);
        /**
         * The template used to display the [message bounce prompt](../components/MessageBouncePromptComponent.mdx)
         */
        this.messageBouncePromptTemplate$ = new BehaviorSubject(undefined);
        /**
         * Template used to display the channel information inside the [channel list item](../components/ChannelPreviewComponent.mdx)
         *
         */
        this.channelPreviewInfoTemplate$ = new BehaviorSubject(undefined);
    }
}
CustomTemplatesService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: CustomTemplatesService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
CustomTemplatesService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: CustomTemplatesService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: CustomTemplatesService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return []; } });

/**
 * The `AvatarPlaceholder` component displays the [default avatar](./AvatarComponent.mdx) unless a [custom template](../services/CustomTemplatesService.mdx) is provided. This component is used by the SDK internally, you likely won't need to use it.
 */
class AvatarPlaceholderComponent {
    constructor(customTemplatesService) {
        this.customTemplatesService = customTemplatesService;
        /**
         * If channel/user image isn't provided the initials of the name of the channel/user is shown instead, you can choose how the initals should be computed
         */
        this.initialsType = 'first-letter-of-first-word';
        /**
         * If a channel avatar is displayed, and if the channel has exactly two members a green dot is displayed if the other member is online. Set this flag to `false` to turn off this behavior.
         */
        this.showOnlineIndicator = true;
        this.context = {
            name: undefined,
            imageUrl: undefined,
            location: undefined,
            channel: undefined,
            user: undefined,
            type: undefined,
            initialsType: undefined,
            showOnlineIndicator: undefined,
        };
    }
    ngOnChanges() {
        this.context = {
            name: this.name,
            imageUrl: this.imageUrl,
            location: this.location,
            type: this.type,
            user: this.user,
            channel: this.channel,
            initialsType: this.initialsType,
            showOnlineIndicator: this.showOnlineIndicator,
        };
    }
}
AvatarPlaceholderComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: AvatarPlaceholderComponent, deps: [{ token: CustomTemplatesService }], target: i0.ɵɵFactoryTarget.Component });
AvatarPlaceholderComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.0.4", type: AvatarPlaceholderComponent, selector: "stream-avatar-placeholder", inputs: { name: "name", imageUrl: "imageUrl", location: "location", channel: "channel", user: "user", type: "type", initialsType: "initialsType", showOnlineIndicator: "showOnlineIndicator" }, usesOnChanges: true, ngImport: i0, template: "<ng-template\n  #defaultAvatar\n  let-name=\"name\"\n  let-imageUrl=\"imageUrl\"\n  let-type=\"type\"\n  let-channel=\"channel\"\n  let-user=\"user\"\n  let-location=\"location\"\n  let-initialsType=\"initialsType\"\n  let-showOnlineIndicator=\"showOnlineIndicator\"\n>\n  <stream-avatar\n    [name]=\"name\"\n    [imageUrl]=\"imageUrl\"\n    [type]=\"type\"\n    [channel]=\"channel\"\n    [user]=\"user\"\n    [location]=\"location\"\n    [initialsType]=\"initialsType\"\n    [showOnlineIndicator]=\"showOnlineIndicator\"\n  ></stream-avatar>\n</ng-template>\n<ng-container\n  *ngTemplateOutlet=\"\n    (customTemplatesService.avatarTemplate$ | async) || defaultAvatar;\n    context: context\n  \"\n></ng-container>\n", dependencies: [{ kind: "directive", type: i4.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "component", type: AvatarComponent, selector: "stream-avatar", inputs: ["name", "imageUrl", "location", "channel", "user", "type", "showOnlineIndicator", "initialsType"] }, { kind: "pipe", type: i4.AsyncPipe, name: "async" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: AvatarPlaceholderComponent, decorators: [{
            type: Component,
            args: [{ selector: 'stream-avatar-placeholder', template: "<ng-template\n  #defaultAvatar\n  let-name=\"name\"\n  let-imageUrl=\"imageUrl\"\n  let-type=\"type\"\n  let-channel=\"channel\"\n  let-user=\"user\"\n  let-location=\"location\"\n  let-initialsType=\"initialsType\"\n  let-showOnlineIndicator=\"showOnlineIndicator\"\n>\n  <stream-avatar\n    [name]=\"name\"\n    [imageUrl]=\"imageUrl\"\n    [type]=\"type\"\n    [channel]=\"channel\"\n    [user]=\"user\"\n    [location]=\"location\"\n    [initialsType]=\"initialsType\"\n    [showOnlineIndicator]=\"showOnlineIndicator\"\n  ></stream-avatar>\n</ng-template>\n<ng-container\n  *ngTemplateOutlet=\"\n    (customTemplatesService.avatarTemplate$ | async) || defaultAvatar;\n    context: context\n  \"\n></ng-container>\n" }]
        }], ctorParameters: function () { return [{ type: CustomTemplatesService }]; }, propDecorators: { name: [{
                type: Input
            }], imageUrl: [{
                type: Input
            }], location: [{
                type: Input
            }], channel: [{
                type: Input
            }], user: [{
                type: Input
            }], type: [{
                type: Input
            }], initialsType: [{
                type: Input
            }], showOnlineIndicator: [{
                type: Input
            }] } });

/**
 * The `Icon` component can be used to display different icons (i. e. message delivered icon).
 */
class IconComponent {
    constructor() { }
}
IconComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: IconComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
IconComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.0.4", type: IconComponent, selector: "stream-icon", inputs: { icon: "icon" }, ngImport: i0, template: "<div class=\"str-chat__icon str-chat__icon--{{ icon }}\"></div>\n" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: IconComponent, decorators: [{
            type: Component,
            args: [{ selector: 'stream-icon', template: "<div class=\"str-chat__icon str-chat__icon--{{ icon }}\"></div>\n" }]
        }], ctorParameters: function () { return []; }, propDecorators: { icon: [{
                type: Input
            }] } });

/**
 * The `IconPlaceholder` component displays the [default icons](./IconComponent.mdx) unless a [custom template](../services/CustomTemplatesService.mdx) is provided. This component is used by the SDK internally, you likely won't need to use it.
 */
class IconPlaceholderComponent {
    constructor(customTemplatesService) {
        this.customTemplatesService = customTemplatesService;
        this.iconContext = { icon: undefined };
    }
    ngOnChanges() {
        this.iconContext = {
            icon: this.icon,
        };
    }
}
IconPlaceholderComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: IconPlaceholderComponent, deps: [{ token: CustomTemplatesService }], target: i0.ɵɵFactoryTarget.Component });
IconPlaceholderComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.0.4", type: IconPlaceholderComponent, selector: "stream-icon-placeholder", inputs: { icon: "icon" }, usesOnChanges: true, ngImport: i0, template: "<ng-template #defaultIcon let-icon=\"icon\">\n  <stream-icon [icon]=\"icon\"></stream-icon>\n</ng-template>\n<ng-container\n  *ngTemplateOutlet=\"\n    (customTemplatesService.iconTemplate$ | async) || defaultIcon;\n    context: iconContext\n  \"\n></ng-container>\n", dependencies: [{ kind: "directive", type: i4.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "component", type: IconComponent, selector: "stream-icon", inputs: ["icon"] }, { kind: "pipe", type: i4.AsyncPipe, name: "async" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: IconPlaceholderComponent, decorators: [{
            type: Component,
            args: [{ selector: 'stream-icon-placeholder', template: "<ng-template #defaultIcon let-icon=\"icon\">\n  <stream-icon [icon]=\"icon\"></stream-icon>\n</ng-template>\n<ng-container\n  *ngTemplateOutlet=\"\n    (customTemplatesService.iconTemplate$ | async) || defaultIcon;\n    context: iconContext\n  \"\n></ng-container>\n" }]
        }], ctorParameters: function () { return [{ type: CustomTemplatesService }]; }, propDecorators: { icon: [{
                type: Input
            }] } });

/**
 * The `LoadingIndicator` component displays a spinner to indicate that an action is in progress.
 */
class LoadingIndicatorComponent {
    constructor() { }
}
LoadingIndicatorComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: LoadingIndicatorComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
LoadingIndicatorComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.0.4", type: LoadingIndicatorComponent, selector: "stream-loading-indicator", ngImport: i0, template: "<div class=\"str-chat__loading-indicator\">\n  <svg\n    viewBox=\"0 0 30 30\"\n    data-testid=\"loading-indicator\"\n    xmlns=\"http://www.w3.org/2000/svg\"\n    height=\"30\"\n    width=\"30\"\n  >\n    <defs>\n      <linearGradient\n        x1=\"50%\"\n        x2=\"50%\"\n        y1=\"0%\"\n        y2=\"100%\"\n        id=\"stream-chat-loading-circle\"\n      >\n        <stop offset=\"0%\" stop-color=\"#FFF\" stop-opacity=\"0\" />\n        <stop data-testid=\"stop-color\" offset=\"100%\" stop-opacity=\"1\" />\n      </linearGradient>\n    </defs>\n    <path\n      d=\"M2.518 23.321l1.664-1.11A12.988 12.988 0 0 0 15 28c7.18 0 13-5.82 13-13S22.18 2 15 2V0c8.284 0 15 6.716 15 15 0 8.284-6.716 15-15 15-5.206 0-9.792-2.652-12.482-6.679z\"\n      fillRule=\"evenodd\"\n      fill=\"url(#stream-chat-loading-circle)\"\n    />\n  </svg>\n</div>\n" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: LoadingIndicatorComponent, decorators: [{
            type: Component,
            args: [{ selector: 'stream-loading-indicator', template: "<div class=\"str-chat__loading-indicator\">\n  <svg\n    viewBox=\"0 0 30 30\"\n    data-testid=\"loading-indicator\"\n    xmlns=\"http://www.w3.org/2000/svg\"\n    height=\"30\"\n    width=\"30\"\n  >\n    <defs>\n      <linearGradient\n        x1=\"50%\"\n        x2=\"50%\"\n        y1=\"0%\"\n        y2=\"100%\"\n        id=\"stream-chat-loading-circle\"\n      >\n        <stop offset=\"0%\" stop-color=\"#FFF\" stop-opacity=\"0\" />\n        <stop data-testid=\"stop-color\" offset=\"100%\" stop-opacity=\"1\" />\n      </linearGradient>\n    </defs>\n    <path\n      d=\"M2.518 23.321l1.664-1.11A12.988 12.988 0 0 0 15 28c7.18 0 13-5.82 13-13S22.18 2 15 2V0c8.284 0 15 6.716 15 15 0 8.284-6.716 15-15 15-5.206 0-9.792-2.652-12.482-6.679z\"\n      fillRule=\"evenodd\"\n      fill=\"url(#stream-chat-loading-circle)\"\n    />\n  </svg>\n</div>\n" }]
        }], ctorParameters: function () { return []; } });

/**
 * The `LoadingInficatorPlaceholder` component displays the [default loading indicator](./LoadingIndicatorComponent.mdx) unless a [custom template](../services/CustomTemplatesService.mdx) is provided. This component is used by the SDK internally, you likely won't need to use it.
 */
class LoadingIndicatorPlaceholderComponent {
    constructor(customTemplatesService) {
        this.customTemplatesService = customTemplatesService;
    }
}
LoadingIndicatorPlaceholderComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: LoadingIndicatorPlaceholderComponent, deps: [{ token: CustomTemplatesService }], target: i0.ɵɵFactoryTarget.Component });
LoadingIndicatorPlaceholderComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.0.4", type: LoadingIndicatorPlaceholderComponent, selector: "stream-loading-indicator-placeholder", ngImport: i0, template: "<ng-template #defaultLoadingIndicator>\n  <stream-loading-indicator></stream-loading-indicator>\n</ng-template>\n<ng-container\n  *ngTemplateOutlet=\"\n    (customTemplatesService.loadingIndicatorTemplate$ | async) ||\n    defaultLoadingIndicator\n  \"\n></ng-container>\n", dependencies: [{ kind: "directive", type: i4.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "component", type: LoadingIndicatorComponent, selector: "stream-loading-indicator" }, { kind: "pipe", type: i4.AsyncPipe, name: "async" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: LoadingIndicatorPlaceholderComponent, decorators: [{
            type: Component,
            args: [{ selector: 'stream-loading-indicator-placeholder', template: "<ng-template #defaultLoadingIndicator>\n  <stream-loading-indicator></stream-loading-indicator>\n</ng-template>\n<ng-container\n  *ngTemplateOutlet=\"\n    (customTemplatesService.loadingIndicatorTemplate$ | async) ||\n    defaultLoadingIndicator\n  \"\n></ng-container>\n" }]
        }], ctorParameters: function () { return [{ type: CustomTemplatesService }]; } });

/**
 * The message actions service provides customization options for the [message actions](../../components/MessageActionsBoxComponent)
 */
class MessageActionsService {
    constructor(chatClientService, notificationService, channelService) {
        this.chatClientService = chatClientService;
        this.notificationService = notificationService;
        this.channelService = channelService;
        /**
         * Default actions - these are the actions that are handled by the built-in component
         */
        this.defaultActions = [
            {
                actionName: 'react',
                isVisible: (enabledActions) => {
                    return enabledActions.indexOf('send-reaction') !== -1;
                },
            },
            {
                actionName: 'mark-unread',
                actionLabelOrTranslationKey: 'streamChat.Mark as unread',
                actionHandler: (message) => {
                    void this.channelService.markMessageUnread(message.id);
                },
                isVisible: (enabledActions, isMine, message) => enabledActions.indexOf('read-events') !== -1 && !message.parent_id,
            },
            {
                actionName: 'quote',
                actionLabelOrTranslationKey: 'streamChat.Reply',
                actionHandler: (message) => {
                    this.channelService.selectMessageToQuote(message);
                },
                isVisible: (enabledActions) => enabledActions.indexOf('quote-message') !== -1,
            },
            {
                actionName: 'thread-reply',
                actionLabelOrTranslationKey: 'streamChat.Thread',
                actionHandler: (message) => {
                    void this.channelService.setAsActiveParentMessage(message);
                },
                isVisible: (enabledActions, isMine, message) => enabledActions.indexOf('send-reply') !== -1 && !message.parent_id,
            },
            {
                actionName: 'pin',
                actionLabelOrTranslationKey: (message) => message.pinned ? 'streamChat.Unpin' : 'streamChat.Pin',
                actionHandler: (message) => {
                    message.pinned
                        ? void this.channelService.unpinMessage(message)
                        : void this.channelService.pinMessage(message);
                },
                isVisible: (enabledActions) => enabledActions.indexOf('pin-message') !== -1,
            },
            {
                actionName: 'flag',
                actionLabelOrTranslationKey: 'streamChat.Flag',
                // eslint-disable-next-line @typescript-eslint/no-misused-promises
                actionHandler: async (message) => {
                    try {
                        await this.chatClientService.flagMessage(message.id);
                        this.notificationService.addTemporaryNotification('streamChat.Message has been successfully flagged', 'success');
                    }
                    catch (err) {
                        this.notificationService.addTemporaryNotification('streamChat.Error adding flag');
                    }
                },
                isVisible: (enabledActions, isMine) => enabledActions.indexOf('flag-message') !== -1 && !isMine,
            },
            {
                actionName: 'edit',
                actionLabelOrTranslationKey: 'streamChat.Edit Message',
                actionHandler: (message) => {
                    this.messageToEdit$.next(message);
                },
                isVisible: (enabledActions, isMine) => (enabledActions.indexOf('update-own-message') !== -1 && isMine) ||
                    enabledActions.indexOf('update-any-message') !== -1,
            },
            {
                actionName: 'delete',
                actionLabelOrTranslationKey: 'streamChat.Delete',
                // eslint-disable-next-line @typescript-eslint/no-misused-promises
                actionHandler: async (message) => {
                    try {
                        await this.channelService.deleteMessage(message);
                    }
                    catch (error) {
                        this.notificationService.addTemporaryNotification('streamChat.Error deleting message');
                    }
                },
                isVisible: (enabledActions, isMine) => ((enabledActions.indexOf('delete') !== -1 ||
                    enabledActions.indexOf('delete-own-message') !== -1) &&
                    isMine) ||
                    enabledActions.indexOf('delete-any') !== -1 ||
                    enabledActions.indexOf('delete-any-message') !== -1,
            },
            {
                actionName: 'copy-message-text',
                actionLabelOrTranslationKey: 'streamChat.Copy text',
                isVisible: (_, __, message) => {
                    const isClipboardSupported = navigator?.clipboard?.write !== undefined;
                    if (!isClipboardSupported && !this.hasDisplayedClipboardWarning) {
                        console.warn(`[Stream Chat] Copy action is disabled because clipboard API isn't available, please check security and browser requirements: https://developer.mozilla.org/en-US/docs/Web/API/Clipboard/write#security_considerations`);
                        this.hasDisplayedClipboardWarning = true;
                    }
                    return (!!message.text &&
                        (message.type === 'regular' || message.type === 'reply') &&
                        isClipboardSupported);
                },
                actionHandler: (message, extraParams) => {
                    const fallbackContent = message.text || '';
                    // Android Chrome can only copy plain text: https://issues.chromium.org/issues/40851502
                    void navigator.clipboard.write([
                        new ClipboardItem({
                            'text/plain': new Blob([
                                extraParams.messageTextHtmlElement?.innerText ||
                                    fallbackContent,
                            ], { type: 'text/plain' }),
                            'text/html': new Blob([
                                extraParams.messageTextHtmlElement?.innerHTML ||
                                    fallbackContent,
                            ], { type: 'text/html' }),
                        }),
                    ]);
                },
            },
        ];
        /**
         * The built-in components will handle changes to this observable.
         */
        this.messageToEdit$ = new BehaviorSubject(undefined);
        /**
         * You can pass your own custom actions that will be displayed inside the built-in message actions component
         */
        this.customActions$ = new BehaviorSubject([]);
        this.hasDisplayedClipboardWarning = false;
        combineLatest([
            this.messageToEdit$,
            this.channelService.activeChannel$,
        ]).subscribe(([messageToEdit, activeChannel]) => {
            if (messageToEdit &&
                (!activeChannel || activeChannel?.cid !== messageToEdit.cid)) {
                this.messageToEdit$.next(undefined);
            }
        });
        combineLatest([
            this.messageToEdit$,
            this.channelService.activeParentMessageId$,
        ]).subscribe(([messageToEdit, parentMessageId]) => {
            if (messageToEdit &&
                messageToEdit.parent_id &&
                messageToEdit.parent_id !== parentMessageId) {
                this.messageToEdit$.next(undefined);
            }
        });
    }
    /**
     * This method returns how many authorized actions are available to the given message
     * @param message
     * @param enabledActions
     * @returns the count
     */
    getAuthorizedMessageActionsCount(message, enabledActions) {
        const customActions = this.customActions$.getValue() || [];
        const allActions = [...this.defaultActions, ...customActions];
        const currentUserId = this.chatClientService.chatClient.user?.id;
        const isMine = message.user_id === currentUserId;
        return allActions.filter((item) => item.isVisible(enabledActions, isMine, message)).length;
    }
}
MessageActionsService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: MessageActionsService, deps: [{ token: ChatClientService }, { token: NotificationService }, { token: ChannelService }], target: i0.ɵɵFactoryTarget.Injectable });
MessageActionsService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: MessageActionsService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: MessageActionsService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: ChatClientService }, { type: NotificationService }, { type: ChannelService }]; } });

/**
 * The `MessageReactionsService` provides customization options to message [reactions](https://getstream.io/chat/docs/javascript/send_reaction/?language=javascript).
 *
 */
class MessageReactionsService {
    constructor() {
        /**
         * The enabled [reactions](https://getstream.io/chat/docs/javascript/send_reaction/?language=javascript) and the associated emoji
         *
         * You can provide any string as a reaction. The emoji can be provided as a string, if you want to use custom images for reactions you have to provide a [custom reactions UI](../../services/CustomTemplatesService/#messagereactionstemplate)
         */
        this.reactions$ = new BehaviorSubject({
            haha: '😂',
            like: '👍',
            love: '❤️',
            sad: '😞',
            wow: '😮',
        });
    }
    /**
     * Sets the enabled reactions
     */
    set reactions(reactions) {
        this.reactions$.next(reactions);
    }
    /**
     * Get the currently enabled reactions
     */
    get reactions() {
        return this.reactions$.getValue();
    }
}
MessageReactionsService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: MessageReactionsService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
MessageReactionsService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: MessageReactionsService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: MessageReactionsService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return []; } });

/**
 * The `MessageReactionsSelectorComponent` makes it possible for users to react to a message, the reaction options can be set using the [`MessageReactionsService`](../../services/MessageReactionsService). You can read more about [message reactions](https://getstream.io/chat/docs/javascript/send_reaction/?language=javascript) in the platform documentation.
 */
class MessageReactionsSelectorComponent {
    constructor(channelService, messageReactionsService, cdRef) {
        this.channelService = channelService;
        this.messageReactionsService = messageReactionsService;
        this.cdRef = cdRef;
        /**
         * List of the user's own reactions of a [message](../types/stream-message.mdx), used to display the users of a reaction type.
         */
        this.ownReactions = [];
        this.reactionOptions = [];
        this.subscriptions = [];
        this.isViewInited = false;
    }
    ngOnInit() {
        this.subscriptions.push(this.messageReactionsService.reactions$.subscribe((reactions) => {
            this.reactionOptions = Object.keys(reactions);
            if (this.isViewInited) {
                this.cdRef.detectChanges();
            }
        }));
    }
    ngAfterViewInit() {
        this.isViewInited = true;
    }
    ngOnDestroy() {
        this.subscriptions.forEach((s) => s.unsubscribe());
    }
    trackByMessageReaction(_, item) {
        return item;
    }
    isOwnReaction(reactionType) {
        return !!this.ownReactions.find((r) => r.type === reactionType);
    }
    getEmojiByReaction(reactionType) {
        return this.messageReactionsService.reactions[reactionType];
    }
    async react(type) {
        this.ownReactions.find((r) => r.type === type)
            ? await this.channelService.removeReaction(this.messageId, type)
            : await this.channelService.addReaction(this.messageId, type);
    }
}
MessageReactionsSelectorComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: MessageReactionsSelectorComponent, deps: [{ token: ChannelService }, { token: MessageReactionsService }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
MessageReactionsSelectorComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.0.4", type: MessageReactionsSelectorComponent, selector: "stream-message-reactions-selector", inputs: { ownReactions: "ownReactions", messageId: "messageId" }, ngImport: i0, template: "<div\n  #selectorContainer\n  data-testid=\"reaction-selector\"\n  class=\"\n    str-chat__reaction-selector\n    str-chat-angular-v5__reaction-selector\n    str-chat__message-reaction-selector\n  \"\n>\n  <ul\n    class=\"str-chat__message-reactions-list str-chat__message-reactions-options\"\n  >\n    <li\n      *ngFor=\"\n        let reactionType of reactionOptions;\n        trackBy: trackByMessageReaction\n      \"\n      class=\"\n        str-chat__message-reactions-option\n        str-chat__message-reactions-list-item\n        str-chat__emoji\n      \"\n      data-testclass=\"emoji-option\"\n      [attr.data-testid]=\"reactionType\"\n      [class.str-chat__message-reactions-option-selected]=\"\n        isOwnReaction(reactionType)\n      \"\n      (click)=\"react(reactionType)\"\n      (keyup.enter)=\"react(reactionType)\"\n    >\n      <span\n        class=\"\n          emoji\n          str-chat__emoji-selector-emoji-angular\n          str-chat__message-reaction-emoji\n        \"\n      >\n        {{ getEmojiByReaction(reactionType) }}\n      </span>\n    </li>\n  </ul>\n</div>\n", dependencies: [{ kind: "directive", type: i4.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: MessageReactionsSelectorComponent, decorators: [{
            type: Component,
            args: [{ selector: 'stream-message-reactions-selector', template: "<div\n  #selectorContainer\n  data-testid=\"reaction-selector\"\n  class=\"\n    str-chat__reaction-selector\n    str-chat-angular-v5__reaction-selector\n    str-chat__message-reaction-selector\n  \"\n>\n  <ul\n    class=\"str-chat__message-reactions-list str-chat__message-reactions-options\"\n  >\n    <li\n      *ngFor=\"\n        let reactionType of reactionOptions;\n        trackBy: trackByMessageReaction\n      \"\n      class=\"\n        str-chat__message-reactions-option\n        str-chat__message-reactions-list-item\n        str-chat__emoji\n      \"\n      data-testclass=\"emoji-option\"\n      [attr.data-testid]=\"reactionType\"\n      [class.str-chat__message-reactions-option-selected]=\"\n        isOwnReaction(reactionType)\n      \"\n      (click)=\"react(reactionType)\"\n      (keyup.enter)=\"react(reactionType)\"\n    >\n      <span\n        class=\"\n          emoji\n          str-chat__emoji-selector-emoji-angular\n          str-chat__message-reaction-emoji\n        \"\n      >\n        {{ getEmojiByReaction(reactionType) }}\n      </span>\n    </li>\n  </ul>\n</div>\n" }]
        }], ctorParameters: function () { return [{ type: ChannelService }, { type: MessageReactionsService }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { ownReactions: [{
                type: Input
            }], messageId: [{
                type: Input
            }] } });

/**
 * The `MessageActionsBox` component displays a list of message actions (i.e edit), that can be opened or closed. You can find the [list of the supported actions](../concepts/message-interactions.mdx) in the message interaction guide.
 */
class MessageActionsBoxComponent {
    constructor(customTemplatesService, messageActionsService, cdRef) {
        this.customTemplatesService = customTemplatesService;
        this.messageActionsService = messageActionsService;
        this.cdRef = cdRef;
        /**
         * Indicates if the message actions are belonging to a message that was sent by the current user or not.
         */
        this.isMine = false;
        /**
         * The list of [channel capabilities](https://getstream.io/chat/docs/javascript/channel_capabilities/?language=javascript) that are enabled for the current user, the list of [supported interactions](../concepts/message-interactions.mdx) can be found in our message interaction guide. Unathorized actions won't be displayed on the UI.
         */
        this.enabledActions = [];
        this.visibleMessageActionItems = [];
        this.isEditModalOpen = false;
        this.customActions = [];
        this.subscriptions = [];
        this.isViewInited = false;
        this.messageActionItems = this.messageActionsService.defaultActions;
    }
    ngOnInit() {
        this.subscriptions.push(this.messageActionsService.customActions$.subscribe((actions) => {
            this.customActions = actions;
            this.setVisibleActions();
            if (this.isViewInited) {
                this.cdRef.detectChanges();
            }
        }));
        this.subscriptions.push(this.messageActionsService.messageToEdit$.subscribe((m) => {
            let isEditModalOpen = false;
            if (m && m.id === this.message?.id) {
                isEditModalOpen = true;
            }
            if (isEditModalOpen !== this.isEditModalOpen) {
                this.isEditModalOpen = isEditModalOpen;
                if (this.isViewInited) {
                    this.cdRef.detectChanges();
                }
            }
        }));
    }
    ngOnChanges(changes) {
        if (changes.isMine || changes.enabledActions || changes.message) {
            this.setVisibleActions();
        }
    }
    ngAfterViewInit() {
        this.isViewInited = true;
    }
    ngOnDestroy() {
        this.subscriptions.forEach((s) => s.unsubscribe());
    }
    getActionLabel(actionLabelOrTranslationKey) {
        return typeof actionLabelOrTranslationKey === 'string'
            ? actionLabelOrTranslationKey
            : actionLabelOrTranslationKey(this.message);
    }
    getReactionSelectorTemplateContext() {
        return {
            messageId: this.message?.id,
            ownReactions: this.message?.own_reactions || [],
        };
    }
    getMessageActionTemplateContext(item) {
        if (this.isReactAction(item)) {
            return {};
        }
        else {
            return {
                actionHandler: item.actionHandler,
                actionHandlerExtraParams: {
                    isMine: this.isMine,
                    messageTextHtmlElement: this.messageTextHtmlElement,
                },
                actionName: item.actionName,
                message: this.message,
                actionLabelOrTranslationKey: item.actionLabelOrTranslationKey,
            };
        }
    }
    trackByActionName(_, item) {
        return item.actionName;
    }
    isReactAction(item) {
        return item.actionName === 'react';
    }
    setVisibleActions() {
        if (!this.message) {
            this.visibleMessageActionItems = [];
        }
        else {
            this.visibleMessageActionItems = [
                ...this.messageActionItems,
                ...this.customActions,
            ].filter((item) => item.isVisible(this.enabledActions, this.isMine, this.message));
        }
    }
}
MessageActionsBoxComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: MessageActionsBoxComponent, deps: [{ token: CustomTemplatesService }, { token: MessageActionsService }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
MessageActionsBoxComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.0.4", type: MessageActionsBoxComponent, selector: "stream-message-actions-box", inputs: { isMine: "isMine", message: "message", messageTextHtmlElement: "messageTextHtmlElement", enabledActions: "enabledActions" }, usesOnChanges: true, ngImport: i0, template: "<div\n  #actionBox\n  data-testid=\"action-box\"\n  class=\"\n    str-chat__message-actions-box\n    str-chat__message-actions-box-angular\n    str-chat__message-actions-box--open\n  \"\n>\n  <ul class=\"str-chat__message-actions-list\">\n    <ng-container\n      *ngFor=\"let item of visibleMessageActionItems; trackBy: trackByActionName\"\n    >\n      <ng-container [ngSwitch]=\"item.actionName\">\n        <ng-container *ngSwitchCase=\"'react'\">\n          <ng-container\n            *ngTemplateOutlet=\"\n              (customTemplatesService.messageReactionsSelectorTemplate$\n                | async) || defaultReactionSelector;\n              context: getReactionSelectorTemplateContext()\n            \"\n          ></ng-container>\n        </ng-container>\n        <ng-container *ngSwitchDefault>\n          <ng-container\n            *ngTemplateOutlet=\"\n              (customTemplatesService.messageActionsBoxItemTemplate$ | async) ||\n                defaultMessageActionItem;\n              context: getMessageActionTemplateContext(item)\n            \"\n          ></ng-container>\n        </ng-container>\n      </ng-container>\n    </ng-container>\n  </ul>\n</div>\n\n<ng-template\n  #defaultMessageActionItem\n  let-actionName=\"actionName\"\n  let-actionHandler=\"actionHandler\"\n  let-actionLabelOrTranslationKey=\"actionLabelOrTranslationKey\"\n  let-actionHandlerExtraParams=\"actionHandlerExtraParams\"\n>\n  <button\n    class=\"str-chat__message-actions-list-item-button\"\n    [attr.data-testid]=\"actionName + '-action'\"\n    (click)=\"actionHandler(message, actionHandlerExtraParams)\"\n  >\n    <li class=\"str-chat__message-actions-list-item\">\n      {{ getActionLabel(actionLabelOrTranslationKey) | translate }}\n    </li>\n  </button>\n</ng-template>\n\n<ng-template\n  #defaultReactionSelector\n  let-messageId=\"messageId\"\n  let-ownReactions=\"ownReactions\"\n>\n  <stream-message-reactions-selector\n    [messageId]=\"message?.id\"\n    [ownReactions]=\"message?.own_reactions || []\"\n  ></stream-message-reactions-selector>\n</ng-template>\n", dependencies: [{ kind: "directive", type: i4.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i4.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: i4.NgSwitch, selector: "[ngSwitch]", inputs: ["ngSwitch"] }, { kind: "directive", type: i4.NgSwitchCase, selector: "[ngSwitchCase]", inputs: ["ngSwitchCase"] }, { kind: "directive", type: i4.NgSwitchDefault, selector: "[ngSwitchDefault]" }, { kind: "component", type: MessageReactionsSelectorComponent, selector: "stream-message-reactions-selector", inputs: ["ownReactions", "messageId"] }, { kind: "pipe", type: i4.AsyncPipe, name: "async" }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: MessageActionsBoxComponent, decorators: [{
            type: Component,
            args: [{ selector: 'stream-message-actions-box', template: "<div\n  #actionBox\n  data-testid=\"action-box\"\n  class=\"\n    str-chat__message-actions-box\n    str-chat__message-actions-box-angular\n    str-chat__message-actions-box--open\n  \"\n>\n  <ul class=\"str-chat__message-actions-list\">\n    <ng-container\n      *ngFor=\"let item of visibleMessageActionItems; trackBy: trackByActionName\"\n    >\n      <ng-container [ngSwitch]=\"item.actionName\">\n        <ng-container *ngSwitchCase=\"'react'\">\n          <ng-container\n            *ngTemplateOutlet=\"\n              (customTemplatesService.messageReactionsSelectorTemplate$\n                | async) || defaultReactionSelector;\n              context: getReactionSelectorTemplateContext()\n            \"\n          ></ng-container>\n        </ng-container>\n        <ng-container *ngSwitchDefault>\n          <ng-container\n            *ngTemplateOutlet=\"\n              (customTemplatesService.messageActionsBoxItemTemplate$ | async) ||\n                defaultMessageActionItem;\n              context: getMessageActionTemplateContext(item)\n            \"\n          ></ng-container>\n        </ng-container>\n      </ng-container>\n    </ng-container>\n  </ul>\n</div>\n\n<ng-template\n  #defaultMessageActionItem\n  let-actionName=\"actionName\"\n  let-actionHandler=\"actionHandler\"\n  let-actionLabelOrTranslationKey=\"actionLabelOrTranslationKey\"\n  let-actionHandlerExtraParams=\"actionHandlerExtraParams\"\n>\n  <button\n    class=\"str-chat__message-actions-list-item-button\"\n    [attr.data-testid]=\"actionName + '-action'\"\n    (click)=\"actionHandler(message, actionHandlerExtraParams)\"\n  >\n    <li class=\"str-chat__message-actions-list-item\">\n      {{ getActionLabel(actionLabelOrTranslationKey) | translate }}\n    </li>\n  </button>\n</ng-template>\n\n<ng-template\n  #defaultReactionSelector\n  let-messageId=\"messageId\"\n  let-ownReactions=\"ownReactions\"\n>\n  <stream-message-reactions-selector\n    [messageId]=\"message?.id\"\n    [ownReactions]=\"message?.own_reactions || []\"\n  ></stream-message-reactions-selector>\n</ng-template>\n" }]
        }], ctorParameters: function () { return [{ type: CustomTemplatesService }, { type: MessageActionsService }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { isMine: [{
                type: Input
            }], message: [{
                type: Input
            }], messageTextHtmlElement: [{
                type: Input
            }], enabledActions: [{
                type: Input
            }] } });

/**
 * The `Notification` component displays a notification within the [`NotificationList`](./NotificationListComponent.mdx)
 */
class NotificationComponent {
    constructor() { }
}
NotificationComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: NotificationComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
NotificationComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.0.4", type: NotificationComponent, selector: "stream-notification", inputs: { type: "type", content: "content" }, ngImport: i0, template: "<div\n  data-testid=\"custom-notification\"\n  class=\"str-chat__custom-notification notification-{{\n    type\n  }} str-chat__notification\"\n>\n  <ng-container *ngIf=\"content; else elseContent\">\n    <ng-container *ngTemplateOutlet=\"content\"></ng-container>\n  </ng-container>\n  <ng-template #elseContent>\n    <ng-content></ng-content>\n  </ng-template>\n</div>\n", dependencies: [{ kind: "directive", type: i4.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i4.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: NotificationComponent, decorators: [{
            type: Component,
            args: [{ selector: 'stream-notification', template: "<div\n  data-testid=\"custom-notification\"\n  class=\"str-chat__custom-notification notification-{{\n    type\n  }} str-chat__notification\"\n>\n  <ng-container *ngIf=\"content; else elseContent\">\n    <ng-container *ngTemplateOutlet=\"content\"></ng-container>\n  </ng-container>\n  <ng-template #elseContent>\n    <ng-content></ng-content>\n  </ng-template>\n</div>\n" }]
        }], ctorParameters: function () { return []; }, propDecorators: { type: [{
                type: Input
            }], content: [{
                type: Input
            }] } });

/**
 * The `NotificationList` component displays the list of active notifications.
 */
class NotificationListComponent {
    constructor(customTemplatesService, notificationService, themeService) {
        this.customTemplatesService = customTemplatesService;
        this.notificationService = notificationService;
        this.themeService = themeService;
        this.notifications$ = this.notificationService.notifications$;
        this.theme$ = this.themeService.theme$;
    }
    trackById(_, item) {
        return item.id;
    }
    getNotificationContentContext(notification) {
        return {
            ...notification.templateContext,
            dismissFn: notification.dismissFn,
        };
    }
}
NotificationListComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: NotificationListComponent, deps: [{ token: CustomTemplatesService }, { token: NotificationService }, { token: ThemeService }], target: i0.ɵɵFactoryTarget.Component });
NotificationListComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.0.4", type: NotificationListComponent, selector: "stream-notification-list", ngImport: i0, template: "<div\n  data-testid=\"notification-list\"\n  class=\"str-chat str-chat__theme-{{\n    theme$ | async\n  }} str-chat__list-notifications\"\n>\n  <ng-container\n    *ngFor=\"let notification of notifications$ | async; trackBy: trackById\"\n  >\n    <ng-template #notificationContent>\n      <div\n        *ngIf=\"notification.text !== undefined\"\n        data-testclass=\"notification-content\"\n      >\n        {{ notification.text | translate: notification.translateParams }}\n      </div>\n      <ng-container *ngIf=\"notification.template !== undefined\">\n        <ng-container\n          *ngTemplateOutlet=\"\n            notification.template;\n            context: getNotificationContentContext(notification)\n          \"\n        ></ng-container>\n      </ng-container>\n    </ng-template>\n    <ng-container\n      *ngTemplateOutlet=\"\n        (customTemplatesService.notificationTemplate$ | async) ||\n          defaultNotification;\n        context: { type: notification.type, content: notificationContent }\n      \"\n    ></ng-container>\n  </ng-container>\n</div>\n\n<ng-template #defaultNotification let-type=\"type\" let-content=\"content\">\n  <stream-notification [type]=\"type\" [content]=\"content\"></stream-notification>\n</ng-template>\n", dependencies: [{ kind: "directive", type: i4.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i4.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i4.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "component", type: NotificationComponent, selector: "stream-notification", inputs: ["type", "content"] }, { kind: "pipe", type: i4.AsyncPipe, name: "async" }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: NotificationListComponent, decorators: [{
            type: Component,
            args: [{ selector: 'stream-notification-list', template: "<div\n  data-testid=\"notification-list\"\n  class=\"str-chat str-chat__theme-{{\n    theme$ | async\n  }} str-chat__list-notifications\"\n>\n  <ng-container\n    *ngFor=\"let notification of notifications$ | async; trackBy: trackById\"\n  >\n    <ng-template #notificationContent>\n      <div\n        *ngIf=\"notification.text !== undefined\"\n        data-testclass=\"notification-content\"\n      >\n        {{ notification.text | translate: notification.translateParams }}\n      </div>\n      <ng-container *ngIf=\"notification.template !== undefined\">\n        <ng-container\n          *ngTemplateOutlet=\"\n            notification.template;\n            context: getNotificationContentContext(notification)\n          \"\n        ></ng-container>\n      </ng-container>\n    </ng-template>\n    <ng-container\n      *ngTemplateOutlet=\"\n        (customTemplatesService.notificationTemplate$ | async) ||\n          defaultNotification;\n        context: { type: notification.type, content: notificationContent }\n      \"\n    ></ng-container>\n  </ng-container>\n</div>\n\n<ng-template #defaultNotification let-type=\"type\" let-content=\"content\">\n  <stream-notification [type]=\"type\" [content]=\"content\"></stream-notification>\n</ng-template>\n" }]
        }], ctorParameters: function () { return [{ type: CustomTemplatesService }, { type: NotificationService }, { type: ThemeService }]; } });

/**
 * The `Modal` component displays its content in an overlay. The modal can be closed with a close button, if the user clicks outside of the modal content, or if the escape button is pressed. The modal can also be closed from outside.
 */
class ModalComponent {
    constructor() {
        /**
         * If `true` the modal will be displayed, if `false` the modal will be hidden
         */
        this.isOpen = false;
        /**
         * Emits `true` if the modal becomes visible, and `false` if the modal is closed.
         */
        this.isOpenChange = new EventEmitter();
        this.watchForEscPress = (event) => {
            if (event.key === 'Escape') {
                this.close();
            }
        };
        this.stopWatchForEscPress = () => {
            window.removeEventListener('keyup', this.watchForEscPress);
        };
        this.watchForOutsideClicks = (event) => {
            if (!this.innerContainer?.nativeElement.contains(event.target)) {
                this.close();
            }
        };
    }
    ngOnChanges(changes) {
        if (changes.isOpen) {
            if (this.isOpen) {
                window.addEventListener('keyup', this.watchForEscPress);
                setTimeout(() => window.addEventListener('click', this.watchForOutsideClicks), 0);
            }
            else {
                this.stopWatchForOutsideClicks();
                this.stopWatchForEscPress();
            }
        }
    }
    close() {
        this.isOpen = false;
        this.isOpenChange.emit(false);
        this.stopWatchForOutsideClicks();
        this.stopWatchForEscPress();
    }
    stopWatchForOutsideClicks() {
        window.removeEventListener('click', this.watchForOutsideClicks);
    }
}
ModalComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: ModalComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
ModalComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.0.4", type: ModalComponent, selector: "stream-modal", inputs: { isOpen: "isOpen", content: "content" }, outputs: { isOpenChange: "isOpenChange" }, viewQueries: [{ propertyName: "innerContainer", first: true, predicate: ["modalInner"], descendants: true }], usesOnChanges: true, ngImport: i0, template: "<div\n  data-testid=\"modal\"\n  class=\"str-chat__modal str-chat__modal--{{ isOpen ? 'open' : 'close' }}\"\n>\n  <div\n    data-testid=\"close\"\n    class=\"str-chat__modal__close-button\"\n    (click)=\"close()\"\n    (keyup.enter)=\"close()\"\n  >\n    <stream-icon-placeholder icon=\"close\"></stream-icon-placeholder>\n  </div>\n  <div #modalInner class=\"str-chat__modal__inner\">\n    <ng-container *ngIf=\"content; else elseContent\">\n      <ng-container *ngTemplateOutlet=\"content\"></ng-container>\n    </ng-container>\n    <ng-template #elseContent>\n      <ng-content></ng-content>\n    </ng-template>\n  </div>\n</div>\n", dependencies: [{ kind: "directive", type: i4.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i4.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "component", type: IconPlaceholderComponent, selector: "stream-icon-placeholder", inputs: ["icon"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: ModalComponent, decorators: [{
            type: Component,
            args: [{ selector: 'stream-modal', template: "<div\n  data-testid=\"modal\"\n  class=\"str-chat__modal str-chat__modal--{{ isOpen ? 'open' : 'close' }}\"\n>\n  <div\n    data-testid=\"close\"\n    class=\"str-chat__modal__close-button\"\n    (click)=\"close()\"\n    (keyup.enter)=\"close()\"\n  >\n    <stream-icon-placeholder icon=\"close\"></stream-icon-placeholder>\n  </div>\n  <div #modalInner class=\"str-chat__modal__inner\">\n    <ng-container *ngIf=\"content; else elseContent\">\n      <ng-container *ngTemplateOutlet=\"content\"></ng-container>\n    </ng-container>\n    <ng-template #elseContent>\n      <ng-content></ng-content>\n    </ng-template>\n  </div>\n</div>\n" }]
        }], ctorParameters: function () { return []; }, propDecorators: { isOpen: [{
                type: Input
            }], content: [{
                type: Input
            }], isOpenChange: [{
                type: Output
            }], innerContainer: [{
                type: ViewChild,
                args: ['modalInner']
            }] } });

/**
 * The component watches for the [`channelService.bouncedMessage$` stream](../../services/ChannelService/#bouncedmessage) and opens the bounce modal if a message is emitted.
 *
 * To bounce messages, you need to set up [semantic filters for moderation](https://getstream.io/automated-moderation/docs/automod_configuration/?q=semantic%20filters).
 */
class MessageBouncePromptComponent {
    constructor(channelService, customTemplatesService, messageActionsService) {
        this.channelService = channelService;
        this.customTemplatesService = customTemplatesService;
        this.messageActionsService = messageActionsService;
        this.class = 'str-chat__message-bounce-prompt';
        this.isModalOpen = false;
        this.subscriptions = [];
        this.messageBounceModalOpenChanged = (isOpen) => {
            this.isModalOpen = isOpen;
            if (!isOpen) {
                this.message = undefined;
                this.channelService.bouncedMessage$.next(undefined);
            }
        };
        this.subscriptions.push(this.channelService.bouncedMessage$.subscribe((m) => {
            if (m !== this.message) {
                this.message = m;
                if (this.message) {
                    this.isModalOpen = true;
                }
            }
        }));
    }
    ngOnDestroy() {
        this.subscriptions.forEach((s) => s.unsubscribe());
    }
    async resendMessage() {
        this.isModalOpen = false;
        await this.channelService.resendMessage(this.message);
        this.message = undefined;
        this.channelService.bouncedMessage$.next(undefined);
    }
    async deleteMessage() {
        if (!this.message) {
            return;
        }
        this.isModalOpen = false;
        await this.channelService.deleteMessage(this.message, true);
        this.message = undefined;
        this.channelService.bouncedMessage$.next(undefined);
    }
    editMessage() {
        this.isModalOpen = false;
        this.messageActionsService.messageToEdit$.next(this.message);
        this.message = undefined;
        this.channelService.bouncedMessage$.next(undefined);
    }
}
MessageBouncePromptComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: MessageBouncePromptComponent, deps: [{ token: ChannelService }, { token: CustomTemplatesService }, { token: MessageActionsService }], target: i0.ɵɵFactoryTarget.Component });
MessageBouncePromptComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.0.4", type: MessageBouncePromptComponent, selector: "stream-message-bounce-prompt", host: { properties: { "class": "this.class" } }, ngImport: i0, template: "<ng-container\n  *ngTemplateOutlet=\"\n    (customTemplatesService.modalTemplate$ | async) || defaultModal;\n    context: {\n      message: message,\n      isOpen: isModalOpen,\n      isOpenChangeHandler: messageBounceModalOpenChanged,\n      content: modalContent\n    }\n  \"\n></ng-container>\n\n<ng-template\n  #defaultModal\n  let-isOpen=\"isOpen\"\n  let-isOpenChangeHandler=\"isOpenChangeHandler\"\n  let-content=\"content\"\n>\n  <stream-modal\n    *ngIf=\"isOpen\"\n    [isOpen]=\"isOpen\"\n    [content]=\"content\"\n    (isOpenChange)=\"isOpenChangeHandler($event)\"\n  >\n  </stream-modal>\n</ng-template>\n\n<ng-template #modalContent>\n  <div\n    class=\"str-chat__message-bounce-prompt\"\n    data-testid=\"message-bounce-prompt\"\n  >\n    <div class=\"str-chat__message-bounce-prompt-header\">\n      {{\n        \"streamChat.This message did not meet our content guidelines\"\n          | translate\n      }}\n    </div>\n    <div class=\"str-chat__message-bounce-actions\">\n      <button\n        class=\"str-chat__message-bounce-edit\"\n        data-testid=\"message-bounce-edit\"\n        type=\"button\"\n        (click)=\"editMessage()\"\n        (keyup.enter)=\"editMessage()\"\n      >\n        {{ \"streamChat.Edit Message\" | translate }}\n      </button>\n      <button\n        class=\"str-chat__message-bounce-send\"\n        data-testid=\"message-bounce-send\"\n        (click)=\"resendMessage()\"\n        (keyup.enter)=\"resendMessage()\"\n      >\n        {{ \"streamChat.Send Anyway\" | translate }}\n      </button>\n      <button\n        class=\"str-chat__message-bounce-delete\"\n        data-testid=\"message-bounce-delete\"\n        (click)=\"deleteMessage()\"\n        (keyup.enter)=\"deleteMessage()\"\n      >\n        {{ \"streamChat.Delete\" | translate }}\n      </button>\n    </div>\n  </div>\n</ng-template>\n", dependencies: [{ kind: "directive", type: i4.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i4.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "component", type: ModalComponent, selector: "stream-modal", inputs: ["isOpen", "content"], outputs: ["isOpenChange"] }, { kind: "pipe", type: i4.AsyncPipe, name: "async" }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: MessageBouncePromptComponent, decorators: [{
            type: Component,
            args: [{ selector: 'stream-message-bounce-prompt', template: "<ng-container\n  *ngTemplateOutlet=\"\n    (customTemplatesService.modalTemplate$ | async) || defaultModal;\n    context: {\n      message: message,\n      isOpen: isModalOpen,\n      isOpenChangeHandler: messageBounceModalOpenChanged,\n      content: modalContent\n    }\n  \"\n></ng-container>\n\n<ng-template\n  #defaultModal\n  let-isOpen=\"isOpen\"\n  let-isOpenChangeHandler=\"isOpenChangeHandler\"\n  let-content=\"content\"\n>\n  <stream-modal\n    *ngIf=\"isOpen\"\n    [isOpen]=\"isOpen\"\n    [content]=\"content\"\n    (isOpenChange)=\"isOpenChangeHandler($event)\"\n  >\n  </stream-modal>\n</ng-template>\n\n<ng-template #modalContent>\n  <div\n    class=\"str-chat__message-bounce-prompt\"\n    data-testid=\"message-bounce-prompt\"\n  >\n    <div class=\"str-chat__message-bounce-prompt-header\">\n      {{\n        \"streamChat.This message did not meet our content guidelines\"\n          | translate\n      }}\n    </div>\n    <div class=\"str-chat__message-bounce-actions\">\n      <button\n        class=\"str-chat__message-bounce-edit\"\n        data-testid=\"message-bounce-edit\"\n        type=\"button\"\n        (click)=\"editMessage()\"\n        (keyup.enter)=\"editMessage()\"\n      >\n        {{ \"streamChat.Edit Message\" | translate }}\n      </button>\n      <button\n        class=\"str-chat__message-bounce-send\"\n        data-testid=\"message-bounce-send\"\n        (click)=\"resendMessage()\"\n        (keyup.enter)=\"resendMessage()\"\n      >\n        {{ \"streamChat.Send Anyway\" | translate }}\n      </button>\n      <button\n        class=\"str-chat__message-bounce-delete\"\n        data-testid=\"message-bounce-delete\"\n        (click)=\"deleteMessage()\"\n        (keyup.enter)=\"deleteMessage()\"\n      >\n        {{ \"streamChat.Delete\" | translate }}\n      </button>\n    </div>\n  </div>\n</ng-template>\n" }]
        }], ctorParameters: function () { return [{ type: ChannelService }, { type: CustomTemplatesService }, { type: MessageActionsService }]; }, propDecorators: { class: [{
                type: HostBinding
            }] } });

/**
 * The `Channel` component is a container component that displays the [`ChannelHeader`](./ChannelHeaderComponent.mdx), [`MessageList`](./MessageListComponent.mdx), [`NotificationList`](./NotificationListComponent.mdx) and [`MessageInput`](./MessageInputComponent.mdx) components. You can also provide the [`Thread`](./ThreadComponent.mdx) component to use message [threads](https://getstream.io/chat/docs/javascript/threads/?language=javascript).
 */
class ChannelComponent {
    constructor(channelService, themeService, customTemplatesService) {
        this.channelService = channelService;
        this.themeService = themeService;
        this.customTemplatesService = customTemplatesService;
        this.subscriptions = [];
        this.isError$ = combineLatest([
            this.channelService.channelQueryState$,
            this.channelService.activeChannel$,
        ]).pipe(map(([state, activeChannel]) => {
            return !activeChannel && state?.state === 'error';
        }));
        this.isInitializing$ = combineLatest([
            this.channelService.channelQueryState$,
            this.channelService.activeChannel$,
        ]).pipe(map(([state, activeChannel]) => {
            return !activeChannel && state?.state === 'in-progress';
        }));
        this.isActiveThread$ = this.channelService.activeParentMessageId$.pipe(map((id) => !!id));
        this.theme$ = this.themeService.theme$;
        this.isActiveChannel$ = this.channelService.activeChannel$.pipe(map((c) => !!c));
    }
}
ChannelComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: ChannelComponent, deps: [{ token: ChannelService }, { token: ThemeService }, { token: CustomTemplatesService }], target: i0.ɵɵFactoryTarget.Component });
ChannelComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.0.4", type: ChannelComponent, selector: "stream-channel", ngImport: i0, template: "<div\n  class=\"str-chat str-chat-channel messaging str-chat__channel str-chat__theme-{{\n    theme$ | async\n  }}\"\n>\n  <div\n    *ngIf=\"\n      (isError$ | async) === false &&\n        (isInitializing$ | async) === false &&\n        (isActiveChannel$ | async) === true;\n      else noChannel\n    \"\n    class=\"str-chat__container\"\n  >\n    <ng-container\n      *ngTemplateOutlet=\"\n        (customTemplatesService.messageBouncePromptTemplate$ | async) ||\n        defaultMessageBouncePrompt\n      \"\n    ></ng-container>\n    <ng-template #defaultMessageBouncePrompt>\n      <stream-message-bounce-prompt></stream-message-bounce-prompt>\n    </ng-template>\n    <div class=\"str-chat__main-panel\">\n      <ng-content></ng-content>\n    </div>\n    <ng-content\n      *ngIf=\"isActiveThread$ | async\"\n      select='[name=\"thread\"]'\n    ></ng-content>\n  </div>\n  <ng-template #noChannel>\n    <div\n      *ngIf=\"\n        (isInitializing$ | async) === false &&\n        ((isError$ | async) === true || (isActiveChannel$ | async) === false)\n      \"\n      class=\"str-chat__empty-channel\"\n    >\n      <stream-icon icon=\"chat-bubble\"></stream-icon>\n      <p class=\"str-chat__empty-channel-text\">\n        {{ \"streamChat.No chats here yet\u2026\" | translate }}\n      </p>\n      <div class=\"str-chat__empty-channel-notifications\">\n        <stream-notification-list></stream-notification-list>\n      </div>\n    </div>\n    <div\n      *ngIf=\"\n        (isInitializing$ | async) === true &&\n        (isError$ | async) === false &&\n        (isActiveChannel$ | async) === false\n      \"\n      class=\"str-chat__loading-channel\"\n    >\n      <div class=\"str-chat__loading-channel-header\">\n        <div class=\"str-chat__loading-channel-header-avatar\"></div>\n        <div class=\"str-chat__loading-channel-header-end\">\n          <div class=\"str-chat__loading-channel-header-name\"></div>\n          <div class=\"str-chat__loading-channel-header-info\"></div>\n        </div>\n      </div>\n      <div class=\"str-chat__loading-channel-message-list\">\n        <div class=\"str-chat__loading-channel-message\">\n          <div class=\"str-chat__loading-channel-message-avatar\"></div>\n          <div class=\"str-chat__loading-channel-message-end\">\n            <div class=\"str-chat__loading-channel-message-sender\"></div>\n            <div class=\"str-chat__loading-channel-message-last-row\">\n              <div class=\"str-chat__loading-channel-message-text\"></div>\n              <div class=\"str-chat__loading-channel-message-date\"></div>\n            </div>\n          </div>\n        </div>\n        <div class=\"str-chat__loading-channel-message\">\n          <div class=\"str-chat__loading-channel-message-avatar\"></div>\n          <div class=\"str-chat__loading-channel-message-end\">\n            <div class=\"str-chat__loading-channel-message-sender\"></div>\n            <div class=\"str-chat__loading-channel-message-last-row\">\n              <div class=\"str-chat__loading-channel-message-text\"></div>\n              <div class=\"str-chat__loading-channel-message-date\"></div>\n            </div>\n          </div>\n        </div>\n        <div class=\"str-chat__loading-channel-message\">\n          <div class=\"str-chat__loading-channel-message-avatar\"></div>\n          <div class=\"str-chat__loading-channel-message-end\">\n            <div class=\"str-chat__loading-channel-message-sender\"></div>\n            <div class=\"str-chat__loading-channel-message-last-row\">\n              <div class=\"str-chat__loading-channel-message-text\"></div>\n              <div class=\"str-chat__loading-channel-message-date\"></div>\n            </div>\n          </div>\n        </div>\n      </div>\n      <div class=\"str-chat__loading-channel-message-input-row\">\n        <div class=\"str-chat__loading-channel-message-input\"></div>\n        <div class=\"str-chat__loading-channel-message-send\"></div>\n      </div>\n    </div>\n  </ng-template>\n</div>\n", dependencies: [{ kind: "directive", type: i4.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i4.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "component", type: IconComponent, selector: "stream-icon", inputs: ["icon"] }, { kind: "component", type: NotificationListComponent, selector: "stream-notification-list" }, { kind: "component", type: MessageBouncePromptComponent, selector: "stream-message-bounce-prompt" }, { kind: "pipe", type: i4.AsyncPipe, name: "async" }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: ChannelComponent, decorators: [{
            type: Component,
            args: [{ selector: 'stream-channel', template: "<div\n  class=\"str-chat str-chat-channel messaging str-chat__channel str-chat__theme-{{\n    theme$ | async\n  }}\"\n>\n  <div\n    *ngIf=\"\n      (isError$ | async) === false &&\n        (isInitializing$ | async) === false &&\n        (isActiveChannel$ | async) === true;\n      else noChannel\n    \"\n    class=\"str-chat__container\"\n  >\n    <ng-container\n      *ngTemplateOutlet=\"\n        (customTemplatesService.messageBouncePromptTemplate$ | async) ||\n        defaultMessageBouncePrompt\n      \"\n    ></ng-container>\n    <ng-template #defaultMessageBouncePrompt>\n      <stream-message-bounce-prompt></stream-message-bounce-prompt>\n    </ng-template>\n    <div class=\"str-chat__main-panel\">\n      <ng-content></ng-content>\n    </div>\n    <ng-content\n      *ngIf=\"isActiveThread$ | async\"\n      select='[name=\"thread\"]'\n    ></ng-content>\n  </div>\n  <ng-template #noChannel>\n    <div\n      *ngIf=\"\n        (isInitializing$ | async) === false &&\n        ((isError$ | async) === true || (isActiveChannel$ | async) === false)\n      \"\n      class=\"str-chat__empty-channel\"\n    >\n      <stream-icon icon=\"chat-bubble\"></stream-icon>\n      <p class=\"str-chat__empty-channel-text\">\n        {{ \"streamChat.No chats here yet\u2026\" | translate }}\n      </p>\n      <div class=\"str-chat__empty-channel-notifications\">\n        <stream-notification-list></stream-notification-list>\n      </div>\n    </div>\n    <div\n      *ngIf=\"\n        (isInitializing$ | async) === true &&\n        (isError$ | async) === false &&\n        (isActiveChannel$ | async) === false\n      \"\n      class=\"str-chat__loading-channel\"\n    >\n      <div class=\"str-chat__loading-channel-header\">\n        <div class=\"str-chat__loading-channel-header-avatar\"></div>\n        <div class=\"str-chat__loading-channel-header-end\">\n          <div class=\"str-chat__loading-channel-header-name\"></div>\n          <div class=\"str-chat__loading-channel-header-info\"></div>\n        </div>\n      </div>\n      <div class=\"str-chat__loading-channel-message-list\">\n        <div class=\"str-chat__loading-channel-message\">\n          <div class=\"str-chat__loading-channel-message-avatar\"></div>\n          <div class=\"str-chat__loading-channel-message-end\">\n            <div class=\"str-chat__loading-channel-message-sender\"></div>\n            <div class=\"str-chat__loading-channel-message-last-row\">\n              <div class=\"str-chat__loading-channel-message-text\"></div>\n              <div class=\"str-chat__loading-channel-message-date\"></div>\n            </div>\n          </div>\n        </div>\n        <div class=\"str-chat__loading-channel-message\">\n          <div class=\"str-chat__loading-channel-message-avatar\"></div>\n          <div class=\"str-chat__loading-channel-message-end\">\n            <div class=\"str-chat__loading-channel-message-sender\"></div>\n            <div class=\"str-chat__loading-channel-message-last-row\">\n              <div class=\"str-chat__loading-channel-message-text\"></div>\n              <div class=\"str-chat__loading-channel-message-date\"></div>\n            </div>\n          </div>\n        </div>\n        <div class=\"str-chat__loading-channel-message\">\n          <div class=\"str-chat__loading-channel-message-avatar\"></div>\n          <div class=\"str-chat__loading-channel-message-end\">\n            <div class=\"str-chat__loading-channel-message-sender\"></div>\n            <div class=\"str-chat__loading-channel-message-last-row\">\n              <div class=\"str-chat__loading-channel-message-text\"></div>\n              <div class=\"str-chat__loading-channel-message-date\"></div>\n            </div>\n          </div>\n        </div>\n      </div>\n      <div class=\"str-chat__loading-channel-message-input-row\">\n        <div class=\"str-chat__loading-channel-message-input\"></div>\n        <div class=\"str-chat__loading-channel-message-send\"></div>\n      </div>\n    </div>\n  </ng-template>\n</div>\n" }]
        }], ctorParameters: function () { return [{ type: ChannelService }, { type: ThemeService }, { type: CustomTemplatesService }]; } });

const listUsers = (users) => {
    let outStr = '';
    const slicedArr = users.map((item) => item.name || item.id).slice(0, 5);
    const restLength = users.length - slicedArr.length;
    const commaSeparatedUsers = slicedArr.join(', ');
    outStr = commaSeparatedUsers;
    if (restLength > 0) {
        outStr += ` +${restLength}`;
    }
    return outStr;
};

const getChannelDisplayText = (channel, currentUser) => {
    if (channel.data?.name) {
        return channel.data.name;
    }
    if (channel.state.members && Object.keys(channel.state.members).length > 0) {
        const members = Object.values(channel.state.members)
            .map((m) => m.user || { id: m.user_id })
            .filter((m) => m.id !== currentUser?.id);
        return listUsers(members);
    }
    return channel.id;
};

/**
 * The `ChannelHeader` component displays the avatar and name of the currently active channel along with member and watcher information. You can read about [the difference between members and watchers](https://getstream.io/chat/docs/javascript/watch_channel/?language=javascript#watchers-vs-members) in the platform documentation. Please note that number of watchers is only displayed if the user has [`connect-events` capability](https://getstream.io/chat/docs/javascript/channel_capabilities/?language=javascript)
 */
class ChannelHeaderComponent {
    constructor(channelService, customTemplatesService, cdRef, chatClientService) {
        this.channelService = channelService;
        this.customTemplatesService = customTemplatesService;
        this.cdRef = cdRef;
        this.chatClientService = chatClientService;
        this.subscriptions = [];
        this.channelService.activeChannel$.subscribe((c) => {
            this.activeChannel = c;
            const capabilities = this.activeChannel?.data
                ?.own_capabilities;
            if (!capabilities) {
                return;
            }
            this.canReceiveConnectEvents =
                capabilities.indexOf('connect-events') !== -1;
        });
    }
    ngOnInit() {
        this.subscriptions.push(this.customTemplatesService.channelActionsTemplate$.subscribe((template) => {
            this.channelActionsTemplate = template;
            this.cdRef.detectChanges();
        }));
        this.subscriptions.push(this.customTemplatesService.channelHeaderInfoTemplate$.subscribe((template) => {
            this.channelHeaderInfoTemplate = template;
            this.cdRef.detectChanges();
        }));
    }
    ngOnDestroy() {
        this.subscriptions.forEach((s) => s.unsubscribe());
    }
    getChannelActionsContext() {
        return { channel: this.activeChannel };
    }
    getChannelInfoContext() {
        return { channel: this.activeChannel };
    }
    get memberCountParam() {
        return { memberCount: this.activeChannel?.data?.member_count || 0 };
    }
    get watcherCountParam() {
        return { watcherCount: this.activeChannel?.state?.watcher_count || 0 };
    }
    get displayText() {
        if (!this.activeChannel) {
            return '';
        }
        return getChannelDisplayText(this.activeChannel, this.chatClientService.chatClient.user);
    }
    get avatarName() {
        return this.activeChannel?.data?.name;
    }
}
ChannelHeaderComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: ChannelHeaderComponent, deps: [{ token: ChannelService }, { token: CustomTemplatesService }, { token: i0.ChangeDetectorRef }, { token: ChatClientService }], target: i0.ɵɵFactoryTarget.Component });
ChannelHeaderComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.0.4", type: ChannelHeaderComponent, selector: "stream-channel-header", ngImport: i0, template: "<div class=\"str-chat__header-livestream str-chat__channel-header\">\n  <ng-content></ng-content>\n  <stream-avatar-placeholder\n    type=\"channel\"\n    location=\"channel-header\"\n    imageUrl=\"{{ activeChannel?.data?.image }}\"\n    name=\"{{ avatarName }}\"\n    [channel]=\"activeChannel\"\n  ></stream-avatar-placeholder>\n  <div class=\"str-chat__header-livestream-left str-chat__channel-header-end\">\n    <p\n      data-testid=\"name\"\n      class=\"\n        str-chat__header-livestream-left--title str-chat__channel-header-title\n      \"\n    >\n      {{ displayText }}\n    </p>\n    <ng-container\n      *ngTemplateOutlet=\"\n        channelHeaderInfoTemplate || defaultChannelInfo;\n        context: getChannelInfoContext()\n      \"\n    ></ng-container>\n    <ng-template #defaultChannelInfo>\n      <p\n        data-testid=\"info\"\n        class=\"\n          str-chat__header-livestream-left--members\n          str-chat__channel-header-info\n        \"\n      >\n        {{'streamChat.{{ memberCount }} members' | translate:memberCountParam}}\n        {{canReceiveConnectEvents ? ('streamChat.{{ watcherCount }} online' |\n        translate:watcherCountParam) : ''}}\n      </p>\n    </ng-template>\n  </div>\n  <ng-container *ngIf=\"channelActionsTemplate\">\n    <ng-container\n      *ngTemplateOutlet=\"\n        channelActionsTemplate;\n        context: getChannelActionsContext()\n      \"\n    ></ng-container>\n  </ng-container>\n</div>\n", dependencies: [{ kind: "directive", type: i4.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i4.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "component", type: AvatarPlaceholderComponent, selector: "stream-avatar-placeholder", inputs: ["name", "imageUrl", "location", "channel", "user", "type", "initialsType", "showOnlineIndicator"] }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: ChannelHeaderComponent, decorators: [{
            type: Component,
            args: [{ selector: 'stream-channel-header', template: "<div class=\"str-chat__header-livestream str-chat__channel-header\">\n  <ng-content></ng-content>\n  <stream-avatar-placeholder\n    type=\"channel\"\n    location=\"channel-header\"\n    imageUrl=\"{{ activeChannel?.data?.image }}\"\n    name=\"{{ avatarName }}\"\n    [channel]=\"activeChannel\"\n  ></stream-avatar-placeholder>\n  <div class=\"str-chat__header-livestream-left str-chat__channel-header-end\">\n    <p\n      data-testid=\"name\"\n      class=\"\n        str-chat__header-livestream-left--title str-chat__channel-header-title\n      \"\n    >\n      {{ displayText }}\n    </p>\n    <ng-container\n      *ngTemplateOutlet=\"\n        channelHeaderInfoTemplate || defaultChannelInfo;\n        context: getChannelInfoContext()\n      \"\n    ></ng-container>\n    <ng-template #defaultChannelInfo>\n      <p\n        data-testid=\"info\"\n        class=\"\n          str-chat__header-livestream-left--members\n          str-chat__channel-header-info\n        \"\n      >\n        {{'streamChat.{{ memberCount }} members' | translate:memberCountParam}}\n        {{canReceiveConnectEvents ? ('streamChat.{{ watcherCount }} online' |\n        translate:watcherCountParam) : ''}}\n      </p>\n    </ng-template>\n  </div>\n  <ng-container *ngIf=\"channelActionsTemplate\">\n    <ng-container\n      *ngTemplateOutlet=\"\n        channelActionsTemplate;\n        context: getChannelActionsContext()\n      \"\n    ></ng-container>\n  </ng-container>\n</div>\n" }]
        }], ctorParameters: function () { return [{ type: ChannelService }, { type: CustomTemplatesService }, { type: i0.ChangeDetectorRef }, { type: ChatClientService }]; } });

const isOnSeparateDate = (date1, date2) => {
    if (date1.getDate() !== date2.getDate()) {
        return true;
    }
    else if (date1.getFullYear() !== date2.getFullYear() ||
        date1.getMonth() !== date2.getMonth()) {
        return true;
    }
    return false;
};

/**
 * The message service contains configuration options related to displaying the message content
 */
class MessageService {
    constructor() {
        /**
         * Decides if the message content should be formatted as text or HTML
         *
         * If you display messages as text the following parts are still be displayed as HTML:
         * - user mentions -> you can customize this with your own template using the [`customTemplatesService.mentionTemplate$`](https://getstream.io/chat/docs/sdk/angular/services/CustomTemplatesService/#mentiontemplate)
         * - links -> you can customize this by providing you own [`customLinkRenderer`](#customlinkrenderer) method
         */
        this.displayAs = 'text';
    }
}
MessageService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: MessageService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
MessageService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: MessageService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: MessageService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return []; } });

Dayjs.extend(calendar);
Dayjs.extend(relativeTime);
const parseDate = (date, format = 'date-time') => {
    const parsedTime = Dayjs(date);
    switch (format) {
        case 'date': {
            return parsedTime.calendar(null, {
                sameDay: '[Today]',
                nextDay: '[Tomorrow]',
                nextWeek: 'dddd',
                lastDay: '[Yesterday]',
                lastWeek: '[Last] dddd',
                sameElse: 'MM/DD/YYYY', // Everything else ( 10/17/2011 )
            });
        }
        case 'date-time': {
            return parsedTime.calendar();
        }
        case 'time': {
            return parsedTime.format('h:mm A');
        }
    }
};

/**
 * The `DateParserService` parses dates into user-friendly string representations.
 */
class DateParserService {
    constructor() { }
    /**
     * Return a user-friendly string representation of the time
     * @param date
     * @returns The parsed time
     */
    parseTime(date) {
        if (this.customTimeParser) {
            return this.customTimeParser(date);
        }
        return parseDate(date, 'time');
    }
    /**
     * Return a user-friendly string representation of the date (year, month and date)
     * @param date
     * @returns The parsed date
     */
    parseDate(date) {
        if (this.customDateParser) {
            return this.customDateParser(date);
        }
        return parseDate(date, 'date');
    }
    /**
     * Return a user-friendly string representation of the date and time
     * @param date
     * @returns The parsed date
     */
    parseDateTime(date) {
        if (this.customDateTimeParser) {
            return this.customDateTimeParser(date);
        }
        return parseDate(date, 'date-time');
    }
}
DateParserService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: DateParserService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
DateParserService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: DateParserService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: DateParserService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return []; } });

/**
 * The `ChannelPreview` component displays a channel preview in the channel list, it consists of the image, name and latest message of the channel.
 */
class ChannelPreviewComponent {
    constructor(channelService, ngZone, chatClientService, messageService, customTemplatesService, dateParser) {
        this.channelService = channelService;
        this.ngZone = ngZone;
        this.chatClientService = chatClientService;
        this.customTemplatesService = customTemplatesService;
        this.dateParser = dateParser;
        this.isActive = false;
        this.isUnreadMessageWasCalled = false;
        this.isUnread = false;
        this.latestMessageText = 'streamChat.Nothing yet...';
        this.subscriptions = [];
        this.canSendReadEvents = true;
        this.displayAs = messageService.displayAs;
    }
    ngOnInit() {
        this.subscriptions.push(this.chatClientService.user$.subscribe((user) => {
            if (user?.id !== this.userId) {
                this.userId = user?.id;
            }
        }));
        this.subscriptions.push(this.channelService.activeChannel$.subscribe((activeChannel) => (this.isActive = activeChannel?.id === this.channel?.id)));
        const messages = this.channel?.state?.latestMessages;
        if (messages && messages.length > 0) {
            this.setLatestMessage(messages[messages.length - 1]);
        }
        this.updateUnreadState();
        const capabilities = this.channel?.data?.own_capabilities || [];
        this.canSendReadEvents = capabilities.indexOf('read-events') !== -1;
        this.subscriptions.push(this.channel.on('message.new', this.handleMessageEvent.bind(this)));
        this.subscriptions.push(this.channel.on('message.updated', this.handleMessageEvent.bind(this)));
        this.subscriptions.push(this.channel.on('message.deleted', this.handleMessageEvent.bind(this)));
        this.subscriptions.push(this.channel.on('channel.truncated', this.handleMessageEvent.bind(this)));
        this.subscriptions.push(this.channel.on('message.read', () => this.ngZone.run(() => {
            this.isUnreadMessageWasCalled = false;
            this.updateUnreadState();
        })));
        this.subscriptions.push(this.chatClientService.events$
            .pipe(filter((e) => e.eventType === 'notification.mark_unread' &&
            this.channel.id === e.event?.channel_id))
            .subscribe(() => {
            this.ngZone.run(() => {
                this.isUnreadMessageWasCalled = true;
                this.updateUnreadState();
            });
        }));
    }
    ngOnDestroy() {
        this.subscriptions.forEach((s) => s.unsubscribe());
    }
    get avatarImage() {
        return this.channel?.data?.image;
    }
    get avatarName() {
        return this.channel?.data?.name;
    }
    get title() {
        if (!this.channel) {
            return '';
        }
        return getChannelDisplayText(this.channel, this.chatClientService.chatClient.user);
    }
    setAsActiveChannel() {
        void this.channelService.setAsActiveChannel(this.channel);
    }
    handleMessageEvent(event) {
        this.ngZone.run(() => {
            if (this.channel?.state.latestMessages.length === 0) {
                this.latestMessage = undefined;
                this.latestMessageStatus = undefined;
                this.latestMessageText = 'streamChat.Nothing yet...';
                this.latestMessageTime = undefined;
                return;
            }
            const latestMessage = this.channel?.state.latestMessages[this.channel?.state.latestMessages.length - 1];
            if (!event.message || latestMessage?.id !== event.message.id) {
                return;
            }
            this.setLatestMessage(latestMessage);
            this.updateUnreadState();
        });
    }
    setLatestMessage(message) {
        this.latestMessage = message;
        if (message?.deleted_at) {
            this.latestMessageText = 'streamChat.Message deleted';
        }
        else if (message?.text) {
            this.latestMessageText =
                getMessageTranslation(message, this.channel, this.chatClientService.chatClient.user) || message.text;
        }
        else if (message?.attachments && message.attachments.length) {
            this.latestMessageText = 'streamChat.🏙 Attachment...';
        }
        if (this.latestMessage && this.latestMessage.type === 'regular') {
            this.latestMessageTime = isOnSeparateDate(new Date(), this.latestMessage.created_at)
                ? this.dateParser.parseDate(this.latestMessage.created_at)
                : this.dateParser.parseTime(this.latestMessage.created_at);
        }
        else {
            this.latestMessageTime = undefined;
        }
    }
    updateUnreadState() {
        if (this.channel &&
            this.latestMessage &&
            this.latestMessage.user?.id === this.userId &&
            this.latestMessage.status === 'received' &&
            this.latestMessage.type === 'regular') {
            this.latestMessageStatus =
                getReadBy(this.latestMessage, this.channel).length > 0
                    ? 'read'
                    : 'delivered';
        }
        else {
            this.latestMessageStatus = undefined;
        }
        if ((this.isActive && !this.isUnreadMessageWasCalled) ||
            !this.canSendReadEvents) {
            this.unreadCount = 0;
            this.isUnread = false;
            return;
        }
        this.unreadCount = this.channel.countUnread();
        this.isUnread = !!this.unreadCount;
    }
}
ChannelPreviewComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: ChannelPreviewComponent, deps: [{ token: ChannelService }, { token: i0.NgZone }, { token: ChatClientService }, { token: MessageService }, { token: CustomTemplatesService }, { token: DateParserService }], target: i0.ɵɵFactoryTarget.Component });
ChannelPreviewComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.0.4", type: ChannelPreviewComponent, selector: "stream-channel-preview", inputs: { channel: "channel" }, ngImport: i0, template: "<button\n  class=\"str-chat__channel-preview-messenger str-chat__channel-preview\"\n  data-testid=\"channel-preview-container\"\n  [class.str-chat__channel-preview-messenger--active]=\"isActive\"\n  [class.str-chat__channel-preview--active]=\"isActive\"\n  [class.str-chat__channel-preview-messenger--unread]=\"isUnread\"\n  (click)=\"setAsActiveChannel()\"\n>\n  <div class=\"str-chat__channel-preview-messenger--left\">\n    <stream-avatar-placeholder\n      type=\"channel\"\n      location=\"channel-preview\"\n      name=\"{{ avatarName }}\"\n      imageUrl=\"{{ avatarImage }}\"\n      [channel]=\"channel\"\n    ></stream-avatar-placeholder>\n  </div>\n  <div\n    class=\"\n      str-chat__channel-preview-messenger--right str-chat__channel-preview-end\n    \"\n  >\n    <ng-container\n      *ngTemplateOutlet=\"\n        (customTemplatesService.channelPreviewInfoTemplate$ | async) ||\n          defaultChannelInfo;\n        context: {\n          channelDisplayTitle: title,\n          channel: channel,\n          unreadCount: unreadCount,\n          latestMessageText: latestMessageText,\n          latestMessageStatus: latestMessageStatus,\n          latestMessageTime: latestMessageTime,\n          latestMessage: latestMessage\n        }\n      \"\n    ></ng-container>\n    <ng-template\n      #defaultChannelInfo\n      let-channelDisplayTitle=\"channelDisplayTitle\"\n      let-unreadCount=\"unreadCount\"\n      let-latestMessageText=\"latestMessageText\"\n      let-latestMessageStatus=\"latestMessageStatus\"\n      let-latestMessageTime=\"latestMessageTime\"\n    >\n      <div class=\"str-chat__channel-preview-end-first-row\">\n        <div class=\"str-chat__channel-preview-messenger--name\">\n          <span data-testid=\"channel-preview-title\">{{\n            channelDisplayTitle\n          }}</span>\n        </div>\n        <div\n          *ngIf=\"unreadCount\"\n          data-testid=\"unread-badge\"\n          class=\"str-chat__channel-preview-unread-badge\"\n        >\n          {{ unreadCount }}\n        </div>\n      </div>\n      <div class=\"str-chat__channel-preview-end-second-row\">\n        <div\n          data-testid=\"latest-message\"\n          class=\"str-chat__channel-preview-messenger--last-message\"\n        >\n          <ng-container *ngIf=\"displayAs === 'text'; else asHTML\">\n            {{ latestMessageText | translate }}\n          </ng-container>\n          <ng-template #asHTML>\n            <span\n              data-testid=\"html-content\"\n              [innerHTML]=\"latestMessageText | translate\"\n            ></span>\n          </ng-template>\n        </div>\n        <div\n          *ngIf=\"latestMessageStatus\"\n          data-testid=\"latest-message-status\"\n          class=\"str-chat__channel-preview-messenger--status str-chat__channel-preview-messenger--status-{{\n            latestMessageStatus\n          }}\"\n        >\n          <stream-icon-placeholder\n            [icon]=\"latestMessageStatus === 'delivered' ? 'delivered' : 'read'\"\n          ></stream-icon-placeholder>\n        </div>\n        <div\n          *ngIf=\"latestMessageTime\"\n          data-testid=\"latest-message-time\"\n          class=\"str-chat__channel-preview-messenger--time\"\n        >\n          {{ latestMessageTime }}\n        </div>\n      </div>\n    </ng-template>\n  </div>\n</button>\n", dependencies: [{ kind: "directive", type: i4.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i4.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "component", type: AvatarPlaceholderComponent, selector: "stream-avatar-placeholder", inputs: ["name", "imageUrl", "location", "channel", "user", "type", "initialsType", "showOnlineIndicator"] }, { kind: "component", type: IconPlaceholderComponent, selector: "stream-icon-placeholder", inputs: ["icon"] }, { kind: "pipe", type: i4.AsyncPipe, name: "async" }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: ChannelPreviewComponent, decorators: [{
            type: Component,
            args: [{ selector: 'stream-channel-preview', template: "<button\n  class=\"str-chat__channel-preview-messenger str-chat__channel-preview\"\n  data-testid=\"channel-preview-container\"\n  [class.str-chat__channel-preview-messenger--active]=\"isActive\"\n  [class.str-chat__channel-preview--active]=\"isActive\"\n  [class.str-chat__channel-preview-messenger--unread]=\"isUnread\"\n  (click)=\"setAsActiveChannel()\"\n>\n  <div class=\"str-chat__channel-preview-messenger--left\">\n    <stream-avatar-placeholder\n      type=\"channel\"\n      location=\"channel-preview\"\n      name=\"{{ avatarName }}\"\n      imageUrl=\"{{ avatarImage }}\"\n      [channel]=\"channel\"\n    ></stream-avatar-placeholder>\n  </div>\n  <div\n    class=\"\n      str-chat__channel-preview-messenger--right str-chat__channel-preview-end\n    \"\n  >\n    <ng-container\n      *ngTemplateOutlet=\"\n        (customTemplatesService.channelPreviewInfoTemplate$ | async) ||\n          defaultChannelInfo;\n        context: {\n          channelDisplayTitle: title,\n          channel: channel,\n          unreadCount: unreadCount,\n          latestMessageText: latestMessageText,\n          latestMessageStatus: latestMessageStatus,\n          latestMessageTime: latestMessageTime,\n          latestMessage: latestMessage\n        }\n      \"\n    ></ng-container>\n    <ng-template\n      #defaultChannelInfo\n      let-channelDisplayTitle=\"channelDisplayTitle\"\n      let-unreadCount=\"unreadCount\"\n      let-latestMessageText=\"latestMessageText\"\n      let-latestMessageStatus=\"latestMessageStatus\"\n      let-latestMessageTime=\"latestMessageTime\"\n    >\n      <div class=\"str-chat__channel-preview-end-first-row\">\n        <div class=\"str-chat__channel-preview-messenger--name\">\n          <span data-testid=\"channel-preview-title\">{{\n            channelDisplayTitle\n          }}</span>\n        </div>\n        <div\n          *ngIf=\"unreadCount\"\n          data-testid=\"unread-badge\"\n          class=\"str-chat__channel-preview-unread-badge\"\n        >\n          {{ unreadCount }}\n        </div>\n      </div>\n      <div class=\"str-chat__channel-preview-end-second-row\">\n        <div\n          data-testid=\"latest-message\"\n          class=\"str-chat__channel-preview-messenger--last-message\"\n        >\n          <ng-container *ngIf=\"displayAs === 'text'; else asHTML\">\n            {{ latestMessageText | translate }}\n          </ng-container>\n          <ng-template #asHTML>\n            <span\n              data-testid=\"html-content\"\n              [innerHTML]=\"latestMessageText | translate\"\n            ></span>\n          </ng-template>\n        </div>\n        <div\n          *ngIf=\"latestMessageStatus\"\n          data-testid=\"latest-message-status\"\n          class=\"str-chat__channel-preview-messenger--status str-chat__channel-preview-messenger--status-{{\n            latestMessageStatus\n          }}\"\n        >\n          <stream-icon-placeholder\n            [icon]=\"latestMessageStatus === 'delivered' ? 'delivered' : 'read'\"\n          ></stream-icon-placeholder>\n        </div>\n        <div\n          *ngIf=\"latestMessageTime\"\n          data-testid=\"latest-message-time\"\n          class=\"str-chat__channel-preview-messenger--time\"\n        >\n          {{ latestMessageTime }}\n        </div>\n      </div>\n    </ng-template>\n  </div>\n</button>\n" }]
        }], ctorParameters: function () { return [{ type: ChannelService }, { type: i0.NgZone }, { type: ChatClientService }, { type: MessageService }, { type: CustomTemplatesService }, { type: DateParserService }]; }, propDecorators: { channel: [{
                type: Input
            }] } });

/**
 * The `ChannelList` component renders the list of channels.
 */
class ChannelListComponent {
    constructor(channelService, customTemplatesService, themeService) {
        this.channelService = channelService;
        this.customTemplatesService = customTemplatesService;
        this.themeService = themeService;
        this.isLoadingMoreChannels = false;
        this.subscriptions = [];
        this.theme$ = this.themeService.theme$;
        this.channels$ = this.channelService.channels$;
        this.hasMoreChannels$ = this.channelService.hasMoreChannels$;
        this.isError$ = this.channelService.channelQueryState$.pipe(map((s) => !this.isLoadingMoreChannels && s?.state === 'error'));
        this.isInitializing$ = this.channelService.channelQueryState$.pipe(map((s) => !this.isLoadingMoreChannels && s?.state === 'in-progress'));
        this.subscriptions.push(this.customTemplatesService.channelPreviewTemplate$.subscribe((template) => (this.customChannelPreviewTemplate = template)));
    }
    ngOnDestroy() {
        this.subscriptions.forEach((s) => s.unsubscribe());
    }
    async loadMoreChannels() {
        this.isLoadingMoreChannels = true;
        await this.channelService.loadMoreChannels();
        this.isLoadingMoreChannels = false;
    }
    trackByChannelId(index, item) {
        return item.cid;
    }
}
ChannelListComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: ChannelListComponent, deps: [{ token: ChannelService }, { token: CustomTemplatesService }, { token: ThemeService }], target: i0.ɵɵFactoryTarget.Component });
ChannelListComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.0.4", type: ChannelListComponent, selector: "stream-channel-list", viewQueries: [{ propertyName: "container", first: true, predicate: ["container"], descendants: true }], ngImport: i0, template: "<div\n  #container\n  data-testid=\"channel-list-container\"\n  class=\"str-chat str-chat__channel-list str-chat-channel-list messaging str-chat__theme-{{\n    theme$ | async\n  }}\"\n>\n  <div\n    *ngIf=\"\n      (isError$ | async) === false && (isInitializing$ | async) === false;\n      else statusIndicator\n    \"\n    class=\"str-chat__channel-list-messenger\"\n  >\n    <div class=\"str-chat__channel-list-messenger__main\">\n      <ng-content select=\"[channel-list-top]\"></ng-content>\n      <div\n        *ngIf=\"!(channels$ | async)?.length\"\n        class=\"str-chat__channel-list-empty\"\n      >\n        <stream-icon icon=\"chat-bubble\"></stream-icon>\n        <p data-testid=\"empty-channel-list-indicator\">\n          {{ \"streamChat.You have no channels currently\" | translate }}\n        </p>\n      </div>\n      <p\n        *ngIf=\"!(channels$ | async)?.length\"\n        class=\"str-chat__channel-list-empty-v1\"\n        data-testid=\"empty-channel-list-indicator\"\n      >\n        {{ \"streamChat.You have no channels currently\" | translate }}\n      </p>\n      <ng-container\n        *ngFor=\"let channel of channels$ | async; trackBy: trackByChannelId\"\n      >\n        <ng-template #defaultTemplate let-channelInput=\"channel\">\n          <stream-channel-preview\n            data-testclass=\"channel-preview\"\n            [channel]=\"channelInput\"\n          ></stream-channel-preview>\n        </ng-template>\n        <div>\n          <ng-container\n            *ngTemplateOutlet=\"\n              customChannelPreviewTemplate || defaultTemplate;\n              context: { channel: channel }\n            \"\n          ></ng-container>\n        </div>\n      </ng-container>\n      <div\n        *ngIf=\"hasMoreChannels$ | async\"\n        class=\"str-chat__load-more-button\"\n        data-testid=\"load-more\"\n        (click)=\"loadMoreChannels()\"\n        (keyup.enter)=\"loadMoreChannels()\"\n      >\n        <button\n          class=\"str-chat__load-more-button__button str-chat__cta-button\"\n          data-testid=\"load-more-button\"\n          [disabled]=\"isLoadingMoreChannels\"\n        >\n          <span *ngIf=\"!isLoadingMoreChannels; else loadingIndicator\">{{\n            \"Load more\" | translate\n          }}</span>\n          <ng-template #loadingIndicator\n            ><stream-loading-indicator-placeholder></stream-loading-indicator-placeholder\n          ></ng-template>\n        </button>\n      </div>\n      <ng-content select=\"[channel-list-bottom]\"></ng-content>\n    </div>\n  </div>\n</div>\n\n<ng-template #statusIndicator>\n  <ng-container *ngIf=\"isError$ | async\">\n    <ng-container *ngTemplateOutlet=\"chatDown\"></ng-container>\n  </ng-container>\n  <ng-container *ngIf=\"isInitializing$ | async\">\n    <ng-container *ngTemplateOutlet=\"loadingChannels\"></ng-container>\n  </ng-container>\n</ng-template>\n\n<ng-template #chatDown>\n  <div data-testid=\"chatdown-container\" class=\"str-chat__down\">\n    <ng-container *ngTemplateOutlet=\"loadingChannels\"></ng-container>\n  </div>\n</ng-template>\n\n<ng-template #loadingChannels>\n  <div data-testid=\"loading-indicator\" class=\"str-chat__loading-channels\">\n    <ng-container *ngTemplateOutlet=\"loadingChannel\"></ng-container>\n    <ng-container *ngTemplateOutlet=\"loadingChannel\"></ng-container>\n    <ng-container *ngTemplateOutlet=\"loadingChannel\"></ng-container>\n  </div>\n</ng-template>\n\n<ng-template #loadingChannel>\n  <div\n    class=\"str-chat__loading-channels-item str-chat__channel-preview-loading\"\n  >\n    <div class=\"str-chat__loading-channels-avatar\"></div>\n    <div\n      class=\"\n        str-chat__loading-channels-meta str-chat__channel-preview-end-loading\n      \"\n    >\n      <div class=\"str-chat__loading-channels-username\"></div>\n      <div class=\"str-chat__loading-channels-status\"></div>\n    </div>\n  </div>\n</ng-template>\n", dependencies: [{ kind: "directive", type: i4.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i4.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i4.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "component", type: ChannelPreviewComponent, selector: "stream-channel-preview", inputs: ["channel"] }, { kind: "component", type: IconComponent, selector: "stream-icon", inputs: ["icon"] }, { kind: "component", type: LoadingIndicatorPlaceholderComponent, selector: "stream-loading-indicator-placeholder" }, { kind: "pipe", type: i4.AsyncPipe, name: "async" }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: ChannelListComponent, decorators: [{
            type: Component,
            args: [{ selector: 'stream-channel-list', template: "<div\n  #container\n  data-testid=\"channel-list-container\"\n  class=\"str-chat str-chat__channel-list str-chat-channel-list messaging str-chat__theme-{{\n    theme$ | async\n  }}\"\n>\n  <div\n    *ngIf=\"\n      (isError$ | async) === false && (isInitializing$ | async) === false;\n      else statusIndicator\n    \"\n    class=\"str-chat__channel-list-messenger\"\n  >\n    <div class=\"str-chat__channel-list-messenger__main\">\n      <ng-content select=\"[channel-list-top]\"></ng-content>\n      <div\n        *ngIf=\"!(channels$ | async)?.length\"\n        class=\"str-chat__channel-list-empty\"\n      >\n        <stream-icon icon=\"chat-bubble\"></stream-icon>\n        <p data-testid=\"empty-channel-list-indicator\">\n          {{ \"streamChat.You have no channels currently\" | translate }}\n        </p>\n      </div>\n      <p\n        *ngIf=\"!(channels$ | async)?.length\"\n        class=\"str-chat__channel-list-empty-v1\"\n        data-testid=\"empty-channel-list-indicator\"\n      >\n        {{ \"streamChat.You have no channels currently\" | translate }}\n      </p>\n      <ng-container\n        *ngFor=\"let channel of channels$ | async; trackBy: trackByChannelId\"\n      >\n        <ng-template #defaultTemplate let-channelInput=\"channel\">\n          <stream-channel-preview\n            data-testclass=\"channel-preview\"\n            [channel]=\"channelInput\"\n          ></stream-channel-preview>\n        </ng-template>\n        <div>\n          <ng-container\n            *ngTemplateOutlet=\"\n              customChannelPreviewTemplate || defaultTemplate;\n              context: { channel: channel }\n            \"\n          ></ng-container>\n        </div>\n      </ng-container>\n      <div\n        *ngIf=\"hasMoreChannels$ | async\"\n        class=\"str-chat__load-more-button\"\n        data-testid=\"load-more\"\n        (click)=\"loadMoreChannels()\"\n        (keyup.enter)=\"loadMoreChannels()\"\n      >\n        <button\n          class=\"str-chat__load-more-button__button str-chat__cta-button\"\n          data-testid=\"load-more-button\"\n          [disabled]=\"isLoadingMoreChannels\"\n        >\n          <span *ngIf=\"!isLoadingMoreChannels; else loadingIndicator\">{{\n            \"Load more\" | translate\n          }}</span>\n          <ng-template #loadingIndicator\n            ><stream-loading-indicator-placeholder></stream-loading-indicator-placeholder\n          ></ng-template>\n        </button>\n      </div>\n      <ng-content select=\"[channel-list-bottom]\"></ng-content>\n    </div>\n  </div>\n</div>\n\n<ng-template #statusIndicator>\n  <ng-container *ngIf=\"isError$ | async\">\n    <ng-container *ngTemplateOutlet=\"chatDown\"></ng-container>\n  </ng-container>\n  <ng-container *ngIf=\"isInitializing$ | async\">\n    <ng-container *ngTemplateOutlet=\"loadingChannels\"></ng-container>\n  </ng-container>\n</ng-template>\n\n<ng-template #chatDown>\n  <div data-testid=\"chatdown-container\" class=\"str-chat__down\">\n    <ng-container *ngTemplateOutlet=\"loadingChannels\"></ng-container>\n  </div>\n</ng-template>\n\n<ng-template #loadingChannels>\n  <div data-testid=\"loading-indicator\" class=\"str-chat__loading-channels\">\n    <ng-container *ngTemplateOutlet=\"loadingChannel\"></ng-container>\n    <ng-container *ngTemplateOutlet=\"loadingChannel\"></ng-container>\n    <ng-container *ngTemplateOutlet=\"loadingChannel\"></ng-container>\n  </div>\n</ng-template>\n\n<ng-template #loadingChannel>\n  <div\n    class=\"str-chat__loading-channels-item str-chat__channel-preview-loading\"\n  >\n    <div class=\"str-chat__loading-channels-avatar\"></div>\n    <div\n      class=\"\n        str-chat__loading-channels-meta str-chat__channel-preview-end-loading\n      \"\n    >\n      <div class=\"str-chat__loading-channels-username\"></div>\n      <div class=\"str-chat__loading-channels-status\"></div>\n    </div>\n  </div>\n</ng-template>\n" }]
        }], ctorParameters: function () { return [{ type: ChannelService }, { type: CustomTemplatesService }, { type: ThemeService }]; }, propDecorators: { container: [{
                type: ViewChild,
                args: ['container']
            }] } });

/**
 * This component can be used to visualize the wave bar of a voice recording
 */
class VoiceRecordingWavebarComponent {
    constructor(ngZone, cdRef) {
        this.ngZone = ngZone;
        this.cdRef = cdRef;
        /**
         * The waveform data to visualize
         */
        this.waveFormData = [];
        this.resampledWaveFormData = [];
        this.progress = 0;
        this.isDragging = false;
        this.sampleSize = 40;
        this.isViewInited = false;
        this.upsample = () => {
            if (this.sampleSize === this.waveFormData.length)
                return this.waveFormData;
            // eslint-disable-next-line  prefer-const
            let [bucketSize, remainder] = this.divMod(this.sampleSize, this.waveFormData.length);
            const result = [];
            for (let i = 0; i < this.waveFormData.length; i++) {
                const extra = remainder && remainder-- ? 1 : 0;
                result.push(...Array(bucketSize + extra).fill(this.waveFormData[i]));
            }
            return result;
        };
        this.getNextBucketMean = (data, currentBucketIndex, bucketSize) => {
            const nextBucketStartIndex = Math.floor(currentBucketIndex * bucketSize) + 1;
            let nextNextBucketStartIndex = Math.floor((currentBucketIndex + 1) * bucketSize) + 1;
            nextNextBucketStartIndex =
                nextNextBucketStartIndex < data.length
                    ? nextNextBucketStartIndex
                    : data.length;
            return this.mean(data.slice(nextBucketStartIndex, nextNextBucketStartIndex));
        };
        this.mean = (values) => values.reduce((acc, value) => acc + value, 0) / values.length;
        this.triangleAreaHeron = (a, b, c) => {
            const s = (a + b + c) / 2;
            return Math.sqrt(s * (s - a) * (s - b) * (s - c));
        };
        this.triangleBase = (a, b) => Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));
        this.divMod = (num, divisor) => {
            return [Math.floor(num / divisor), num % divisor];
        };
    }
    ngOnInit() {
        this.containerSizeChanged();
        if (this.container?.nativeElement) {
            this.ngZone.runOutsideAngular(() => {
                new ResizeObserver(() => {
                    this.containerSizeChanged();
                }).observe(this.container.nativeElement);
            });
        }
    }
    ngOnChanges(changes) {
        if (changes.waveFormData) {
            this.resampledWaveFormData =
                this.waveFormData.length > this.sampleSize
                    ? this.downsample()
                    : this.upsample();
        }
        if (changes.audioElement) {
            this.ngZone.runOutsideAngular(() => {
                this.audioElement?.addEventListener('timeupdate', () => {
                    const progress = (this.audioElement?.currentTime || 0) / (this.duration || 0) || 0;
                    if (Math.abs(progress - this.progress) >= 0.02) {
                        this.ngZone.run(() => {
                            this.progress = progress;
                            this.cdRef.detectChanges();
                        });
                    }
                });
            });
        }
    }
    ngAfterViewInit() {
        this.isViewInited = true;
    }
    seek(event) {
        const containerWidth = this.container?.nativeElement?.getBoundingClientRect().width || 0;
        const containerStart = this.container?.nativeElement?.getBoundingClientRect()?.x || 0;
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        const progress = (event.x - containerStart) / containerWidth;
        if (!isNaN(progress) && this.audioElement) {
            const duration = this.duration || 0;
            const time = duration * progress;
            this.audioElement.currentTime = time;
        }
    }
    trackByIndex(index) {
        return index;
    }
    containerSizeChanged() {
        if (!this.container?.nativeElement) {
            return;
        }
        const containerWidth = this.container.nativeElement.clientWidth;
        if (containerWidth === 0) {
            return;
        }
        const barWidth = +getComputedStyle(this.container.nativeElement)
            .getPropertyValue('--str-chat__voice-recording-amplitude-bar-width')
            .replace('px', '');
        const barGap = +getComputedStyle(this.container.nativeElement)
            .getPropertyValue('--str-chat__voice-recording-amplitude-bar-gap-width')
            .replace('px', '');
        if (!isNaN(barWidth) && !isNaN(barGap)) {
            const sampleSize = Math.floor(containerWidth / (barWidth + barGap));
            if (sampleSize !== this.sampleSize &&
                !isNaN(sampleSize) &&
                sampleSize !== Infinity) {
                this.ngZone.run(() => {
                    this.sampleSize = sampleSize;
                    this.resampledWaveFormData =
                        this.waveFormData.length > this.sampleSize
                            ? this.downsample()
                            : this.upsample();
                    if (this.isViewInited) {
                        this.cdRef.detectChanges();
                    }
                });
            }
        }
    }
    downsample() {
        if (this.waveFormData.length <= this.sampleSize) {
            return this.waveFormData;
        }
        if (this.sampleSize === 1)
            return [this.mean(this.waveFormData)];
        const result = [];
        // bucket size adjusted due to the fact that the first and the last item in the original data array is kept in target output
        const bucketSize = (this.waveFormData.length - 2) / (this.sampleSize - 2);
        let lastSelectedPointIndex = 0;
        result.push(this.waveFormData[lastSelectedPointIndex]); // Always add the first point
        let maxAreaPoint, maxArea, triangleArea;
        for (let bucketIndex = 1; bucketIndex < this.sampleSize - 1; bucketIndex++) {
            const previousBucketRefPoint = this.waveFormData[lastSelectedPointIndex];
            const nextBucketMean = this.getNextBucketMean(this.waveFormData, bucketIndex, bucketSize);
            const currentBucketStartIndex = Math.floor((bucketIndex - 1) * bucketSize) + 1;
            const nextBucketStartIndex = Math.floor(bucketIndex * bucketSize) + 1;
            const countUnitsBetweenAtoC = 1 + nextBucketStartIndex - currentBucketStartIndex;
            maxArea = triangleArea = -1;
            for (let currentPointIndex = currentBucketStartIndex; currentPointIndex < nextBucketStartIndex; currentPointIndex++) {
                const countUnitsBetweenAtoB = Math.abs(currentPointIndex - currentBucketStartIndex) + 1;
                const countUnitsBetweenBtoC = countUnitsBetweenAtoC - countUnitsBetweenAtoB;
                const currentPointValue = this.waveFormData[currentPointIndex];
                triangleArea = this.triangleAreaHeron(this.triangleBase(Math.abs(previousBucketRefPoint - currentPointValue), countUnitsBetweenAtoB), this.triangleBase(Math.abs(currentPointValue - nextBucketMean), countUnitsBetweenBtoC), this.triangleBase(Math.abs(previousBucketRefPoint - nextBucketMean), countUnitsBetweenAtoC));
                if (triangleArea > maxArea) {
                    maxArea = triangleArea;
                    maxAreaPoint = this.waveFormData[currentPointIndex];
                    lastSelectedPointIndex = currentPointIndex;
                }
            }
            if (typeof maxAreaPoint !== 'undefined')
                result.push(maxAreaPoint);
        }
        result.push(this.waveFormData[this.waveFormData.length - 1]); // Always add the last point
        return result;
    }
}
VoiceRecordingWavebarComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: VoiceRecordingWavebarComponent, deps: [{ token: i0.NgZone }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
VoiceRecordingWavebarComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.0.4", type: VoiceRecordingWavebarComponent, selector: "stream-voice-recording-wavebar", inputs: { audioElement: "audioElement", waveFormData: "waveFormData", duration: "duration" }, viewQueries: [{ propertyName: "container", first: true, predicate: ["container"], descendants: true, static: true }], usesOnChanges: true, ngImport: i0, template: "<!--eslint-disable @angular-eslint/template/click-events-have-key-events-->\n<div\n  #container\n  class=\"str-chat__wave-progress-bar__track\"\n  data-testid=\"wave-progress-bar-track\"\n  role=\"progressbar\"\n  (mousedown)=\"isDragging = true\"\n  (mouseup)=\"isDragging = false\"\n  (mouseleave)=\"isDragging = false\"\n  (mousemove)=\"isDragging ? seek($event) : null\"\n  (click)=\"seek($event)\"\n>\n  <!--eslint-enable @angular-eslint/template/click-events-have-key-events-->\n  <div\n    *ngFor=\"\n      let dataPoint of resampledWaveFormData;\n      let i = index;\n      trackBy: trackByIndex\n    \"\n    class=\"str-chat__wave-progress-bar__amplitude-bar\"\n    [class.str-chat__wave-progress-bar__amplitude-bar--active]=\"\n      progress > i / resampledWaveFormData.length\n    \"\n    [style.--str-chat__wave-progress-bar__amplitude-bar-height]=\"\n      dataPoint ? dataPoint * 100 + '%' : '0%'\n    \"\n  ></div>\n  <div\n    class=\"str-chat__wave-progress-bar__progress-indicator\"\n    data-testid=\"wave-progress-bar-progress-indicator\"\n    [ngStyle]=\"{ 'inset-inline-start': progress * 100 + '%' }\"\n  ></div>\n</div>\n", dependencies: [{ kind: "directive", type: i4.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i4.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: VoiceRecordingWavebarComponent, decorators: [{
            type: Component,
            args: [{ selector: 'stream-voice-recording-wavebar', template: "<!--eslint-disable @angular-eslint/template/click-events-have-key-events-->\n<div\n  #container\n  class=\"str-chat__wave-progress-bar__track\"\n  data-testid=\"wave-progress-bar-track\"\n  role=\"progressbar\"\n  (mousedown)=\"isDragging = true\"\n  (mouseup)=\"isDragging = false\"\n  (mouseleave)=\"isDragging = false\"\n  (mousemove)=\"isDragging ? seek($event) : null\"\n  (click)=\"seek($event)\"\n>\n  <!--eslint-enable @angular-eslint/template/click-events-have-key-events-->\n  <div\n    *ngFor=\"\n      let dataPoint of resampledWaveFormData;\n      let i = index;\n      trackBy: trackByIndex\n    \"\n    class=\"str-chat__wave-progress-bar__amplitude-bar\"\n    [class.str-chat__wave-progress-bar__amplitude-bar--active]=\"\n      progress > i / resampledWaveFormData.length\n    \"\n    [style.--str-chat__wave-progress-bar__amplitude-bar-height]=\"\n      dataPoint ? dataPoint * 100 + '%' : '0%'\n    \"\n  ></div>\n  <div\n    class=\"str-chat__wave-progress-bar__progress-indicator\"\n    data-testid=\"wave-progress-bar-progress-indicator\"\n    [ngStyle]=\"{ 'inset-inline-start': progress * 100 + '%' }\"\n  ></div>\n</div>\n" }]
        }], ctorParameters: function () { return [{ type: i0.NgZone }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { audioElement: [{
                type: Input
            }], waveFormData: [{
                type: Input
            }], duration: [{
                type: Input
            }], container: [{
                type: ViewChild,
                args: ['container', { static: true }]
            }] } });

/**
 * This component can be used to display an attachment with type `voiceRecording`. The component allows playing the attachment inside the browser.
 */
class VoiceRecordingComponent {
    constructor(ngZone, cdRef) {
        this.ngZone = ngZone;
        this.cdRef = cdRef;
        this.fileSize = '';
        this.durationFormatted = '';
        this.secondsElapsed = 0;
        this.isError = false;
        this.secondsElapsedFormatted = this.getFormattedDuration(this.secondsElapsed);
    }
    ngOnChanges(changes) {
        if (changes.attachment) {
            this.fileSize = this.getFileSize();
            this.durationFormatted = this.getFormattedDuration(this.attachment?.duration);
        }
    }
    ngAfterViewInit() {
        // timeupdate fired frequntly so we optimize change detections
        this.ngZone.runOutsideAngular(() => {
            this.audioElement?.nativeElement.addEventListener('timeupdate', () => {
                const secondsElapsed = this.audioElement?.nativeElement?.ended
                    ? this.attachment?.duration || 0
                    : Math.round(this.audioElement?.nativeElement?.currentTime || 0);
                if (this.secondsElapsed !== secondsElapsed) {
                    this.ngZone.run(() => {
                        this.secondsElapsed = secondsElapsed;
                        this.secondsElapsedFormatted = this.getFormattedDuration(this.secondsElapsed);
                        this.cdRef.detectChanges();
                    });
                }
            });
        });
    }
    async togglePlay() {
        if (!this.audioElement || !this.attachment?.asset_url) {
            return;
        }
        try {
            this.audioElement?.nativeElement.paused
                ? await this.audioElement.nativeElement.play()
                : this.audioElement.nativeElement.pause();
            this.isError = false;
        }
        catch (e) {
            this.isError = true;
        }
    }
    setPlaybackRate() {
        if (!this.audioElement?.nativeElement) {
            return;
        }
        let playbackRate = this.audioElement?.nativeElement?.playbackRate + 0.5;
        if (playbackRate > 2) {
            playbackRate = 1;
        }
        this.audioElement.nativeElement.playbackRate = playbackRate;
    }
    getFormattedDuration(duration) {
        if (duration === undefined || duration <= 0)
            return '00:00';
        const [hours, hoursLeftover] = this.divMod(duration, 3600);
        const [minutes, seconds] = this.divMod(hoursLeftover, 60);
        const roundedSeconds = Math.ceil(seconds);
        const prependHrsZero = hours.toString().length === 1 ? '0' : '';
        const prependMinZero = minutes.toString().length === 1 ? '0' : '';
        const prependSecZero = roundedSeconds.toString().length === 1 ? '0' : '';
        const minSec = `${prependMinZero}${minutes}:${prependSecZero}${roundedSeconds}`;
        return hours ? `${prependHrsZero}${hours}:` + minSec : minSec;
    }
    getFileSize() {
        if (this.attachment?.file_size === undefined ||
            this.attachment?.file_size === null) {
            return '';
        }
        return prettybytes(Number(this.attachment.file_size || 0));
    }
    divMod(num, divisor) {
        return [Math.floor(num / divisor), num % divisor];
    }
}
VoiceRecordingComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: VoiceRecordingComponent, deps: [{ token: i0.NgZone }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
VoiceRecordingComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.0.4", type: VoiceRecordingComponent, selector: "stream-voice-recording", inputs: { attachment: "attachment" }, viewQueries: [{ propertyName: "audioElement", first: true, predicate: ["audioElement"], descendants: true }], usesOnChanges: true, ngImport: i0, template: "<div\n  class=\"str-chat__message-attachment__voice-recording-widget\"\n  data-testid=\"voice-recording-widget\"\n  [class.str-chat__message-attachment__voice-recording-widget--error]=\"isError\"\n>\n  <!-- Empty event handlers to trigger change detection -->\n  <audio\n    #audioElement\n    (play)=\"(null)\"\n    (pause)=\"(null)\"\n    (ended)=\"(null)\"\n    (error)=\"isError = true\"\n    (abort)=\"isError = true\"\n  >\n    <source\n      data-testid=\"audio-source\"\n      [src]=\"attachment?.asset_url\"\n      [type]=\"attachment?.mime_type\"\n    />\n  </audio>\n  <button\n    class=\"str-chat__message-attachment-audio-widget--play-button\"\n    data-testid=\"play-button\"\n    (click)=\"togglePlay()\"\n  >\n    <stream-icon-placeholder\n      [icon]=\"audioElement?.paused ? 'play' : 'pause'\"\n    ></stream-icon-placeholder>\n  </button>\n  <div class=\"str-chat__message-attachment__voice-recording-widget__metadata\">\n    <div class=\"str-chat__message-attachment-voice-recording-widget--first-row\">\n      <div\n        class=\"str-chat__message-attachment__voice-recording-widget__title\"\n        data-testid=\"voice-recording-title\"\n        [title]=\"attachment?.title\"\n      >\n        {{ attachment?.title }}\n      </div>\n    </div>\n\n    <ng-container *ngIf=\"isError; else state\">\n      <div\n        class=\"\n          str-chat__message-attachment__voice-recording-widget__error-message\n        \"\n      >\n        <stream-icon-placeholder icon=\"error\"></stream-icon-placeholder>\n        <span data-testid=\"error-message\">{{\n          \"streamChat.Error playing audio\" | translate\n        }}</span>\n      </div>\n    </ng-container>\n    <ng-template #state>\n      <div\n        class=\"\n          str-chat__message-attachment__voice-recording-widget__audio-state\n        \"\n      >\n        <div\n          class=\"str-chat__message-attachment__voice-recording-widget__timer\"\n        >\n          <span\n            *ngIf=\"!!attachment?.duration; else fileSizeTemplate\"\n            data-testid=\"duration\"\n          >\n            {{\n              secondsElapsed > 0 || !audioElement.paused\n                ? secondsElapsedFormatted\n                : durationFormatted\n            }}</span\n          >\n          <ng-template #fileSizeTemplate>\n            <span\n              class=\"str-chat__message-attachment-file--item-size\"\n              data-testid=\"file-size-indicator\"\n            >\n              {{ fileSize }}\n            </span>\n          </ng-template>\n        </div>\n        <stream-voice-recording-wavebar\n          *ngIf=\"attachment?.waveform_data && attachment?.duration\"\n          [waveFormData]=\"attachment?.waveform_data || []\"\n          [duration]=\"attachment?.duration\"\n          [audioElement]=\"audioElement\"\n        ></stream-voice-recording-wavebar>\n      </div>\n    </ng-template>\n  </div>\n  <div\n    class=\"str-chat__message-attachment__voice-recording-widget__right-section\"\n  >\n    <button\n      *ngIf=\"!audioElement?.paused; else fileIcon\"\n      class=\"str-chat__message_attachment__playback-rate-button\"\n      data-testid=\"playback-rate-button\"\n      (click)=\"setPlaybackRate()\"\n    >\n      {{ audioElement?.playbackRate | number: \"1.1-1\" }}x\n    </button>\n    <ng-template #fileIcon>\n      <stream-icon-placeholder\n        class=\"str-chat__attachment-type-icon\"\n        icon=\"audio-file\"\n      ></stream-icon-placeholder>\n    </ng-template>\n  </div>\n</div>\n", dependencies: [{ kind: "directive", type: i4.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: IconPlaceholderComponent, selector: "stream-icon-placeholder", inputs: ["icon"] }, { kind: "component", type: VoiceRecordingWavebarComponent, selector: "stream-voice-recording-wavebar", inputs: ["audioElement", "waveFormData", "duration"] }, { kind: "pipe", type: i4.DecimalPipe, name: "number" }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: VoiceRecordingComponent, decorators: [{
            type: Component,
            args: [{ selector: 'stream-voice-recording', template: "<div\n  class=\"str-chat__message-attachment__voice-recording-widget\"\n  data-testid=\"voice-recording-widget\"\n  [class.str-chat__message-attachment__voice-recording-widget--error]=\"isError\"\n>\n  <!-- Empty event handlers to trigger change detection -->\n  <audio\n    #audioElement\n    (play)=\"(null)\"\n    (pause)=\"(null)\"\n    (ended)=\"(null)\"\n    (error)=\"isError = true\"\n    (abort)=\"isError = true\"\n  >\n    <source\n      data-testid=\"audio-source\"\n      [src]=\"attachment?.asset_url\"\n      [type]=\"attachment?.mime_type\"\n    />\n  </audio>\n  <button\n    class=\"str-chat__message-attachment-audio-widget--play-button\"\n    data-testid=\"play-button\"\n    (click)=\"togglePlay()\"\n  >\n    <stream-icon-placeholder\n      [icon]=\"audioElement?.paused ? 'play' : 'pause'\"\n    ></stream-icon-placeholder>\n  </button>\n  <div class=\"str-chat__message-attachment__voice-recording-widget__metadata\">\n    <div class=\"str-chat__message-attachment-voice-recording-widget--first-row\">\n      <div\n        class=\"str-chat__message-attachment__voice-recording-widget__title\"\n        data-testid=\"voice-recording-title\"\n        [title]=\"attachment?.title\"\n      >\n        {{ attachment?.title }}\n      </div>\n    </div>\n\n    <ng-container *ngIf=\"isError; else state\">\n      <div\n        class=\"\n          str-chat__message-attachment__voice-recording-widget__error-message\n        \"\n      >\n        <stream-icon-placeholder icon=\"error\"></stream-icon-placeholder>\n        <span data-testid=\"error-message\">{{\n          \"streamChat.Error playing audio\" | translate\n        }}</span>\n      </div>\n    </ng-container>\n    <ng-template #state>\n      <div\n        class=\"\n          str-chat__message-attachment__voice-recording-widget__audio-state\n        \"\n      >\n        <div\n          class=\"str-chat__message-attachment__voice-recording-widget__timer\"\n        >\n          <span\n            *ngIf=\"!!attachment?.duration; else fileSizeTemplate\"\n            data-testid=\"duration\"\n          >\n            {{\n              secondsElapsed > 0 || !audioElement.paused\n                ? secondsElapsedFormatted\n                : durationFormatted\n            }}</span\n          >\n          <ng-template #fileSizeTemplate>\n            <span\n              class=\"str-chat__message-attachment-file--item-size\"\n              data-testid=\"file-size-indicator\"\n            >\n              {{ fileSize }}\n            </span>\n          </ng-template>\n        </div>\n        <stream-voice-recording-wavebar\n          *ngIf=\"attachment?.waveform_data && attachment?.duration\"\n          [waveFormData]=\"attachment?.waveform_data || []\"\n          [duration]=\"attachment?.duration\"\n          [audioElement]=\"audioElement\"\n        ></stream-voice-recording-wavebar>\n      </div>\n    </ng-template>\n  </div>\n  <div\n    class=\"str-chat__message-attachment__voice-recording-widget__right-section\"\n  >\n    <button\n      *ngIf=\"!audioElement?.paused; else fileIcon\"\n      class=\"str-chat__message_attachment__playback-rate-button\"\n      data-testid=\"playback-rate-button\"\n      (click)=\"setPlaybackRate()\"\n    >\n      {{ audioElement?.playbackRate | number: \"1.1-1\" }}x\n    </button>\n    <ng-template #fileIcon>\n      <stream-icon-placeholder\n        class=\"str-chat__attachment-type-icon\"\n        icon=\"audio-file\"\n      ></stream-icon-placeholder>\n    </ng-template>\n  </div>\n</div>\n" }]
        }], ctorParameters: function () { return [{ type: i0.NgZone }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { attachment: [{
                type: Input
            }], audioElement: [{
                type: ViewChild,
                args: ['audioElement']
            }] } });

/**
 * The `AttachmentList` component displays the attachments of a message
 */
class AttachmentListComponent {
    constructor(customTemplatesService, channelService, attachmentConfigurationService) {
        this.customTemplatesService = customTemplatesService;
        this.channelService = channelService;
        this.attachmentConfigurationService = attachmentConfigurationService;
        /**
         * The attachments to display
         */
        this.attachments = [];
        /**
         * Emits the state of the image carousel window
         */
        this.imageModalStateChange = new EventEmitter();
        this.class = 'str-chat__attachment-list-angular-host';
        this.orderedAttachments = [];
        this.imagesToView = [];
        this.imagesToViewCurrentIndex = 0;
        this.attachmentConfigurations = new Map();
    }
    ngOnChanges(changes) {
        if (changes.attachments) {
            const images = this.attachments.filter(this.isImage);
            const containsGallery = images.length >= 2;
            this.orderedAttachments = [
                ...(containsGallery ? this.createGallery(images) : images),
                ...this.attachments.filter((a) => this.isVideo(a)),
                ...this.attachments.filter((a) => this.isVoiceMessage(a)),
                ...this.attachments.filter((a) => this.isFile(a)),
            ];
            this.attachmentConfigurations = new Map();
            // Display link attachments only if there are no other attachments
            // Giphy-s always sent without other attachments
            if (this.orderedAttachments.length === 0) {
                this.orderedAttachments.push(...this.attachments.filter((a) => this.isCard(a)));
            }
        }
    }
    trackByUrl(_, attachment) {
        return (attachment.image_url ||
            attachment.img_url ||
            attachment.asset_url ||
            attachment.thumb_url);
    }
    isImage(attachment) {
        return isImageAttachment(attachment);
    }
    isSvg(attachment) {
        const filename = attachment.fallback || '';
        return !!filename.toLowerCase().endsWith('.svg');
    }
    isFile(attachment) {
        return attachment.type === 'file';
    }
    isGallery(attachment) {
        return attachment.type === 'gallery';
    }
    isVideo(attachment) {
        return (attachment.type === 'video' &&
            attachment.asset_url &&
            !attachment.og_scrape_url // links from video share services (such as YouTube or Facebook) are can't be played
        );
    }
    isCard(attachment) {
        return (!attachment.type ||
            (attachment.type === 'image' && !this.isImage(attachment)) ||
            attachment.type === 'giphy');
    }
    isVoiceMessage(attachment) {
        return attachment.type === 'voiceRecording';
    }
    hasFileSize(attachment) {
        return (attachment.file_size && Number.isFinite(Number(attachment.file_size)));
    }
    getFileSize(attachment) {
        return prettybytes(Number(attachment.file_size));
    }
    getModalContext() {
        return {
            isOpen: this.imagesToView && this.imagesToView.length > 0,
            isOpenChangeHandler: (isOpen) => (isOpen ? null : this.closeImageModal()),
            content: this.modalContent,
        };
    }
    trimUrl(url) {
        if (url !== undefined && url !== null) {
            const [trimmedUrl] = url
                .replace(/^(?:https?:\/\/)?(?:www\.)?/i, '')
                .split('/');
            return trimmedUrl;
        }
        return null;
    }
    sendAction(action) {
        void this.channelService.sendAction(this.messageId, {
            [action.name]: action.value,
        }, this.parentMessageId);
    }
    trackByActionValue(_, item) {
        return item.value;
    }
    openImageModal(attachments, selectedIndex = 0) {
        this.imageModalStateChange.next('opened');
        this.imagesToView = attachments;
        this.imagesToViewCurrentIndex = selectedIndex;
    }
    stepImages(dir) {
        this.imagesToViewCurrentIndex += dir * 1;
    }
    trackByImageUrl(_, item) {
        return item.image_url || item.img_url || item.thumb_url;
    }
    getAttachmentContext(attachment) {
        return { attachment };
    }
    getImageAttachmentConfiguration(attachment, type, element) {
        const existingConfiguration = this.attachmentConfigurations.get(attachment);
        if (existingConfiguration) {
            return existingConfiguration;
        }
        const configuration = this.attachmentConfigurationService.getImageAttachmentConfiguration(attachment, type, element);
        this.attachmentConfigurations.set(attachment, configuration);
        return configuration;
    }
    getCarouselImageAttachmentConfiguration(attachment, element) {
        return this.attachmentConfigurationService.getImageAttachmentConfiguration(attachment, 'carousel', element);
    }
    getVideoAttachmentConfiguration(attachment, element) {
        const existingConfiguration = this.attachmentConfigurations.get(attachment);
        if (existingConfiguration) {
            return existingConfiguration;
        }
        const configuration = this.attachmentConfigurationService.getVideoAttachmentConfiguration(attachment, element);
        this.attachmentConfigurations.set(attachment, configuration);
        return configuration;
    }
    getCardAttachmentConfiguration(attachment) {
        const existingConfiguration = this.attachmentConfigurations.get(attachment);
        if (existingConfiguration) {
            return existingConfiguration;
        }
        if (attachment.type === 'giphy') {
            return this.attachmentConfigurationService.getGiphyAttachmentConfiguration(attachment);
        }
        else {
            const configuration = this.attachmentConfigurationService.getScrapedImageAttachmentConfiguration(attachment);
            this.attachmentConfigurations.set(attachment, configuration);
            return configuration;
        }
    }
    get isImageModalPrevButtonVisible() {
        return this.imagesToViewCurrentIndex !== 0;
    }
    get isImageModalNextButtonVisible() {
        return this.imagesToViewCurrentIndex !== this.imagesToView.length - 1;
    }
    createGallery(images) {
        return [
            {
                type: 'gallery',
                images,
            },
        ];
    }
    closeImageModal() {
        this.imageModalStateChange.next('closed');
        this.imagesToView = [];
    }
}
AttachmentListComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: AttachmentListComponent, deps: [{ token: CustomTemplatesService }, { token: ChannelService }, { token: AttachmentConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
AttachmentListComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.0.4", type: AttachmentListComponent, selector: "stream-attachment-list", inputs: { messageId: "messageId", parentMessageId: "parentMessageId", attachments: "attachments" }, outputs: { imageModalStateChange: "imageModalStateChange" }, host: { properties: { "class": "this.class" } }, viewQueries: [{ propertyName: "modalContent", first: true, predicate: ["modalContent"], descendants: true, static: true }], usesOnChanges: true, ngImport: i0, template: "<div *ngIf=\"orderedAttachments.length > 0\" class=\"str-chat__attachment-list\">\n  <ng-container\n    *ngFor=\"let attachment of orderedAttachments; trackBy: trackByUrl\"\n  >\n    <div\n      data-testclass=\"attachment-container\"\n      class=\"str-chat__message-attachment str-chat__message-attachment--{{\n        attachment.type\n      }} str-chat__message-attachment-dynamic-size\"\n      [class.str-chat__message-attachment--card]=\"isCard(attachment)\"\n      [class.str-chat-angular__message-attachment-file-single]=\"\n        isFile(attachment)\n      \"\n      [class.str-chat__message-attachment--voice-recording]=\"\n        isVoiceMessage(attachment)\n      \"\n      [class.str-chat__message-attachment-with-actions]=\"\n        attachment.actions && attachment.actions.length > 0\n      \"\n      [class.str-chat__message-attachment--svg-image]=\"isSvg(attachment)\"\n    >\n      <ng-container *ngIf=\"isImage(attachment)\">\n        <ng-container\n          *ngTemplateOutlet=\"\n            (customTemplatesService.imageAttachmentTemplate$ | async) ||\n              defaultImage;\n            context: getAttachmentContext(attachment)\n          \"\n        ></ng-container>\n        <ng-template #defaultImage let-attachmentContext=\"attachment\">\n          <img\n            #imgElement\n            class=\"str-chat__message-attachment--img\"\n            data-testclass=\"image\"\n            [src]=\"\n              getImageAttachmentConfiguration(\n                attachmentContext,\n                'single',\n                imgElement\n              ).url\n            \"\n            [alt]=\"attachmentContext?.fallback\"\n            [ngStyle]=\"{\n              height: getImageAttachmentConfiguration(\n                attachmentContext,\n                'single',\n                imgElement\n              ).height,\n              width: getImageAttachmentConfiguration(\n                attachmentContext,\n                'single',\n                imgElement\n              ).width,\n              '--original-height': getImageAttachmentConfiguration(\n                attachmentContext,\n                'single',\n                imgElement\n              ).originalHeight,\n              '--original-width': getImageAttachmentConfiguration(\n                attachmentContext,\n                'single',\n                imgElement\n              ).originalWidth\n            }\"\n            (click)=\"openImageModal([attachmentContext])\"\n            (keyup.enter)=\"openImageModal([attachmentContext])\"\n          />\n        </ng-template>\n      </ng-container>\n      <ng-container *ngIf=\"isGallery(attachment)\">\n        <ng-container\n          *ngTemplateOutlet=\"\n            (customTemplatesService.galleryAttachmentTemplate$ | async) ||\n              defaultGallery;\n            context: getAttachmentContext(attachment)\n          \"\n        ></ng-container>\n        <ng-template #defaultGallery let-attachmentContext=\"attachment\">\n          <div\n            class=\"str-chat__gallery\"\n            data-testid=\"image-gallery\"\n            [class.str-chat__gallery--square]=\"\n              (attachmentContext?.images)!.length > 3\n            \"\n            [class.str-chat__gallery-two-rows]=\"\n              (attachmentContext?.images)!.length > 2\n            \"\n          >\n            <ng-container\n              *ngFor=\"\n                let galleryImage of attachmentContext.images;\n                let index = index;\n                let isLast = last;\n                trackBy: trackByImageUrl\n              \"\n            >\n              <button\n                *ngIf=\"index < 3 || (index === 3 && isLast)\"\n                class=\"str-chat__gallery-image\"\n                data-testclass=\"gallery-image\"\n                [class.str-chat__message-attachment--svg-image]=\"\n                  isSvg(galleryImage)\n                \"\n                (click)=\"openImageModal(attachmentContext.images!, index)\"\n                (keyup.enter)=\"openImageModal(attachmentContext.images!, index)\"\n              >\n                <img\n                  #imgElement\n                  fetchpriority=\"low\"\n                  loading=\"lazy\"\n                  [src]=\"\n                    getImageAttachmentConfiguration(\n                      galleryImage,\n                      'gallery',\n                      imgElement\n                    ).url\n                  \"\n                  [alt]=\"galleryImage.fallback\"\n                  [style.--original-height]=\"\n                    getImageAttachmentConfiguration(\n                      galleryImage,\n                      'gallery',\n                      imgElement\n                    ).originalHeight\n                  \"\n                  [style.--original-width]=\"\n                    getImageAttachmentConfiguration(\n                      galleryImage,\n                      'gallery',\n                      imgElement\n                    ).originalWidth\n                  \"\n                  [ngStyle]=\"{\n                    height: getImageAttachmentConfiguration(\n                      galleryImage,\n                      'gallery',\n                      imgElement\n                    ).height,\n                    width: getImageAttachmentConfiguration(\n                      galleryImage,\n                      'gallery',\n                      imgElement\n                    ).width\n                  }\"\n                />\n              </button>\n              <button\n                *ngIf=\"index === 3 && !isLast\"\n                #element\n                class=\"str-chat__gallery-placeholder\"\n                data-testclass=\"gallery-image\"\n                data-testid=\"more-image-button\"\n                [class.str-chat__message-attachment--svg-image]=\"\n                  isSvg(galleryImage)\n                \"\n                [ngStyle]=\"{\n                  'background-image':\n                    'url(' +\n                    getImageAttachmentConfiguration(\n                      galleryImage,\n                      'gallery',\n                      element\n                    ).url +\n                    ')',\n                  height: getImageAttachmentConfiguration(\n                    galleryImage,\n                    'gallery',\n                    element\n                  ).height,\n                  width: getImageAttachmentConfiguration(\n                    galleryImage,\n                    'gallery',\n                    element\n                  ).width,\n                  '--original-height': getImageAttachmentConfiguration(\n                    galleryImage,\n                    'gallery',\n                    element\n                  ).originalHeight,\n                  '--original-width': getImageAttachmentConfiguration(\n                    galleryImage,\n                    'gallery',\n                    element\n                  ).originalWidth\n                }\"\n                (click)=\"openImageModal(attachmentContext.images!, index)\"\n                (keyup.enter)=\"openImageModal(attachmentContext.images!, index)\"\n              >\n                <p\n                  [innerHTML]=\"\n                    'streamChat.{{ imageCount }} more'\n                      | translate\n                        : { imageCount: attachmentContext!.images!.length - 4 }\n                  \"\n                ></p>\n              </button>\n            </ng-container>\n          </div>\n        </ng-template>\n      </ng-container>\n      <ng-container *ngIf=\"isVideo(attachment)\">\n        <ng-container\n          *ngTemplateOutlet=\"\n            (customTemplatesService.videoAttachmentTemplate$ | async) ||\n              defaultVideo;\n            context: getAttachmentContext(attachment)\n          \"\n        ></ng-container>\n        <ng-template #defaultVideo let-attachmentContext=\"attachment\">\n          <div\n            class=\"str-chat__player-wrapper\"\n            data-testclass=\"video-attachment-parent\"\n            [style.--original-height]=\"\n              getVideoAttachmentConfiguration(attachmentContext, videoElement)\n                .originalHeight\n            \"\n            [style.--original-width]=\"\n              getVideoAttachmentConfiguration(attachmentContext, videoElement)\n                .originalWidth\n            \"\n            [ngStyle]=\"{\n              height: getVideoAttachmentConfiguration(\n                attachmentContext,\n                videoElement\n              ).height,\n              width: getVideoAttachmentConfiguration(\n                attachmentContext,\n                videoElement\n              ).width\n            }\"\n          >\n            <video\n              #videoElement\n              class=\"str-chat__video-angular\"\n              controls\n              data-testclass=\"video-attachment\"\n              [src]=\"\n                getVideoAttachmentConfiguration(attachmentContext, videoElement)\n                  .url\n              \"\n              [poster]=\"\n                getVideoAttachmentConfiguration(attachmentContext, videoElement)\n                  .thumbUrl\n              \"\n            ></video>\n          </div>\n        </ng-template>\n      </ng-container>\n      <ng-container *ngIf=\"isFile(attachment)\">\n        <ng-container\n          *ngTemplateOutlet=\"\n            (customTemplatesService.fileAttachmentTemplate$ | async) ||\n              defaultFile;\n            context: getAttachmentContext(attachment)\n          \"\n        ></ng-container>\n        <ng-template #defaultFile let-attachmentContext=\"attachment\">\n          <div\n            class=\"\n              str-chat__message-attachment-file--item\n              str-chat-angular__message-attachment-file-single\n            \"\n          >\n            <stream-icon-placeholder\n              class=\"str-chat__attachment-type-icon\"\n              icon=\"unspecified-filetype\"\n            ></stream-icon-placeholder>\n            <div class=\"str-chat__message-attachment-file--item-text\">\n              <a\n                class=\"str-chat__message-attachment-file--item-first-row\"\n                data-testclass=\"file-link\"\n                target=\"_blank\"\n                href=\"{{ attachmentContext.asset_url }}\"\n              >\n                <div\n                  data-testclass=\"file-title\"\n                  class=\"str-chat__message-attachment-file--item-name\"\n                >\n                  {{ attachmentContext.title }}\n                </div>\n                <stream-icon-placeholder\n                  class=\"str-chat__message-attachment-download-icon\"\n                  icon=\"download\"\n                ></stream-icon-placeholder>\n              </a>\n              <span\n                *ngIf=\"hasFileSize(attachmentContext)\"\n                class=\"str-chat__message-attachment-file--item-size\"\n                data-testclass=\"size\"\n                >{{ getFileSize(attachmentContext) }}</span\n              >\n            </div>\n          </div>\n        </ng-template>\n      </ng-container>\n      <ng-container *ngIf=\"isVoiceMessage(attachment)\">\n        <ng-container\n          *ngTemplateOutlet=\"\n            (customTemplatesService.voiceRecordingAttachmentTemplate$\n              | async) || defaultRecording;\n            context: getAttachmentContext(attachment)\n          \"\n        ></ng-container>\n        <ng-template #defaultRecording>\n          <stream-voice-recording\n            data-testclass=\"voice-recording\"\n            [attachment]=\"attachment\"\n          ></stream-voice-recording>\n        </ng-template>\n      </ng-container>\n      <ng-container\n        *ngIf=\"\n          isCard(attachment) &&\n          getCardAttachmentConfiguration(attachment) as attachmentConfiguration\n        \"\n      >\n        <ng-container\n          *ngTemplateOutlet=\"\n            (customTemplatesService.cardAttachmentTemplate$ | async) ||\n              defaultCard;\n            context: getAttachmentContext(attachment)\n          \"\n        ></ng-container>\n        <ng-template #defaultCard let-attachmentContext=\"attachment\">\n          <div\n            class=\"str-chat__message-attachment-card str-chat__message-attachment-card--{{\n              attachmentContext.type\n            }}\"\n          >\n            <div\n              *ngIf=\"attachmentConfiguration.url\"\n              class=\"str-chat__message-attachment-card--header\"\n            >\n              <img\n                fetchpriority=\"low\"\n                loading=\"lazy\"\n                data-testclass=\"card-img\"\n                alt=\"{{ attachmentConfiguration.url }}\"\n                src=\"{{ attachmentConfiguration.url }}\"\n                [ngStyle]=\"{\n                  height: attachmentConfiguration.height,\n                  width: attachmentConfiguration.width\n                }\"\n              />\n            </div>\n            <div class=\"str-chat__message-attachment-card--content\">\n              <div class=\"str-chat__message-attachment-card--flex\">\n                <div\n                  *ngIf=\"attachmentContext.title\"\n                  data-testclass=\"card-title\"\n                  class=\"str-chat__message-attachment-card--title\"\n                >\n                  {{ attachmentContext.title }}\n                </div>\n                <div\n                  *ngIf=\"attachmentContext.text\"\n                  class=\"str-chat__message-attachment-card--text\"\n                  data-testclass=\"card-text\"\n                >\n                  {{ attachmentContext.text }}\n                </div>\n                <a\n                  *ngIf=\"\n                    attachmentContext.title_link ||\n                    attachmentContext.og_scrape_url\n                  \"\n                  class=\"str-chat__message-attachment-card--url\"\n                  data-testclass=\"url-link\"\n                  noopener\n                  noreferrer\n                  target=\"_blank\"\n                  href=\"{{\n                    attachmentContext.title_link ||\n                      attachmentContext.og_scrape_url\n                  }}\"\n                >\n                  {{\n                    trimUrl(\n                      attachmentContext.title_link ||\n                        attachmentContext.og_scrape_url\n                    )\n                  }}\n                </a>\n              </div>\n            </div>\n          </div>\n        </ng-template>\n      </ng-container>\n      <ng-container *ngIf=\"attachment.actions && attachment.actions.length > 0\">\n        <ng-container\n          *ngTemplateOutlet=\"\n            (customTemplatesService.attachmentActionsTemplate$ | async) ||\n              defaultActions;\n            context: getAttachmentContext(attachment)\n          \"\n        ></ng-container>\n        <ng-template #defaultActions let-attachmentContext=\"attachment\">\n          <div class=\"str-chat__message-attachment-actions\">\n            <div class=\"str-chat__message-attachment-actions-form\">\n              <button\n                *ngFor=\"\n                  let action of attachmentContext.actions;\n                  trackBy: trackByActionValue\n                \"\n                data-testclass=\"attachment-action\"\n                class=\"str-chat__message-attachment-actions-button str-chat__message-attachment-actions-button--{{\n                  action.style\n                }}\"\n                (click)=\"sendAction(action)\"\n                (keyup.enter)=\"sendAction(action)\"\n              >\n                {{ action.text }}\n              </button>\n            </div>\n          </div>\n        </ng-template>\n      </ng-container>\n    </div>\n  </ng-container>\n\n  <ng-container *ngIf=\"imagesToView && imagesToView.length > 0\">\n    <ng-container\n      *ngTemplateOutlet=\"\n        (customTemplatesService.modalTemplate$ | async) || defaultModal;\n        context: getModalContext()\n      \"\n    ></ng-container>\n  </ng-container>\n</div>\n\n<ng-template\n  #defaultModal\n  let-isOpen=\"isOpen\"\n  let-isOpenChangeHandler=\"isOpenChangeHandler\"\n  let-content=\"content\"\n>\n  <stream-modal\n    class=\"stream-chat-angular__image-modal-host\"\n    [isOpen]=\"isOpen\"\n    [content]=\"content\"\n    (isOpenChange)=\"isOpenChangeHandler($event)\"\n  >\n  </stream-modal>\n</ng-template>\n\n<ng-template #modalContent>\n  <div class=\"stream-chat-angular__image-modal str-chat__image-carousel\">\n    <img\n      #imgElement\n      class=\"\n        stream-chat-angular__image-modal-image\n        str-chat__image-carousel-image\n      \"\n      data-testid=\"modal-image\"\n      [src]=\"\n        getCarouselImageAttachmentConfiguration(\n          imagesToView[imagesToViewCurrentIndex],\n          imgElement\n        ).url\n      \"\n      [style.--original-height]=\"\n        getCarouselImageAttachmentConfiguration(\n          imagesToView[imagesToViewCurrentIndex],\n          imgElement\n        ).originalHeight\n      \"\n      [style.--original-width]=\"\n        getCarouselImageAttachmentConfiguration(\n          imagesToView[imagesToViewCurrentIndex],\n          imgElement\n        ).originalWidth\n      \"\n      [alt]=\"imagesToView[imagesToViewCurrentIndex].fallback\"\n      [ngStyle]=\"{\n        width: getCarouselImageAttachmentConfiguration(\n          imagesToView[imagesToViewCurrentIndex],\n          imgElement\n        ).width,\n        height: getCarouselImageAttachmentConfiguration(\n          imagesToView[imagesToViewCurrentIndex],\n          imgElement\n        ).height\n      }\"\n    />\n    <div>\n      <button\n        class=\"\n          stream-chat-angular__image-modal-stepper\n          str-chat__image-carousel-stepper str-chat__image-carousel-stepper-prev\n        \"\n        data-testid=\"image-modal-prev\"\n        type=\"button\"\n        [ngStyle]=\"{\n          visibility: isImageModalPrevButtonVisible ? 'visible' : 'hidden'\n        }\"\n        (click)=\"stepImages(-1)\"\n        (keyup.enter)=\"stepImages(-1)\"\n      >\n        <stream-icon-placeholder icon=\"arrow-left\"></stream-icon-placeholder>\n      </button>\n      <button\n        class=\"\n          stream-chat-angular__image-modal-stepper\n          str-chat__image-carousel-stepper str-chat__image-carousel-stepper-next\n        \"\n        type=\"button\"\n        data-testid=\"image-modal-next\"\n        [ngStyle]=\"{\n          visibility: isImageModalNextButtonVisible ? 'visible' : 'hidden'\n        }\"\n        (click)=\"stepImages(1)\"\n        (keyup.enter)=\"stepImages(1)\"\n      >\n        <stream-icon-placeholder icon=\"arrow-right\"></stream-icon-placeholder>\n      </button>\n    </div>\n  </div>\n</ng-template>\n", dependencies: [{ kind: "directive", type: i4.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i4.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i4.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: i4.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "component", type: ModalComponent, selector: "stream-modal", inputs: ["isOpen", "content"], outputs: ["isOpenChange"] }, { kind: "component", type: IconPlaceholderComponent, selector: "stream-icon-placeholder", inputs: ["icon"] }, { kind: "component", type: VoiceRecordingComponent, selector: "stream-voice-recording", inputs: ["attachment"] }, { kind: "pipe", type: i4.AsyncPipe, name: "async" }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: AttachmentListComponent, decorators: [{
            type: Component,
            args: [{ selector: 'stream-attachment-list', template: "<div *ngIf=\"orderedAttachments.length > 0\" class=\"str-chat__attachment-list\">\n  <ng-container\n    *ngFor=\"let attachment of orderedAttachments; trackBy: trackByUrl\"\n  >\n    <div\n      data-testclass=\"attachment-container\"\n      class=\"str-chat__message-attachment str-chat__message-attachment--{{\n        attachment.type\n      }} str-chat__message-attachment-dynamic-size\"\n      [class.str-chat__message-attachment--card]=\"isCard(attachment)\"\n      [class.str-chat-angular__message-attachment-file-single]=\"\n        isFile(attachment)\n      \"\n      [class.str-chat__message-attachment--voice-recording]=\"\n        isVoiceMessage(attachment)\n      \"\n      [class.str-chat__message-attachment-with-actions]=\"\n        attachment.actions && attachment.actions.length > 0\n      \"\n      [class.str-chat__message-attachment--svg-image]=\"isSvg(attachment)\"\n    >\n      <ng-container *ngIf=\"isImage(attachment)\">\n        <ng-container\n          *ngTemplateOutlet=\"\n            (customTemplatesService.imageAttachmentTemplate$ | async) ||\n              defaultImage;\n            context: getAttachmentContext(attachment)\n          \"\n        ></ng-container>\n        <ng-template #defaultImage let-attachmentContext=\"attachment\">\n          <img\n            #imgElement\n            class=\"str-chat__message-attachment--img\"\n            data-testclass=\"image\"\n            [src]=\"\n              getImageAttachmentConfiguration(\n                attachmentContext,\n                'single',\n                imgElement\n              ).url\n            \"\n            [alt]=\"attachmentContext?.fallback\"\n            [ngStyle]=\"{\n              height: getImageAttachmentConfiguration(\n                attachmentContext,\n                'single',\n                imgElement\n              ).height,\n              width: getImageAttachmentConfiguration(\n                attachmentContext,\n                'single',\n                imgElement\n              ).width,\n              '--original-height': getImageAttachmentConfiguration(\n                attachmentContext,\n                'single',\n                imgElement\n              ).originalHeight,\n              '--original-width': getImageAttachmentConfiguration(\n                attachmentContext,\n                'single',\n                imgElement\n              ).originalWidth\n            }\"\n            (click)=\"openImageModal([attachmentContext])\"\n            (keyup.enter)=\"openImageModal([attachmentContext])\"\n          />\n        </ng-template>\n      </ng-container>\n      <ng-container *ngIf=\"isGallery(attachment)\">\n        <ng-container\n          *ngTemplateOutlet=\"\n            (customTemplatesService.galleryAttachmentTemplate$ | async) ||\n              defaultGallery;\n            context: getAttachmentContext(attachment)\n          \"\n        ></ng-container>\n        <ng-template #defaultGallery let-attachmentContext=\"attachment\">\n          <div\n            class=\"str-chat__gallery\"\n            data-testid=\"image-gallery\"\n            [class.str-chat__gallery--square]=\"\n              (attachmentContext?.images)!.length > 3\n            \"\n            [class.str-chat__gallery-two-rows]=\"\n              (attachmentContext?.images)!.length > 2\n            \"\n          >\n            <ng-container\n              *ngFor=\"\n                let galleryImage of attachmentContext.images;\n                let index = index;\n                let isLast = last;\n                trackBy: trackByImageUrl\n              \"\n            >\n              <button\n                *ngIf=\"index < 3 || (index === 3 && isLast)\"\n                class=\"str-chat__gallery-image\"\n                data-testclass=\"gallery-image\"\n                [class.str-chat__message-attachment--svg-image]=\"\n                  isSvg(galleryImage)\n                \"\n                (click)=\"openImageModal(attachmentContext.images!, index)\"\n                (keyup.enter)=\"openImageModal(attachmentContext.images!, index)\"\n              >\n                <img\n                  #imgElement\n                  fetchpriority=\"low\"\n                  loading=\"lazy\"\n                  [src]=\"\n                    getImageAttachmentConfiguration(\n                      galleryImage,\n                      'gallery',\n                      imgElement\n                    ).url\n                  \"\n                  [alt]=\"galleryImage.fallback\"\n                  [style.--original-height]=\"\n                    getImageAttachmentConfiguration(\n                      galleryImage,\n                      'gallery',\n                      imgElement\n                    ).originalHeight\n                  \"\n                  [style.--original-width]=\"\n                    getImageAttachmentConfiguration(\n                      galleryImage,\n                      'gallery',\n                      imgElement\n                    ).originalWidth\n                  \"\n                  [ngStyle]=\"{\n                    height: getImageAttachmentConfiguration(\n                      galleryImage,\n                      'gallery',\n                      imgElement\n                    ).height,\n                    width: getImageAttachmentConfiguration(\n                      galleryImage,\n                      'gallery',\n                      imgElement\n                    ).width\n                  }\"\n                />\n              </button>\n              <button\n                *ngIf=\"index === 3 && !isLast\"\n                #element\n                class=\"str-chat__gallery-placeholder\"\n                data-testclass=\"gallery-image\"\n                data-testid=\"more-image-button\"\n                [class.str-chat__message-attachment--svg-image]=\"\n                  isSvg(galleryImage)\n                \"\n                [ngStyle]=\"{\n                  'background-image':\n                    'url(' +\n                    getImageAttachmentConfiguration(\n                      galleryImage,\n                      'gallery',\n                      element\n                    ).url +\n                    ')',\n                  height: getImageAttachmentConfiguration(\n                    galleryImage,\n                    'gallery',\n                    element\n                  ).height,\n                  width: getImageAttachmentConfiguration(\n                    galleryImage,\n                    'gallery',\n                    element\n                  ).width,\n                  '--original-height': getImageAttachmentConfiguration(\n                    galleryImage,\n                    'gallery',\n                    element\n                  ).originalHeight,\n                  '--original-width': getImageAttachmentConfiguration(\n                    galleryImage,\n                    'gallery',\n                    element\n                  ).originalWidth\n                }\"\n                (click)=\"openImageModal(attachmentContext.images!, index)\"\n                (keyup.enter)=\"openImageModal(attachmentContext.images!, index)\"\n              >\n                <p\n                  [innerHTML]=\"\n                    'streamChat.{{ imageCount }} more'\n                      | translate\n                        : { imageCount: attachmentContext!.images!.length - 4 }\n                  \"\n                ></p>\n              </button>\n            </ng-container>\n          </div>\n        </ng-template>\n      </ng-container>\n      <ng-container *ngIf=\"isVideo(attachment)\">\n        <ng-container\n          *ngTemplateOutlet=\"\n            (customTemplatesService.videoAttachmentTemplate$ | async) ||\n              defaultVideo;\n            context: getAttachmentContext(attachment)\n          \"\n        ></ng-container>\n        <ng-template #defaultVideo let-attachmentContext=\"attachment\">\n          <div\n            class=\"str-chat__player-wrapper\"\n            data-testclass=\"video-attachment-parent\"\n            [style.--original-height]=\"\n              getVideoAttachmentConfiguration(attachmentContext, videoElement)\n                .originalHeight\n            \"\n            [style.--original-width]=\"\n              getVideoAttachmentConfiguration(attachmentContext, videoElement)\n                .originalWidth\n            \"\n            [ngStyle]=\"{\n              height: getVideoAttachmentConfiguration(\n                attachmentContext,\n                videoElement\n              ).height,\n              width: getVideoAttachmentConfiguration(\n                attachmentContext,\n                videoElement\n              ).width\n            }\"\n          >\n            <video\n              #videoElement\n              class=\"str-chat__video-angular\"\n              controls\n              data-testclass=\"video-attachment\"\n              [src]=\"\n                getVideoAttachmentConfiguration(attachmentContext, videoElement)\n                  .url\n              \"\n              [poster]=\"\n                getVideoAttachmentConfiguration(attachmentContext, videoElement)\n                  .thumbUrl\n              \"\n            ></video>\n          </div>\n        </ng-template>\n      </ng-container>\n      <ng-container *ngIf=\"isFile(attachment)\">\n        <ng-container\n          *ngTemplateOutlet=\"\n            (customTemplatesService.fileAttachmentTemplate$ | async) ||\n              defaultFile;\n            context: getAttachmentContext(attachment)\n          \"\n        ></ng-container>\n        <ng-template #defaultFile let-attachmentContext=\"attachment\">\n          <div\n            class=\"\n              str-chat__message-attachment-file--item\n              str-chat-angular__message-attachment-file-single\n            \"\n          >\n            <stream-icon-placeholder\n              class=\"str-chat__attachment-type-icon\"\n              icon=\"unspecified-filetype\"\n            ></stream-icon-placeholder>\n            <div class=\"str-chat__message-attachment-file--item-text\">\n              <a\n                class=\"str-chat__message-attachment-file--item-first-row\"\n                data-testclass=\"file-link\"\n                target=\"_blank\"\n                href=\"{{ attachmentContext.asset_url }}\"\n              >\n                <div\n                  data-testclass=\"file-title\"\n                  class=\"str-chat__message-attachment-file--item-name\"\n                >\n                  {{ attachmentContext.title }}\n                </div>\n                <stream-icon-placeholder\n                  class=\"str-chat__message-attachment-download-icon\"\n                  icon=\"download\"\n                ></stream-icon-placeholder>\n              </a>\n              <span\n                *ngIf=\"hasFileSize(attachmentContext)\"\n                class=\"str-chat__message-attachment-file--item-size\"\n                data-testclass=\"size\"\n                >{{ getFileSize(attachmentContext) }}</span\n              >\n            </div>\n          </div>\n        </ng-template>\n      </ng-container>\n      <ng-container *ngIf=\"isVoiceMessage(attachment)\">\n        <ng-container\n          *ngTemplateOutlet=\"\n            (customTemplatesService.voiceRecordingAttachmentTemplate$\n              | async) || defaultRecording;\n            context: getAttachmentContext(attachment)\n          \"\n        ></ng-container>\n        <ng-template #defaultRecording>\n          <stream-voice-recording\n            data-testclass=\"voice-recording\"\n            [attachment]=\"attachment\"\n          ></stream-voice-recording>\n        </ng-template>\n      </ng-container>\n      <ng-container\n        *ngIf=\"\n          isCard(attachment) &&\n          getCardAttachmentConfiguration(attachment) as attachmentConfiguration\n        \"\n      >\n        <ng-container\n          *ngTemplateOutlet=\"\n            (customTemplatesService.cardAttachmentTemplate$ | async) ||\n              defaultCard;\n            context: getAttachmentContext(attachment)\n          \"\n        ></ng-container>\n        <ng-template #defaultCard let-attachmentContext=\"attachment\">\n          <div\n            class=\"str-chat__message-attachment-card str-chat__message-attachment-card--{{\n              attachmentContext.type\n            }}\"\n          >\n            <div\n              *ngIf=\"attachmentConfiguration.url\"\n              class=\"str-chat__message-attachment-card--header\"\n            >\n              <img\n                fetchpriority=\"low\"\n                loading=\"lazy\"\n                data-testclass=\"card-img\"\n                alt=\"{{ attachmentConfiguration.url }}\"\n                src=\"{{ attachmentConfiguration.url }}\"\n                [ngStyle]=\"{\n                  height: attachmentConfiguration.height,\n                  width: attachmentConfiguration.width\n                }\"\n              />\n            </div>\n            <div class=\"str-chat__message-attachment-card--content\">\n              <div class=\"str-chat__message-attachment-card--flex\">\n                <div\n                  *ngIf=\"attachmentContext.title\"\n                  data-testclass=\"card-title\"\n                  class=\"str-chat__message-attachment-card--title\"\n                >\n                  {{ attachmentContext.title }}\n                </div>\n                <div\n                  *ngIf=\"attachmentContext.text\"\n                  class=\"str-chat__message-attachment-card--text\"\n                  data-testclass=\"card-text\"\n                >\n                  {{ attachmentContext.text }}\n                </div>\n                <a\n                  *ngIf=\"\n                    attachmentContext.title_link ||\n                    attachmentContext.og_scrape_url\n                  \"\n                  class=\"str-chat__message-attachment-card--url\"\n                  data-testclass=\"url-link\"\n                  noopener\n                  noreferrer\n                  target=\"_blank\"\n                  href=\"{{\n                    attachmentContext.title_link ||\n                      attachmentContext.og_scrape_url\n                  }}\"\n                >\n                  {{\n                    trimUrl(\n                      attachmentContext.title_link ||\n                        attachmentContext.og_scrape_url\n                    )\n                  }}\n                </a>\n              </div>\n            </div>\n          </div>\n        </ng-template>\n      </ng-container>\n      <ng-container *ngIf=\"attachment.actions && attachment.actions.length > 0\">\n        <ng-container\n          *ngTemplateOutlet=\"\n            (customTemplatesService.attachmentActionsTemplate$ | async) ||\n              defaultActions;\n            context: getAttachmentContext(attachment)\n          \"\n        ></ng-container>\n        <ng-template #defaultActions let-attachmentContext=\"attachment\">\n          <div class=\"str-chat__message-attachment-actions\">\n            <div class=\"str-chat__message-attachment-actions-form\">\n              <button\n                *ngFor=\"\n                  let action of attachmentContext.actions;\n                  trackBy: trackByActionValue\n                \"\n                data-testclass=\"attachment-action\"\n                class=\"str-chat__message-attachment-actions-button str-chat__message-attachment-actions-button--{{\n                  action.style\n                }}\"\n                (click)=\"sendAction(action)\"\n                (keyup.enter)=\"sendAction(action)\"\n              >\n                {{ action.text }}\n              </button>\n            </div>\n          </div>\n        </ng-template>\n      </ng-container>\n    </div>\n  </ng-container>\n\n  <ng-container *ngIf=\"imagesToView && imagesToView.length > 0\">\n    <ng-container\n      *ngTemplateOutlet=\"\n        (customTemplatesService.modalTemplate$ | async) || defaultModal;\n        context: getModalContext()\n      \"\n    ></ng-container>\n  </ng-container>\n</div>\n\n<ng-template\n  #defaultModal\n  let-isOpen=\"isOpen\"\n  let-isOpenChangeHandler=\"isOpenChangeHandler\"\n  let-content=\"content\"\n>\n  <stream-modal\n    class=\"stream-chat-angular__image-modal-host\"\n    [isOpen]=\"isOpen\"\n    [content]=\"content\"\n    (isOpenChange)=\"isOpenChangeHandler($event)\"\n  >\n  </stream-modal>\n</ng-template>\n\n<ng-template #modalContent>\n  <div class=\"stream-chat-angular__image-modal str-chat__image-carousel\">\n    <img\n      #imgElement\n      class=\"\n        stream-chat-angular__image-modal-image\n        str-chat__image-carousel-image\n      \"\n      data-testid=\"modal-image\"\n      [src]=\"\n        getCarouselImageAttachmentConfiguration(\n          imagesToView[imagesToViewCurrentIndex],\n          imgElement\n        ).url\n      \"\n      [style.--original-height]=\"\n        getCarouselImageAttachmentConfiguration(\n          imagesToView[imagesToViewCurrentIndex],\n          imgElement\n        ).originalHeight\n      \"\n      [style.--original-width]=\"\n        getCarouselImageAttachmentConfiguration(\n          imagesToView[imagesToViewCurrentIndex],\n          imgElement\n        ).originalWidth\n      \"\n      [alt]=\"imagesToView[imagesToViewCurrentIndex].fallback\"\n      [ngStyle]=\"{\n        width: getCarouselImageAttachmentConfiguration(\n          imagesToView[imagesToViewCurrentIndex],\n          imgElement\n        ).width,\n        height: getCarouselImageAttachmentConfiguration(\n          imagesToView[imagesToViewCurrentIndex],\n          imgElement\n        ).height\n      }\"\n    />\n    <div>\n      <button\n        class=\"\n          stream-chat-angular__image-modal-stepper\n          str-chat__image-carousel-stepper str-chat__image-carousel-stepper-prev\n        \"\n        data-testid=\"image-modal-prev\"\n        type=\"button\"\n        [ngStyle]=\"{\n          visibility: isImageModalPrevButtonVisible ? 'visible' : 'hidden'\n        }\"\n        (click)=\"stepImages(-1)\"\n        (keyup.enter)=\"stepImages(-1)\"\n      >\n        <stream-icon-placeholder icon=\"arrow-left\"></stream-icon-placeholder>\n      </button>\n      <button\n        class=\"\n          stream-chat-angular__image-modal-stepper\n          str-chat__image-carousel-stepper str-chat__image-carousel-stepper-next\n        \"\n        type=\"button\"\n        data-testid=\"image-modal-next\"\n        [ngStyle]=\"{\n          visibility: isImageModalNextButtonVisible ? 'visible' : 'hidden'\n        }\"\n        (click)=\"stepImages(1)\"\n        (keyup.enter)=\"stepImages(1)\"\n      >\n        <stream-icon-placeholder icon=\"arrow-right\"></stream-icon-placeholder>\n      </button>\n    </div>\n  </div>\n</ng-template>\n" }]
        }], ctorParameters: function () { return [{ type: CustomTemplatesService }, { type: ChannelService }, { type: AttachmentConfigurationService }]; }, propDecorators: { messageId: [{
                type: Input
            }], parentMessageId: [{
                type: Input
            }], attachments: [{
                type: Input
            }], imageModalStateChange: [{
                type: Output
            }], class: [{
                type: HostBinding
            }], modalContent: [{
                type: ViewChild,
                args: ['modalContent', { static: true }]
            }] } });

/**
 * The `MessageReactions` component displays the reactions of a message. You can read more about [message reactions](https://getstream.io/chat/docs/javascript/send_reaction/?language=javascript) in the platform documentation.
 */
class MessageReactionsComponent {
    constructor(cdRef, channelService, messageReactionsService, customTemplatesService) {
        this.cdRef = cdRef;
        this.channelService = channelService;
        this.messageReactionsService = messageReactionsService;
        this.customTemplatesService = customTemplatesService;
        /**
         * The number of reactions grouped by [reaction types](https://github.com/GetStream/stream-chat-angular/tree/master/projects/stream-chat-angular/src/lib/message-reactions/message-reactions.component.ts)
         */
        this.messageReactionCounts = {};
        /**
         * List of reactions of a [message](../types/stream-message.mdx), used to display the users of a reaction type.
         */
        this.latestReactions = [];
        /**
         * List of the user's own reactions of a [message](../types/stream-message.mdx), used to display the users of a reaction type.
         */
        this.ownReactions = [];
        this.isLoading = true;
        this.reactions = [];
        this.shouldHandleReactionClick = true;
        this.existingReactions = [];
        this.reactionsCount = 0;
        this.reactionOptions = [];
        this.subscriptions = [];
        this.isViewInited = false;
        this.isOpenChange = (isOpen) => {
            this.selectedReactionType = isOpen ? this.selectedReactionType : undefined;
        };
    }
    ngOnInit() {
        this.subscriptions.push(this.messageReactionsService.reactions$.subscribe((reactions) => {
            this.reactionOptions = Object.keys(reactions);
            this.setExistingReactions();
            if (this.isViewInited) {
                this.cdRef.detectChanges();
            }
        }));
    }
    ngOnChanges(changes) {
        if (changes.messageReactionCounts) {
            this.setExistingReactions();
        }
        if (changes.messageReactionCounts && this.messageReactionCounts) {
            const reactionsCount = Object.keys(this.messageReactionCounts).reduce((acc, key) => acc + (this.messageReactionCounts[key] || 0), 0);
            this.shouldHandleReactionClick =
                reactionsCount <= ChannelService.MAX_MESSAGE_REACTIONS_TO_FETCH ||
                    !!this.messageReactionsService.customReactionClickHandler;
        }
    }
    ngAfterViewInit() {
        this.isViewInited = true;
    }
    ngOnDestroy() {
        this.subscriptions.forEach((s) => s.unsubscribe());
    }
    getEmojiByReaction(reactionType) {
        return this.messageReactionsService.reactions[reactionType];
    }
    reactionSelected(reactionType) {
        if (!this.shouldHandleReactionClick) {
            return;
        }
        if (!this.messageId) {
            return;
        }
        if (this.messageReactionsService.customReactionClickHandler) {
            this.messageReactionsService.customReactionClickHandler({
                messageId: this.messageId,
                reactionType: reactionType,
            });
        }
        else {
            this.selectedReactionType = reactionType;
            void this.fetchAllReactions();
        }
    }
    getUsersByReaction(reactionType) {
        return this.latestReactions
            .filter((r) => r.type === reactionType)
            .map((r) => r.user?.name || r.user?.id)
            .filter((i) => !!i)
            .join(', ');
    }
    getAllUsersByReaction(reactionType) {
        if (!reactionType) {
            return [];
        }
        const users = this.reactions
            .filter((r) => r.type === reactionType)
            .map((r) => r.user)
            .filter((i) => !!i);
        users.sort((u1, u2) => {
            const name1 = u1.name?.toLowerCase();
            const name2 = u2.name?.toLowerCase();
            if (!name1) {
                return 1;
            }
            if (!name2) {
                return -1;
            }
            if (name1 === name2) {
                return 0;
            }
            if (name1 < name2) {
                return -1;
            }
            else {
                return 1;
            }
        });
        return users;
    }
    trackByMessageReaction(_, item) {
        return item;
    }
    trackByUserId(_, item) {
        return item.id;
    }
    isOwnReaction(reactionType) {
        return !!this.ownReactions.find((r) => r.type === reactionType);
    }
    async fetchAllReactions() {
        if (!this.messageId) {
            return;
        }
        this.isLoading = true;
        try {
            this.reactions = await this.channelService.getMessageReactions(this.messageId);
        }
        catch (error) {
            this.selectedReactionType = undefined;
        }
        finally {
            this.isLoading = false;
            this.cdRef.detectChanges();
        }
    }
    setExistingReactions() {
        this.existingReactions = Object.keys(this.messageReactionCounts)
            .filter((k) => this.reactionOptions.indexOf(k) !== -1)
            .filter((k) => this.messageReactionCounts[k] > 0);
        this.reactionsCount = this.existingReactions.reduce((total, reaction) => total + this.messageReactionCounts[reaction], 0);
    }
}
MessageReactionsComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: MessageReactionsComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: ChannelService }, { token: MessageReactionsService }, { token: CustomTemplatesService }], target: i0.ɵɵFactoryTarget.Component });
MessageReactionsComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.0.4", type: MessageReactionsComponent, selector: "stream-message-reactions", inputs: { messageId: "messageId", messageReactionCounts: "messageReactionCounts", latestReactions: "latestReactions", ownReactions: "ownReactions" }, viewQueries: [{ propertyName: "selectorContainer", first: true, predicate: ["selectorContainer"], descendants: true }], usesOnChanges: true, ngImport: i0, template: "<div\n  *ngIf=\"existingReactions.length > 0\"\n  data-testid=\"reaction-list\"\n  class=\"str-chat__reaction-list str-chat__message-reactions-container\"\n  [class.str-chat__reaction-list--reverse]=\"true\"\n>\n  <ul class=\"str-chat__message-reactions\">\n    <li\n      *ngFor=\"\n        let reactionType of existingReactions;\n        trackBy: trackByMessageReaction\n      \"\n      class=\"str-chat__message-reaction\"\n      data-testclass=\"emoji\"\n      [ngStyle]=\"{ cursor: shouldHandleReactionClick ? 'pointer' : 'default' }\"\n      [class.str-chat__message-reaction-own]=\"isOwnReaction(reactionType)\"\n      (click)=\"reactionSelected(reactionType)\"\n      (keyup.enter)=\"reactionSelected(reactionType)\"\n    >\n      <span class=\"emoji str-chat__message-reaction-emoji\">\n        {{ getEmojiByReaction(reactionType) }}&nbsp;\n      </span>\n      <span\n        data-testclass=\"reaction-list-reaction-count\"\n        class=\"str-chat__message-reaction-count\"\n      >\n        {{ messageReactionCounts[reactionType] }}\n      </span>\n    </li>\n    <li>\n      <span\n        data-testid=\"reactions-count\"\n        class=\"str-chat__reaction-list--counter\"\n        >{{ reactionsCount }}</span\n      >\n    </li>\n  </ul>\n</div>\n\n<ng-container *ngIf=\"selectedReactionType\">\n  <ng-container\n    *ngTemplateOutlet=\"\n      (customTemplatesService.modalTemplate$ | async) || defaultModal;\n      context: {\n        isOpen: !!selectedReactionType,\n        messageId: messageId,\n        reactionType: selectedReactionType,\n        isOpenChangeHandler: isOpenChange,\n        content: modalContent\n      }\n    \"\n  ></ng-container>\n</ng-container>\n\n<ng-template\n  #defaultModal\n  let-isOpen=\"isOpen\"\n  let-messageId=\"messageId\"\n  let-reactionType=\"reactionType\"\n  let-isOpenChangeHandler=\"isOpenChangeHandler\"\n  let-content=\"content\"\n>\n  <stream-modal\n    class=\"str-chat__message-reactions-details-modal\"\n    [isOpen]=\"isOpen\"\n    [content]=\"content\"\n    (isOpenChange)=\"isOpenChangeHandler($event)\"\n  >\n  </stream-modal>\n</ng-template>\n\n<ng-template #modalContent>\n  <div class=\"str-chat__message-reactions-details\">\n    <div class=\"str-chat__message-reactions-details-reaction-types\">\n      <div\n        *ngFor=\"\n          let reactionType of existingReactions;\n          trackBy: trackByMessageReaction\n        \"\n        class=\"str-chat__message-reactions-details-reaction-type\"\n        [ngStyle]=\"{\n          cursor: shouldHandleReactionClick ? 'pointer' : 'default'\n        }\"\n        attr.data-testid=\"reaction-details-selector-{{ reactionType }}\"\n        [class.str-chat__message-reactions-details-reaction-type--selected]=\"\n          reactionType === selectedReactionType\n        \"\n        (click)=\"selectedReactionType = reactionType; allUsers.scrollTop = 0\"\n        (keyup.enter)=\"\n          selectedReactionType = reactionType; allUsers.scrollTop = 0\n        \"\n      >\n        <span class=\"emoji str-chat__message-reaction-emoji\">\n          {{ getEmojiByReaction(reactionType) }}&nbsp;\n        </span>\n        <span class=\"str-chat__message-reaction-count\">\n          {{ messageReactionCounts[reactionType] }}\n        </span>\n      </div>\n    </div>\n    <div\n      class=\"\n        emoji\n        str-chat__message-reaction-emoji str-chat__message-reaction-emoji-big\n      \"\n    >\n      {{ getEmojiByReaction(selectedReactionType!) }}\n    </div>\n    <div\n      #allUsers\n      data-testid=\"all-reacting-users\"\n      class=\"str-chat__message-reactions-details-reacting-users\"\n    >\n      <stream-loading-indicator\n        *ngIf=\"isLoading; else reactions\"\n      ></stream-loading-indicator>\n      <ng-template #reactions>\n        <div\n          *ngFor=\"\n            let user of getAllUsersByReaction(selectedReactionType);\n            trackBy: trackByUserId\n          \"\n          class=\"str-chat__message-reactions-details-reacting-user\"\n        >\n          <stream-avatar-placeholder\n            data-testclass=\"avatar\"\n            class=\"str-chat__avatar str-chat__avatar--circle\"\n            type=\"user\"\n            location=\"reaction\"\n            [imageUrl]=\"user.image\"\n            [name]=\"user.name\"\n            [user]=\"user\"\n          ></stream-avatar-placeholder>\n          <span\n            data-testclass=\"reaction-user-username\"\n            class=\"str-chat__user-item--name\"\n            >{{ user.name }}</span\n          >\n        </div>\n      </ng-template>\n    </div>\n  </div>\n</ng-template>\n", dependencies: [{ kind: "directive", type: i4.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i4.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i4.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: i4.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "component", type: AvatarPlaceholderComponent, selector: "stream-avatar-placeholder", inputs: ["name", "imageUrl", "location", "channel", "user", "type", "initialsType", "showOnlineIndicator"] }, { kind: "component", type: LoadingIndicatorComponent, selector: "stream-loading-indicator" }, { kind: "component", type: ModalComponent, selector: "stream-modal", inputs: ["isOpen", "content"], outputs: ["isOpenChange"] }, { kind: "pipe", type: i4.AsyncPipe, name: "async" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: MessageReactionsComponent, decorators: [{
            type: Component,
            args: [{ selector: 'stream-message-reactions', template: "<div\n  *ngIf=\"existingReactions.length > 0\"\n  data-testid=\"reaction-list\"\n  class=\"str-chat__reaction-list str-chat__message-reactions-container\"\n  [class.str-chat__reaction-list--reverse]=\"true\"\n>\n  <ul class=\"str-chat__message-reactions\">\n    <li\n      *ngFor=\"\n        let reactionType of existingReactions;\n        trackBy: trackByMessageReaction\n      \"\n      class=\"str-chat__message-reaction\"\n      data-testclass=\"emoji\"\n      [ngStyle]=\"{ cursor: shouldHandleReactionClick ? 'pointer' : 'default' }\"\n      [class.str-chat__message-reaction-own]=\"isOwnReaction(reactionType)\"\n      (click)=\"reactionSelected(reactionType)\"\n      (keyup.enter)=\"reactionSelected(reactionType)\"\n    >\n      <span class=\"emoji str-chat__message-reaction-emoji\">\n        {{ getEmojiByReaction(reactionType) }}&nbsp;\n      </span>\n      <span\n        data-testclass=\"reaction-list-reaction-count\"\n        class=\"str-chat__message-reaction-count\"\n      >\n        {{ messageReactionCounts[reactionType] }}\n      </span>\n    </li>\n    <li>\n      <span\n        data-testid=\"reactions-count\"\n        class=\"str-chat__reaction-list--counter\"\n        >{{ reactionsCount }}</span\n      >\n    </li>\n  </ul>\n</div>\n\n<ng-container *ngIf=\"selectedReactionType\">\n  <ng-container\n    *ngTemplateOutlet=\"\n      (customTemplatesService.modalTemplate$ | async) || defaultModal;\n      context: {\n        isOpen: !!selectedReactionType,\n        messageId: messageId,\n        reactionType: selectedReactionType,\n        isOpenChangeHandler: isOpenChange,\n        content: modalContent\n      }\n    \"\n  ></ng-container>\n</ng-container>\n\n<ng-template\n  #defaultModal\n  let-isOpen=\"isOpen\"\n  let-messageId=\"messageId\"\n  let-reactionType=\"reactionType\"\n  let-isOpenChangeHandler=\"isOpenChangeHandler\"\n  let-content=\"content\"\n>\n  <stream-modal\n    class=\"str-chat__message-reactions-details-modal\"\n    [isOpen]=\"isOpen\"\n    [content]=\"content\"\n    (isOpenChange)=\"isOpenChangeHandler($event)\"\n  >\n  </stream-modal>\n</ng-template>\n\n<ng-template #modalContent>\n  <div class=\"str-chat__message-reactions-details\">\n    <div class=\"str-chat__message-reactions-details-reaction-types\">\n      <div\n        *ngFor=\"\n          let reactionType of existingReactions;\n          trackBy: trackByMessageReaction\n        \"\n        class=\"str-chat__message-reactions-details-reaction-type\"\n        [ngStyle]=\"{\n          cursor: shouldHandleReactionClick ? 'pointer' : 'default'\n        }\"\n        attr.data-testid=\"reaction-details-selector-{{ reactionType }}\"\n        [class.str-chat__message-reactions-details-reaction-type--selected]=\"\n          reactionType === selectedReactionType\n        \"\n        (click)=\"selectedReactionType = reactionType; allUsers.scrollTop = 0\"\n        (keyup.enter)=\"\n          selectedReactionType = reactionType; allUsers.scrollTop = 0\n        \"\n      >\n        <span class=\"emoji str-chat__message-reaction-emoji\">\n          {{ getEmojiByReaction(reactionType) }}&nbsp;\n        </span>\n        <span class=\"str-chat__message-reaction-count\">\n          {{ messageReactionCounts[reactionType] }}\n        </span>\n      </div>\n    </div>\n    <div\n      class=\"\n        emoji\n        str-chat__message-reaction-emoji str-chat__message-reaction-emoji-big\n      \"\n    >\n      {{ getEmojiByReaction(selectedReactionType!) }}\n    </div>\n    <div\n      #allUsers\n      data-testid=\"all-reacting-users\"\n      class=\"str-chat__message-reactions-details-reacting-users\"\n    >\n      <stream-loading-indicator\n        *ngIf=\"isLoading; else reactions\"\n      ></stream-loading-indicator>\n      <ng-template #reactions>\n        <div\n          *ngFor=\"\n            let user of getAllUsersByReaction(selectedReactionType);\n            trackBy: trackByUserId\n          \"\n          class=\"str-chat__message-reactions-details-reacting-user\"\n        >\n          <stream-avatar-placeholder\n            data-testclass=\"avatar\"\n            class=\"str-chat__avatar str-chat__avatar--circle\"\n            type=\"user\"\n            location=\"reaction\"\n            [imageUrl]=\"user.image\"\n            [name]=\"user.name\"\n            [user]=\"user\"\n          ></stream-avatar-placeholder>\n          <span\n            data-testclass=\"reaction-user-username\"\n            class=\"str-chat__user-item--name\"\n            >{{ user.name }}</span\n          >\n        </div>\n      </ng-template>\n    </div>\n  </div>\n</ng-template>\n" }]
        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }, { type: ChannelService }, { type: MessageReactionsService }, { type: CustomTemplatesService }]; }, propDecorators: { messageId: [{
                type: Input
            }], messageReactionCounts: [{
                type: Input
            }], latestReactions: [{
                type: Input
            }], ownReactions: [{
                type: Input
            }], selectorContainer: [{
                type: ViewChild,
                args: ['selectorContainer']
            }] } });

/**
 * The `Message` component displays a message with additional information such as sender and date, and enables [interaction with the message (i.e. edit or react)](../concepts/message-interactions.mdx).
 */
class MessageComponent {
    constructor(chatClientService, channelService, customTemplatesService, cdRef, dateParser, messageService, messageActionsService, ngZone) {
        this.chatClientService = chatClientService;
        this.channelService = channelService;
        this.customTemplatesService = customTemplatesService;
        this.cdRef = cdRef;
        this.dateParser = dateParser;
        this.messageService = messageService;
        this.messageActionsService = messageActionsService;
        this.ngZone = ngZone;
        /**
         * The list of [channel capabilities](https://getstream.io/chat/docs/javascript/channel_capabilities/?language=javascript) that are enabled for the current user, the list of [supported interactions](../concepts/message-interactions.mdx) can be found in our message interaction guide. Unathorized actions won't be displayed on the UI. The [`MessageList`](./MessageListComponent.mdx) component automatically sets this based on [channel capabilities](https://getstream.io/chat/docs/javascript/channel_capabilities/?language=javascript).
         */
        this.enabledMessageActions = [];
        /**
         * Determines if the message is being dispalyed in a channel or in a [thread](https://getstream.io/chat/docs/javascript/threads/?language=javascript).
         */
        this.mode = 'main';
        /**
         * Highlighting is used to add visual emphasize to a message when jumping to the message
         */
        this.isHighlighted = false;
        this.isEditedFlagOpened = false;
        this.messageTextParts = [];
        this.shouldDisplayTranslationNotice = false;
        this.displayedMessageTextContent = 'original';
        this.imageAttachmentModalState = 'closed';
        this.shouldDisplayThreadLink = false;
        this.isSentByCurrentUser = false;
        this.readByText = '';
        this.lastReadUser = undefined;
        this.isOnlyReadByMe = false;
        this.isReadByMultipleUsers = false;
        this.isMessageDeliveredAndRead = false;
        this.parsedDate = '';
        this.pasedEditedDate = '';
        this.areOptionsVisible = false;
        this.hasAttachment = false;
        this.hasReactions = false;
        this.replyCountParam = {
            replyCount: undefined,
        };
        this.areMessageOptionsOpen = false;
        this.canDisplayReadStatus = false;
        this.hasTouchSupport = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        this.subscriptions = [];
        this.isViewInited = false;
        this.urlRegexp = /(?:(?:https?|ftp|file):\/\/|www\.|ftp\.)(?:\([-A-Z0-9+&@#/%=~_|$?!:,.]*\)|[-A-Z0-9+&@#/%=~_|$?!:,.])*(?:\([-A-Z0-9+&@#/%=~_|$?!:,.]*\)|[A-Z0-9+&@#/%=~_|$])/gim;
        this.emojiRegexp = new RegExp(emojiRegex(), 'g');
        this.shouldPreventMessageMenuClose = false;
        this._visibleMessageActionsCount = 0;
        this.displayAs = this.messageService.displayAs;
    }
    get visibleMessageActionsCount() {
        return this._visibleMessageActionsCount;
    }
    set visibleMessageActionsCount(count) {
        this._visibleMessageActionsCount = count;
        if (this.areOptionsVisible && this._visibleMessageActionsCount === 0) {
            this.areOptionsVisible = false;
        }
    }
    ngOnInit() {
        this.subscriptions.push(this.chatClientService.user$.subscribe((u) => {
            if (u?.id !== this.userId) {
                this.userId = u?.id;
                this.setIsSentByCurrentUser();
                this.setLastReadUser();
                if (this.isViewInited) {
                    this.cdRef.detectChanges();
                }
            }
        }));
        this.subscriptions.push(this.messageActionsService.customActions$.subscribe(() => {
            if (this.message) {
                const numberOfEnabledActions = this.messageActionsService.getAuthorizedMessageActionsCount(this.message, this.enabledMessageActions);
                if (numberOfEnabledActions !== this.visibleMessageActionsCount) {
                    this.visibleMessageActionsCount = numberOfEnabledActions;
                    if (this.isViewInited) {
                        this.cdRef.detectChanges();
                    }
                }
            }
        }));
    }
    ngOnChanges(changes) {
        if (changes.message) {
            this.shouldDisplayTranslationNotice = false;
            this.displayedMessageTextContent = 'original';
            this.createMessageParts();
            const originalAttachments = this.message?.quoted_message?.attachments;
            this.quotedMessageAttachments =
                originalAttachments && originalAttachments.length
                    ? [originalAttachments[0]]
                    : [];
            this.setIsSentByCurrentUser();
            this.setLastReadUser();
            this.readByText = this.message?.readBy
                ? listUsers(this.message.readBy)
                : '';
            this.isOnlyReadByMe = !!(this.message &&
                this.message.readBy &&
                this.message.readBy.length === 0);
            this.isReadByMultipleUsers = !!(this.message &&
                this.message.readBy &&
                this.message.readBy.length > 1);
            this.isMessageDeliveredAndRead = !!(this.message &&
                this.message.readBy &&
                this.message.status === 'received' &&
                this.message.readBy.length > 0);
            this.parsedDate =
                (this.message &&
                    this.message.created_at &&
                    this.dateParser.parseDateTime(this.message.created_at)) ||
                    '';
            this.pasedEditedDate =
                (this.message &&
                    this.message.message_text_updated_at &&
                    this.dateParser.parseDateTime(new Date(this.message.message_text_updated_at))) ||
                    '';
            this.hasAttachment =
                !!this.message?.attachments && !!this.message.attachments.length;
            this.hasReactions =
                !!this.message?.reaction_counts &&
                    Object.keys(this.message.reaction_counts).length > 0;
            this.replyCountParam = { replyCount: this.message?.reply_count };
        }
        if (changes.enabledMessageActions) {
            this.canReactToMessage =
                this.enabledMessageActions.indexOf('send-reaction') !== -1;
            this.canReceiveReadEvents =
                this.enabledMessageActions.indexOf('read-events') !== -1;
            this.canDisplayReadStatus =
                this.canReceiveReadEvents !== false &&
                    this.enabledMessageActions.indexOf('read-events') !== -1;
        }
        if (changes.message || changes.enabledMessageActions || changes.mode) {
            this.shouldDisplayThreadLink =
                !!this.message?.reply_count && this.mode !== 'thread';
        }
        if (changes.message || changes.mode || changes.enabledMessageActions) {
            this.areOptionsVisible = this.message
                ? !(!this.message.type ||
                    this.message.type === 'error' ||
                    this.message.type === 'system' ||
                    this.message.type === 'deleted' ||
                    this.message.type === 'ephemeral' ||
                    this.message.status === 'failed' ||
                    this.message.status === 'sending' ||
                    (this.mode === 'thread' && !this.message.parent_id) ||
                    this.message.deleted_at ||
                    this.enabledMessageActions.length === 0)
                : false;
        }
        if (changes.message || changes.enabledMessageActions) {
            if (this.message) {
                this.visibleMessageActionsCount =
                    this.messageActionsService.getAuthorizedMessageActionsCount(this.message, this.enabledMessageActions);
            }
            else {
                this.visibleMessageActionsCount = 0;
            }
        }
    }
    ngAfterViewInit() {
        this.isViewInited = true;
        if (this.hasTouchSupport && this.messageBubble?.nativeElement) {
            this.ngZone.runOutsideAngular(() => {
                this.registerMenuTriggerEventHandlers();
            });
        }
    }
    ngOnDestroy() {
        this.subscriptions.forEach((s) => s.unsubscribe());
    }
    mousePushedDown(event) {
        if (!this.hasTouchSupport ||
            event.button !== 0 ||
            !this.areOptionsVisible) {
            return;
        }
        this.startMessageMenuShowTimer({ fromTouch: false });
    }
    mouseReleased() {
        this.stopMessageMenuShowTimer();
    }
    touchStarted() {
        if (!this.areOptionsVisible) {
            return;
        }
        this.startMessageMenuShowTimer({ fromTouch: true });
    }
    touchEnded() {
        this.stopMessageMenuShowTimer();
    }
    messageBubbleClicked(event) {
        if (!this.hasTouchSupport) {
            return;
        }
        if (this.shouldPreventMessageMenuClose) {
            event.stopPropagation();
            this.shouldPreventMessageMenuClose = false;
        }
        else if (this.areMessageOptionsOpen) {
            this.messageMenuTrigger?.hide();
        }
    }
    messageOptionsButtonClicked() {
        if (!this.message) {
            return;
        }
        if (this.messageActionsService.customActionClickHandler) {
            this.messageActionsService.customActionClickHandler({
                message: this.message,
                enabledActions: this.enabledMessageActions,
                customActions: this.messageActionsService.customActions$.getValue(),
                isMine: this.isSentByCurrentUser,
                messageTextHtmlElement: this.messageTextElement?.nativeElement,
            });
        }
        else {
            this.areMessageOptionsOpen = !this.areMessageOptionsOpen;
        }
    }
    messageActionsBoxClicked(floatingContent) {
        floatingContent.hide();
    }
    getAttachmentListContext() {
        return {
            messageId: this.message?.id || '',
            attachments: this.message?.attachments || [],
            parentMessageId: this.message?.parent_id,
            imageModalStateChangeHandler: (state) => (this.imageAttachmentModalState = state),
        };
    }
    getMessageContext() {
        return {
            message: this.message,
            enabledMessageActions: this.enabledMessageActions,
            isHighlighted: this.isHighlighted,
            isLastSentMessage: this.isLastSentMessage,
            mode: this.mode,
            customActions: this.messageActionsService.customActions$.getValue(),
            parsedDate: this.parsedDate,
            scroll$: this.scroll$,
        };
    }
    getQuotedMessageAttachmentListContext() {
        return {
            messageId: this.message?.quoted_message?.id || '',
            attachments: this.quotedMessageAttachments,
            parentMessageId: this?.message?.quoted_message?.parent_id,
        };
    }
    getMessageReactionsContext() {
        return {
            messageReactionCounts: this.message?.reaction_counts || {},
            latestReactions: this.message?.latest_reactions || [],
            messageId: this.message?.id,
            ownReactions: this.message?.own_reactions || [],
        };
    }
    messageClicked() {
        if (this.message?.status === 'failed' &&
            this.message?.errorStatusCode !== 403) {
            this.resendMessage();
        }
        else if (this.message?.type === 'error' &&
            this.message?.moderation_details) {
            this.openMessageBouncePrompt();
        }
        else {
            this.isEditedFlagOpened = !this.isEditedFlagOpened;
        }
    }
    resendMessage() {
        void this.channelService.resendMessage(this.message);
    }
    setAsActiveParentMessage() {
        void this.channelService.setAsActiveParentMessage(this.message);
    }
    getMentionContext(messagePart) {
        return {
            content: messagePart.content,
            user: messagePart.user,
        };
    }
    getMessageActionsBoxContext() {
        return {
            isMine: this.isSentByCurrentUser,
            enabledActions: this.enabledMessageActions,
            message: this.message,
            messageTextHtmlElement: this.messageTextElement?.nativeElement,
        };
    }
    getDeliveredStatusContext() {
        return {
            message: this.message,
        };
    }
    getSendingStatusContext() {
        return {
            message: this.message,
        };
    }
    getReadStatusContext() {
        return {
            message: this.message,
            readByText: this.readByText,
        };
    }
    getMessageMetadataContext() {
        return {
            message: this.message,
        };
    }
    jumpToMessage(messageId, parentMessageId) {
        void this.channelService.jumpToMessage(messageId, parentMessageId);
    }
    displayTranslatedMessage() {
        this.createMessageParts(true);
    }
    displayOriginalMessage() {
        this.createMessageParts(false);
    }
    openMessageBouncePrompt() {
        this.channelService.bouncedMessage$.next(this.message);
    }
    createMessageParts(shouldTranslate = true) {
        this.messageTextParts = undefined;
        this.messageText = undefined;
        let content = this.getMessageContent(shouldTranslate);
        if ((!this.message.mentioned_users ||
            this.message.mentioned_users.length === 0) &&
            !content?.match(this.emojiRegexp) &&
            !content?.match(this.urlRegexp)) {
            this.messageTextParts = undefined;
            this.messageText = content;
            return;
        }
        if (!content) {
            return;
        }
        if (!this.message.mentioned_users ||
            this.message.mentioned_users.length === 0) {
            content = this.fixEmojiDisplay(content);
            content = this.wrapLinksWithAnchorTag(content);
            this.messageTextParts = [{ content, type: 'text' }];
        }
        else {
            this.messageTextParts = [];
            let text = content;
            this.message.mentioned_users.forEach((user) => {
                const mention = `@${user.name || user.id}`;
                const precedingText = text.substring(0, text.indexOf(mention));
                let formattedPrecedingText = this.fixEmojiDisplay(precedingText);
                formattedPrecedingText = this.wrapLinksWithAnchorTag(formattedPrecedingText);
                this.messageTextParts.push({
                    content: formattedPrecedingText,
                    type: 'text',
                });
                this.messageTextParts.push({
                    content: mention,
                    type: 'mention',
                    user,
                });
                text = text.replace(precedingText + mention, '');
            });
            if (text) {
                text = this.fixEmojiDisplay(text);
                text = this.wrapLinksWithAnchorTag(text);
                this.messageTextParts.push({ content: text, type: 'text' });
            }
        }
    }
    getMessageContent(shouldTranslate) {
        const originalContent = this.message?.text;
        if (shouldTranslate) {
            const translation = this.message?.translation;
            if (translation) {
                this.shouldDisplayTranslationNotice = true;
                this.displayedMessageTextContent = 'translation';
            }
            return translation || originalContent;
        }
        else {
            this.displayedMessageTextContent = 'original';
            return originalContent;
        }
    }
    fixEmojiDisplay(content) {
        // Wrap emojis in span to display emojis correctly in Chrome https://bugs.chromium.org/p/chromium/issues/detail?id=596223
        // Based on this: https://stackoverflow.com/questions/4565112/javascript-how-to-find-out-if-the-user-browser-is-chrome
        /* eslint-disable @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any */
        const isChrome = !!window.chrome && typeof window.opr === 'undefined';
        /* eslint-enable @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any */
        content = content.replace(this.emojiRegexp, (match) => `<span ${isChrome ? 'class="str-chat__emoji-display-fix"' : ''}>${match}</span>`);
        return content;
    }
    wrapLinksWithAnchorTag(content) {
        if (this.displayAs === 'html') {
            return content;
        }
        content = content.replace(this.urlRegexp, (match) => this.messageService.customLinkRenderer
            ? this.messageService.customLinkRenderer(match)
            : `<a href="${match}" target="_blank" rel="nofollow">${match}</a>`);
        return content;
    }
    setIsSentByCurrentUser() {
        this.isSentByCurrentUser = this.message?.user?.id === this.userId;
    }
    setLastReadUser() {
        this.lastReadUser = this.message?.readBy?.filter((u) => u.id !== this.userId)[0];
    }
    startMessageMenuShowTimer(options) {
        this.stopMessageMenuShowTimer();
        if (this.scroll$) {
            this.subscriptions.push(this.scroll$.pipe(take$1(1)).subscribe(() => {
                this.stopMessageMenuShowTimer();
            }));
        }
        this.showMessageMenuTimeout = setTimeout(() => {
            if (!this.message) {
                return;
            }
            this.ngZone.run(() => {
                if (this.messageActionsService.customActionClickHandler) {
                    this.messageActionsService.customActionClickHandler({
                        message: this.message,
                        enabledActions: this.enabledMessageActions,
                        customActions: this.messageActionsService.customActions$.getValue(),
                        isMine: this.isSentByCurrentUser,
                        messageTextHtmlElement: this.messageTextElement?.nativeElement,
                    });
                    return;
                }
                else {
                    this.shouldPreventMessageMenuClose = !options.fromTouch;
                    this.messageMenuTrigger?.show();
                }
                if (this.isViewInited) {
                    this.cdRef.detectChanges();
                }
                this.showMessageMenuTimeout = undefined;
            });
        }, 400);
    }
    registerMenuTriggerEventHandlers() {
        this.messageBubble.nativeElement.addEventListener('touchstart', () => this.touchStarted());
        this.messageBubble.nativeElement.addEventListener('touchend', () => this.touchEnded());
        this.messageBubble.nativeElement.addEventListener('mousedown', (e) => this.mousePushedDown(e));
        this.messageBubble.nativeElement.addEventListener('mouseup', () => this.mouseReleased());
        this.messageBubble.nativeElement.addEventListener('click', (e) => this.messageBubbleClicked(e));
    }
    stopMessageMenuShowTimer() {
        if (this.showMessageMenuTimeout) {
            clearTimeout(this.showMessageMenuTimeout);
            this.showMessageMenuTimeout = undefined;
        }
    }
}
MessageComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: MessageComponent, deps: [{ token: ChatClientService }, { token: ChannelService }, { token: CustomTemplatesService }, { token: i0.ChangeDetectorRef }, { token: DateParserService }, { token: MessageService }, { token: MessageActionsService }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component });
MessageComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.0.4", type: MessageComponent, selector: "stream-message", inputs: { message: "message", enabledMessageActions: "enabledMessageActions", isLastSentMessage: "isLastSentMessage", mode: "mode", isHighlighted: "isHighlighted", scroll$: "scroll$" }, viewQueries: [{ propertyName: "messageMenuTrigger", first: true, predicate: ["messageMenuTrigger"], descendants: true }, { propertyName: "messageMenuFloat", first: true, predicate: ["messageMenuFloat"], descendants: true }, { propertyName: "messageTextElement", first: true, predicate: ["messageTextElement"], descendants: true }, { propertyName: "messageBubble", first: true, predicate: ["messageBubble"], descendants: true }], usesOnChanges: true, ngImport: i0, template: "<div\n  #container\n  data-testid=\"message-container\"\n  class=\"str-chat__message-simple str-chat__message str-chat__message--{{\n    message?.type\n  }} str-chat__message--{{ message?.status }} {{\n    message?.text ? 'str-chat__message--has-text' : 'has-no-text'\n  }} str-chat__message-menu-{{ areMessageOptionsOpen ? 'opened' : 'closed' }}\"\n  [class.str-chat__message--me]=\"isSentByCurrentUser\"\n  [class.str-chat__message--other]=\"!isSentByCurrentUser\"\n  [class.str-chat__message-simple--me]=\"isSentByCurrentUser\"\n  [class.str-chat__message--has-attachment]=\"hasAttachment\"\n  [class.str-chat__message--with-reactions]=\"hasReactions\"\n  [class.str-chat__message--highlighted]=\"isHighlighted\"\n  [class.str-chat__message-with-thread-link]=\"shouldDisplayThreadLink\"\n  [class.str-chat__message-send-can-be-retried]=\"\n    (message?.status === 'failed' && message?.errorStatusCode !== 403) ||\n    (message?.type === 'error' && message?.moderation_details)\n  \"\n  [class.str-chat__message-with-touch-support]=\"hasTouchSupport\"\n  [class.str-chat__message-without-touch-support]=\"!hasTouchSupport\"\n>\n  <ng-container *ngIf=\"!message?.deleted_at; else deletedMessage\">\n    <ng-container *ngIf=\"message?.type !== 'system'; else systemMessage\">\n      <stream-avatar-placeholder\n        data-testid=\"avatar\"\n        class=\"str-chat-angular__avatar-host str-chat__message-sender-avatar\"\n        type=\"user\"\n        location=\"message-sender\"\n        [imageUrl]=\"message?.user?.image\"\n        [name]=\"message?.user?.name || message?.user?.id\"\n        [user]=\"message?.user || undefined\"\n      ></stream-avatar-placeholder>\n      <div class=\"str-chat__message-inner\">\n        <div\n          *ngIf=\"!hasTouchSupport && areOptionsVisible\"\n          class=\"str-chat__message-simple__actions str-chat__message-options\"\n          data-testid=\"message-options\"\n          [class.str-chat__message-actions-open]=\"areMessageOptionsOpen\"\n        >\n          <div\n            #messageActionsToggle\n            data-testid=\"message-actions-container\"\n            class=\"\n              str-chat__message-actions-container\n              str-chat__message-simple__actions__action\n              str-chat__message-simple__actions__action--options\n            \"\n            [floatUiLoose]=\"messageMenuFloat\"\n            [looseTrigger]=\"\n              messageActionsService.customActionClickHandler ? 'none' : 'click'\n            \"\n            [hideOnScroll]=\"false\"\n            [hideOnClickOutside]=\"true\"\n            [hideOnMouseLeave]=\"false\"\n            [disableAnimation]=\"false\"\n            [preventOverflow]=\"true\"\n            [positionFixed]=\"true\"\n            (onSHown)=\"areMessageOptionsOpen = true\"\n            (onHidden)=\"areMessageOptionsOpen = false\"\n          >\n            <div\n              *ngIf=\"visibleMessageActionsCount > 0\"\n              class=\"str-chat__message-actions-box-button\"\n              data-testid=\"message-options-button\"\n              (click)=\"messageOptionsButtonClicked()\"\n              (keyup.enter)=\"messageOptionsButtonClicked()\"\n            >\n              <stream-icon-placeholder\n                icon=\"action\"\n                class=\"str-chat__message-action-icon\"\n              ></stream-icon-placeholder>\n            </div>\n          </div>\n        </div>\n        <div class=\"str-chat__message-reactions-host\">\n          <ng-template\n            #defaultMessageReactions\n            let-messageReactionCounts=\"messageReactionCounts\"\n            let-latestReactions=\"latestReactions\"\n            let-messageId=\"messageId\"\n            let-ownReactions=\"ownReactions\"\n          >\n            <stream-message-reactions\n              [messageReactionCounts]=\"messageReactionCounts\"\n              [latestReactions]=\"latestReactions\"\n              [messageId]=\"messageId\"\n              [ownReactions]=\"ownReactions\"\n            ></stream-message-reactions>\n          </ng-template>\n          <ng-container\n            *ngTemplateOutlet=\"\n              (customTemplatesService.messageReactionsTemplate$ | async) ||\n                defaultMessageReactions;\n              context: getMessageReactionsContext()\n            \"\n          ></ng-container>\n        </div>\n        <float-ui-content #messageMenuFloat>\n          <ng-template\n            #defaultMessageActionsBox\n            let-isMine=\"isMine\"\n            let-messageInput=\"message\"\n            let-enabledActions=\"enabledActions\"\n            let-messageTextHtmlElement=\"messageTextHtmlElement\"\n          >\n            <stream-message-actions-box\n              [isMine]=\"isMine\"\n              [message]=\"messageInput\"\n              [enabledActions]=\"enabledActions\"\n              [messageTextHtmlElement]=\"messageTextHtmlElement\"\n              (click)=\"messageActionsBoxClicked(messageMenuFloat)\"\n            ></stream-message-actions-box>\n          </ng-template>\n          <ng-container>\n            <ng-container\n              *ngTemplateOutlet=\"\n                (customTemplatesService.messageActionsBoxTemplate$ | async) ||\n                  defaultMessageActionsBox;\n                context: getMessageActionsBoxContext()\n              \"\n            >\n            </ng-container>\n          </ng-container>\n        </float-ui-content>\n        <div\n          class=\"str-chat__message-bubble str-chat-angular__message-bubble\"\n          [class.str-chat-angular__message-bubble--attachment-modal-open]=\"\n            imageAttachmentModalState === 'opened'\n          \"\n          data-testid=\"message-bubble\"\n          [floatUiLoose]=\"messageMenuFloat\"\n          #messageMenuTrigger=\"floatUiLoose\"\n          #messageBubble\n          looseTrigger=\"none\"\n          [hideOnScroll]=\"false\"\n          [hideOnClickOutside]=\"true\"\n          [hideOnMouseLeave]=\"false\"\n          [disableAnimation]=\"true\"\n          [preventOverflow]=\"true\"\n          (onShown)=\"areMessageOptionsOpen = true\"\n          (onHidden)=\"areMessageOptionsOpen = false\"\n          [positionFixed]=\"true\"\n        >\n          <ng-container *ngIf=\"hasAttachment && !message?.quoted_message\">\n            <div class=\"str-chat__attachments-container\">\n              <ng-container\n                *ngTemplateOutlet=\"attachmentsTemplate\"\n              ></ng-container>\n            </div>\n          </ng-container>\n          <div\n            *ngIf=\"message?.text || (message?.quoted_message && hasAttachment)\"\n            class=\"str-chat__message-text\"\n            tabindex=\"0\"\n            [class.str-chat__message-text--pointer-cursor]=\"\n              (message?.status === 'failed' &&\n                message?.errorStatusCode !== 403) ||\n              (this.message?.type === 'error' &&\n                this.message?.moderation_details) ||\n              message?.message_text_updated_at\n            \"\n            (click)=\"messageClicked()\"\n            (keyup.enter)=\"messageClicked()\"\n          >\n            <div\n              data-testid=\"inner-message\"\n              class=\"\n                str-chat__message-text-inner str-chat__message-simple-text-inner\n              \"\n              [class.str-chat__message-light-text-inner--has-attachment]=\"\n                hasAttachment\n              \"\n            >\n              <ng-container *ngTemplateOutlet=\"quotedMessage\"></ng-container>\n              <ng-container *ngIf=\"hasAttachment && message?.quoted_message\">\n                <ng-container\n                  *ngTemplateOutlet=\"attachmentsTemplate\"\n                ></ng-container>\n              </ng-container>\n              <div\n                *ngIf=\"message?.type === 'error'\"\n                data-testid=\"client-error-message\"\n                class=\"\n                  str-chat__simple-message--error-message\n                  str-chat__message--error-message\n                \"\n              >\n                <ng-container *ngIf=\"!message?.moderation_details\">{{\n                  \"streamChat.Error \u00B7 Unsent\" | translate\n                }}</ng-container>\n              </div>\n              <div\n                *ngIf=\"message?.status === 'failed'\"\n                data-testid=\"error-message\"\n                class=\"\n                  str-chat__simple-message--error-message\n                  str-chat__message--error-message\n                \"\n              >\n                {{\n                  (message?.errorStatusCode === 403\n                    ? \"streamChat.Message Failed \u00B7 Unauthorized\"\n                    : \"streamChat.Message Failed \u00B7 Click to try again\"\n                  ) | translate\n                }}\n              </div>\n              <div #messageTextElement data-testid=\"text\">\n                <p>\n                  <ng-container *ngIf=\"messageTextParts; else defaultContent\">\n                    <!-- eslint-disable-next-line @angular-eslint/template/use-track-by-function -->\n                    <ng-container *ngFor=\"let part of messageTextParts\">\n                      <span\n                        *ngIf=\"part.type === 'text'; else mention\"\n                        [innerHTML]=\"part.content\"\n                      ></span>\n                      <ng-template #mention>\n                        <ng-template #defaultMention let-content=\"content\">\n                          <span class=\"str-chat__message-mention\">{{\n                            content\n                          }}</span>\n                        </ng-template>\n                        <ng-container\n                          *ngTemplateOutlet=\"\n                            (customTemplatesService.mentionTemplate$ | async) ||\n                              defaultMention;\n                            context: getMentionContext(part)\n                          \"\n                        ></ng-container>\n                      </ng-template>\n                    </ng-container>\n                  </ng-container>\n                  <ng-template #defaultContent>\n                    <ng-container *ngIf=\"displayAs === 'text'; else asHTML\">\n                      {{ messageText || \"\" }}\n                    </ng-container>\n                    <ng-template #asHTML\n                      ><span\n                        data-testid=\"html-content\"\n                        [innerHTML]=\"messageText\"\n                      ></span\n                    ></ng-template>\n                  </ng-template>\n                </p>\n              </div>\n            </div>\n          </div>\n          <stream-icon-placeholder\n            class=\"str-chat__message-error-icon\"\n            icon=\"error\"\n          ></stream-icon-placeholder>\n        </div>\n      </div>\n      <ng-container\n        *ngTemplateOutlet=\"replyCountButton; context: { message: message }\"\n      ></ng-container>\n\n      <ng-container *ngTemplateOutlet=\"messageDateAndSender\"></ng-container>\n    </ng-container>\n  </ng-container>\n</div>\n\n<ng-template #deletedMessage>\n  <div data-testid=\"message-deleted-component\">\n    <div class=\"str-chat__message--deleted-inner\" translate>\n      streamChat.This message was deleted...\n    </div>\n  </div>\n</ng-template>\n\n<ng-template #systemMessage>\n  <ng-container\n    *ngTemplateOutlet=\"\n      (customTemplatesService.systemMessageTemplate$ | async) ||\n        defaultSystemMessage;\n      context: getMessageContext()\n    \"\n  ></ng-container>\n  <ng-template #defaultSystemMessage let-messageInput=\"message\">\n    <div data-testid=\"system-message\" class=\"str-chat__message--system\">\n      <div class=\"str-chat__message--system__text\">\n        <div class=\"str-chat__message--system__line\"></div>\n        <p>{{ messageInput?.text }}</p>\n        <div class=\"str-chat__message--system__line\"></div>\n      </div>\n      <div class=\"str-chat__message--system__date\">\n        {{ parsedDate }}\n      </div>\n    </div>\n  </ng-template>\n</ng-template>\n\n<ng-template #quotedMessage>\n  <div\n    *ngIf=\"message?.quoted_message\"\n    class=\"quoted-message str-chat__quoted-message-preview\"\n    data-testid=\"quoted-message-container\"\n    [class.mine]=\"isSentByCurrentUser\"\n    (click)=\"\n      jumpToMessage(\n        (message?.quoted_message)!.id,\n        message?.quoted_message?.parent_id\n      )\n    \"\n    (keyup.enter)=\"\n      jumpToMessage(\n        (message?.quoted_message)!.id,\n        message?.quoted_message?.parent_id\n      )\n    \"\n  >\n    <stream-avatar-placeholder\n      data-testid=\"qouted-message-avatar\"\n      class=\"str-chat-angular__avatar-host str-chat__message-sender-avatar\"\n      type=\"user\"\n      location=\"quoted-message-sender\"\n      [imageUrl]=\"message?.quoted_message?.user?.image\"\n      [name]=\"\n        message?.quoted_message?.user?.name || message?.quoted_message?.user?.id\n      \"\n      [user]=\"message?.quoted_message?.user || undefined\"\n    ></stream-avatar-placeholder>\n    <div class=\"quoted-message-inner str-chat__quoted-message-bubble\">\n      <ng-container\n        *ngIf=\"\n          message?.quoted_message?.attachments &&\n          message?.quoted_message?.attachments?.length\n        \"\n      >\n        <ng-template\n          #defaultAttachments\n          let-messageId=\"messageId\"\n          let-attachments=\"attachments\"\n          let-parentMessageId=\"parentMessageId\"\n          let-imageModalStateChangeHandler=\"imageModalStateChangeHandler\"\n        >\n          <stream-attachment-list\n            [messageId]=\"messageId\"\n            [attachments]=\"attachments\"\n            [parentMessageId]=\"parentMessageId\"\n            (imageModalStateChange)=\"imageModalStateChangeHandler($event)\"\n          ></stream-attachment-list>\n        </ng-template>\n        <ng-container\n          *ngTemplateOutlet=\"\n            (customTemplatesService.attachmentListTemplate$ | async) ||\n              defaultAttachments;\n            context: getQuotedMessageAttachmentListContext()\n          \"\n        ></ng-container>\n      </ng-container>\n      <div\n        data-testid=\"quoted-message-text\"\n        [innerHTML]=\"\n          message?.quoted_message?.translation ||\n          message?.quoted_message?.html ||\n          message?.quoted_message?.text\n        \"\n      ></div>\n    </div>\n  </div>\n</ng-template>\n\n<ng-template #messageDateAndSender>\n  <ng-container>\n    <div\n      *ngIf=\"shouldDisplayTranslationNotice\"\n      class=\"str-chat__translation-notice\"\n      data-testid=\"translation-notice\"\n    >\n      <button\n        *ngIf=\"displayedMessageTextContent === 'translation'\"\n        data-testid=\"see-original\"\n        translate\n        (click)=\"displayOriginalMessage()\"\n        (keyup.enter)=\"displayOriginalMessage()\"\n      >\n        streamChat.See original (automatically translated)\n      </button>\n      <button\n        *ngIf=\"displayedMessageTextContent === 'original'\"\n        data-testid=\"see-translation\"\n        translate\n        (click)=\"displayTranslatedMessage()\"\n        (keyup.enter)=\"displayTranslatedMessage()\"\n      >\n        streamChat.See translation\n      </button>\n    </div>\n    <ng-container\n      *ngIf=\"customTemplatesService.customMessageMetadataTemplate$ | async\"\n    >\n      <div class=\"str-chat__custom-message-metadata\">\n        <ng-container\n          *ngTemplateOutlet=\"\n            (customTemplatesService.customMessageMetadataTemplate$ | async)!;\n            context: getMessageMetadataContext()\n          \"\n        ></ng-container>\n      </div>\n    </ng-container>\n    <div\n      class=\"\n        str-chat__message-data\n        str-chat__message-simple-data\n        str-chat__message-metadata\n      \"\n    >\n      <ng-container *ngTemplateOutlet=\"messageStatus\"></ng-container>\n\n      <span\n        *ngIf=\"!isSentByCurrentUser\"\n        data-testid=\"sender\"\n        class=\"str-chat__message-simple-name str-chat__message-sender-name\"\n      >\n        {{ message?.user?.name ? message?.user?.name : message?.user?.id }}\n      </span>\n      <span\n        data-testid=\"date\"\n        class=\"str-chat__message-simple-timestamp str-chat__message-simple-time\"\n      >\n        {{ parsedDate }}\n      </span>\n      <ng-container *ngIf=\"message?.message_text_updated_at\">\n        <span\n          data-testid=\"edited-flag\"\n          class=\"str-chat__mesage-simple-edited\"\n          translate\n          >streamChat.Edited</span\n        >\n        <div\n          data-testid=\"edited-timestamp\"\n          class=\"str-chat__message-edited-timestamp\"\n          [ngClass]=\"{\n            'str-chat__message-edited-timestamp--open': isEditedFlagOpened,\n            'str-chat__message-edited-timestamp--collapsed': !isEditedFlagOpened\n          }\"\n        >\n          <span translate>streamChat.Edited</span>\n          <time\n            dateTime=\"{{ message?.message_text_updated_at }}\"\n            title=\"{{ message?.message_text_updated_at }}\"\n          >\n            {{ pasedEditedDate }}\n          </time>\n        </div>\n      </ng-container>\n    </div>\n  </ng-container>\n</ng-template>\n\n<ng-template #messageStatus>\n  <ng-container\n    *ngIf=\"\n      isSentByCurrentUser &&\n      ((isLastSentMessage && message?.status === 'received') ||\n        message?.status === 'sending')\n    \"\n  >\n    <ng-container *ngIf=\"message?.status === 'sending'; else sentStatus\">\n      <ng-container *ngTemplateOutlet=\"sendingStatus\"></ng-container>\n    </ng-container>\n    <ng-template #sentStatus>\n      <ng-container\n        *ngIf=\"\n          mode === 'main' && isMessageDeliveredAndRead && canDisplayReadStatus;\n          else deliveredStatus\n        \"\n      >\n        <ng-container *ngTemplateOutlet=\"readStatus\"></ng-container>\n      </ng-container>\n    </ng-template>\n    <ng-template #deliveredStatus>\n      <ng-container\n        *ngTemplateOutlet=\"\n          (customTemplatesService.deliveredStatusTemplate$ | async) ||\n            defaultDeliveredStatus;\n          context: getDeliveredStatusContext()\n        \"\n      ></ng-container>\n    </ng-template>\n    <ng-template #defaultDeliveredStatus>\n      <span\n        *ngIf=\"mode === 'main'\"\n        class=\"\n          str-chat__message-simple-status\n          str-chat__message-simple-status-angular\n          str-chat__message-status\n        \"\n        data-testid=\"delivered-indicator\"\n        tabindex=\"0\"\n        [floatUiLoose]=\"floatingContent\"\n        loosePlacement=\"top\"\n        [looseTrigger]=\"hasTouchSupport ? 'click' : 'hover'\"\n        [disableAnimation]=\"true\"\n        [hideOnClickOutside]=\"true\"\n        [positionFixed]=\"true\"\n        [preventOverflow]=\"true\"\n      >\n        <float-ui-content #floatingContent>\n          <div class=\"str-chat__tooltip str-chat__tooltip-angular\">\n            {{ \"streamChat.Delivered\" | translate }}\n          </div>\n        </float-ui-content>\n        <stream-icon-placeholder\n          data-testid=\"delivered-icon\"\n          icon=\"delivered\"\n        ></stream-icon-placeholder>\n      </span>\n    </ng-template>\n    <ng-template #sendingStatus>\n      <ng-container\n        *ngTemplateOutlet=\"\n          (customTemplatesService.sendingStatusTemplate$ | async) ||\n            defaultSendingStatus;\n          context: getSendingStatusContext()\n        \"\n      ></ng-container>\n    </ng-template>\n    <ng-template #defaultSendingStatus>\n      <span\n        class=\"\n          str-chat__message-simple-status\n          str-chat__message-simple-status-angular\n          str-chat__message-status\n        \"\n        data-testid=\"sending-indicator\"\n        tabindex=\"0\"\n        [floatUiLoose]=\"floatingContent\"\n        loosePlacement=\"top\"\n        [looseTrigger]=\"hasTouchSupport ? 'click' : 'hover'\"\n        [disableAnimation]=\"true\"\n        [hideOnClickOutside]=\"true\"\n        [positionFixed]=\"true\"\n        [preventOverflow]=\"true\"\n      >\n        <float-ui-content #floatingContent>\n          <div class=\"str-chat__tooltip str-chat__tooltip-angular\">\n            {{ \"streamChat.Sending...\" | translate }}\n          </div>\n        </float-ui-content>\n        <stream-loading-indicator-placeholder\n          data-testid=\"loading-indicator\"\n        ></stream-loading-indicator-placeholder>\n      </span>\n    </ng-template>\n    <ng-template #readStatus>\n      <ng-container\n        *ngTemplateOutlet=\"\n          (customTemplatesService.readStatusTemplate$ | async) ||\n            defaultReadStatus;\n          context: getReadStatusContext()\n        \"\n      ></ng-container>\n    </ng-template>\n    <ng-template #defaultReadStatus let-readByText=\"readByText\">\n      <span\n        class=\"\n          str-chat__message-simple-status\n          str-chat__message-simple-status-angular\n          str-chat__message-status\n        \"\n        data-testid=\"read-indicator\"\n        tabindex=\"0\"\n        [floatUiLoose]=\"floatingContent\"\n        loosePlacement=\"top\"\n        [looseTrigger]=\"hasTouchSupport ? 'click' : 'hover'\"\n        [disableAnimation]=\"true\"\n        [hideOnClickOutside]=\"true\"\n        [positionFixed]=\"true\"\n        [preventOverflow]=\"true\"\n      >\n        <float-ui-content #floatingContent>\n          <div\n            class=\"str-chat__tooltip str-chat__tooltip-angular\"\n            data-testid=\"read-by-tooltip\"\n          >\n            {{ readByText }}\n          </div>\n        </float-ui-content>\n        <stream-icon-placeholder icon=\"read\"></stream-icon-placeholder>\n      </span>\n    </ng-template>\n  </ng-container>\n</ng-template>\n\n<ng-template #replyCountButton>\n  <div\n    class=\"\n      str-chat__message-simple-reply-button\n      str-chat__message-replies-count-button-wrapper\n    \"\n  >\n    <button\n      *ngIf=\"shouldDisplayThreadLink\"\n      class=\"str-chat__message-replies-count-button\"\n      data-testid=\"reply-count-button\"\n      (click)=\"setAsActiveParentMessage()\"\n    >\n      {{message?.reply_count === 1 ? ('streamChat.1 reply' | translate) : ('streamChat.{{ replyCount }}\n      replies' | translate:replyCountParam)}}\n    </button>\n  </div>\n</ng-template>\n\n<ng-template #attachmentsTemplate>\n  <ng-template\n    #defaultAttachments\n    let-messageId=\"messageId\"\n    let-attachments=\"attachments\"\n    let-parentMessageId=\"parentMessageId\"\n    let-imageModalStateChangeHandler=\"imageModalStateChangeHandler\"\n  >\n    <stream-attachment-list\n      [messageId]=\"messageId\"\n      [attachments]=\"attachments\"\n      [parentMessageId]=\"parentMessageId\"\n      (imageModalStateChange)=\"imageModalStateChangeHandler($event)\"\n    ></stream-attachment-list>\n  </ng-template>\n  <ng-container\n    *ngTemplateOutlet=\"\n      (customTemplatesService.attachmentListTemplate$ | async) ||\n        defaultAttachments;\n      context: getAttachmentListContext()\n    \"\n  ></ng-container>\n</ng-template>\n", dependencies: [{ kind: "directive", type: i4.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i4.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i4.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i4.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "component", type: i8.NgxFloatUiContentComponent, selector: "float-ui-content", exportAs: ["ngxFloatUiContent"] }, { kind: "directive", type: i8.NgxFloatUiLooseDirective, selector: "[floatUiLoose]", inputs: ["floatUiLoose", "loosePlacement", "looseTrigger"], exportAs: ["floatUiLoose"] }, { kind: "component", type: AvatarPlaceholderComponent, selector: "stream-avatar-placeholder", inputs: ["name", "imageUrl", "location", "channel", "user", "type", "initialsType", "showOnlineIndicator"] }, { kind: "directive", type: i10.TranslateDirective, selector: "[translate],[ngx-translate]", inputs: ["translate", "translateParams"] }, { kind: "component", type: MessageActionsBoxComponent, selector: "stream-message-actions-box", inputs: ["isMine", "message", "messageTextHtmlElement", "enabledActions"] }, { kind: "component", type: AttachmentListComponent, selector: "stream-attachment-list", inputs: ["messageId", "parentMessageId", "attachments"], outputs: ["imageModalStateChange"] }, { kind: "component", type: MessageReactionsComponent, selector: "stream-message-reactions", inputs: ["messageId", "messageReactionCounts", "latestReactions", "ownReactions"] }, { kind: "component", type: IconPlaceholderComponent, selector: "stream-icon-placeholder", inputs: ["icon"] }, { kind: "component", type: LoadingIndicatorPlaceholderComponent, selector: "stream-loading-indicator-placeholder" }, { kind: "pipe", type: i4.AsyncPipe, name: "async" }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: MessageComponent, decorators: [{
            type: Component,
            args: [{ selector: 'stream-message', changeDetection: ChangeDetectionStrategy.OnPush, template: "<div\n  #container\n  data-testid=\"message-container\"\n  class=\"str-chat__message-simple str-chat__message str-chat__message--{{\n    message?.type\n  }} str-chat__message--{{ message?.status }} {{\n    message?.text ? 'str-chat__message--has-text' : 'has-no-text'\n  }} str-chat__message-menu-{{ areMessageOptionsOpen ? 'opened' : 'closed' }}\"\n  [class.str-chat__message--me]=\"isSentByCurrentUser\"\n  [class.str-chat__message--other]=\"!isSentByCurrentUser\"\n  [class.str-chat__message-simple--me]=\"isSentByCurrentUser\"\n  [class.str-chat__message--has-attachment]=\"hasAttachment\"\n  [class.str-chat__message--with-reactions]=\"hasReactions\"\n  [class.str-chat__message--highlighted]=\"isHighlighted\"\n  [class.str-chat__message-with-thread-link]=\"shouldDisplayThreadLink\"\n  [class.str-chat__message-send-can-be-retried]=\"\n    (message?.status === 'failed' && message?.errorStatusCode !== 403) ||\n    (message?.type === 'error' && message?.moderation_details)\n  \"\n  [class.str-chat__message-with-touch-support]=\"hasTouchSupport\"\n  [class.str-chat__message-without-touch-support]=\"!hasTouchSupport\"\n>\n  <ng-container *ngIf=\"!message?.deleted_at; else deletedMessage\">\n    <ng-container *ngIf=\"message?.type !== 'system'; else systemMessage\">\n      <stream-avatar-placeholder\n        data-testid=\"avatar\"\n        class=\"str-chat-angular__avatar-host str-chat__message-sender-avatar\"\n        type=\"user\"\n        location=\"message-sender\"\n        [imageUrl]=\"message?.user?.image\"\n        [name]=\"message?.user?.name || message?.user?.id\"\n        [user]=\"message?.user || undefined\"\n      ></stream-avatar-placeholder>\n      <div class=\"str-chat__message-inner\">\n        <div\n          *ngIf=\"!hasTouchSupport && areOptionsVisible\"\n          class=\"str-chat__message-simple__actions str-chat__message-options\"\n          data-testid=\"message-options\"\n          [class.str-chat__message-actions-open]=\"areMessageOptionsOpen\"\n        >\n          <div\n            #messageActionsToggle\n            data-testid=\"message-actions-container\"\n            class=\"\n              str-chat__message-actions-container\n              str-chat__message-simple__actions__action\n              str-chat__message-simple__actions__action--options\n            \"\n            [floatUiLoose]=\"messageMenuFloat\"\n            [looseTrigger]=\"\n              messageActionsService.customActionClickHandler ? 'none' : 'click'\n            \"\n            [hideOnScroll]=\"false\"\n            [hideOnClickOutside]=\"true\"\n            [hideOnMouseLeave]=\"false\"\n            [disableAnimation]=\"false\"\n            [preventOverflow]=\"true\"\n            [positionFixed]=\"true\"\n            (onSHown)=\"areMessageOptionsOpen = true\"\n            (onHidden)=\"areMessageOptionsOpen = false\"\n          >\n            <div\n              *ngIf=\"visibleMessageActionsCount > 0\"\n              class=\"str-chat__message-actions-box-button\"\n              data-testid=\"message-options-button\"\n              (click)=\"messageOptionsButtonClicked()\"\n              (keyup.enter)=\"messageOptionsButtonClicked()\"\n            >\n              <stream-icon-placeholder\n                icon=\"action\"\n                class=\"str-chat__message-action-icon\"\n              ></stream-icon-placeholder>\n            </div>\n          </div>\n        </div>\n        <div class=\"str-chat__message-reactions-host\">\n          <ng-template\n            #defaultMessageReactions\n            let-messageReactionCounts=\"messageReactionCounts\"\n            let-latestReactions=\"latestReactions\"\n            let-messageId=\"messageId\"\n            let-ownReactions=\"ownReactions\"\n          >\n            <stream-message-reactions\n              [messageReactionCounts]=\"messageReactionCounts\"\n              [latestReactions]=\"latestReactions\"\n              [messageId]=\"messageId\"\n              [ownReactions]=\"ownReactions\"\n            ></stream-message-reactions>\n          </ng-template>\n          <ng-container\n            *ngTemplateOutlet=\"\n              (customTemplatesService.messageReactionsTemplate$ | async) ||\n                defaultMessageReactions;\n              context: getMessageReactionsContext()\n            \"\n          ></ng-container>\n        </div>\n        <float-ui-content #messageMenuFloat>\n          <ng-template\n            #defaultMessageActionsBox\n            let-isMine=\"isMine\"\n            let-messageInput=\"message\"\n            let-enabledActions=\"enabledActions\"\n            let-messageTextHtmlElement=\"messageTextHtmlElement\"\n          >\n            <stream-message-actions-box\n              [isMine]=\"isMine\"\n              [message]=\"messageInput\"\n              [enabledActions]=\"enabledActions\"\n              [messageTextHtmlElement]=\"messageTextHtmlElement\"\n              (click)=\"messageActionsBoxClicked(messageMenuFloat)\"\n            ></stream-message-actions-box>\n          </ng-template>\n          <ng-container>\n            <ng-container\n              *ngTemplateOutlet=\"\n                (customTemplatesService.messageActionsBoxTemplate$ | async) ||\n                  defaultMessageActionsBox;\n                context: getMessageActionsBoxContext()\n              \"\n            >\n            </ng-container>\n          </ng-container>\n        </float-ui-content>\n        <div\n          class=\"str-chat__message-bubble str-chat-angular__message-bubble\"\n          [class.str-chat-angular__message-bubble--attachment-modal-open]=\"\n            imageAttachmentModalState === 'opened'\n          \"\n          data-testid=\"message-bubble\"\n          [floatUiLoose]=\"messageMenuFloat\"\n          #messageMenuTrigger=\"floatUiLoose\"\n          #messageBubble\n          looseTrigger=\"none\"\n          [hideOnScroll]=\"false\"\n          [hideOnClickOutside]=\"true\"\n          [hideOnMouseLeave]=\"false\"\n          [disableAnimation]=\"true\"\n          [preventOverflow]=\"true\"\n          (onShown)=\"areMessageOptionsOpen = true\"\n          (onHidden)=\"areMessageOptionsOpen = false\"\n          [positionFixed]=\"true\"\n        >\n          <ng-container *ngIf=\"hasAttachment && !message?.quoted_message\">\n            <div class=\"str-chat__attachments-container\">\n              <ng-container\n                *ngTemplateOutlet=\"attachmentsTemplate\"\n              ></ng-container>\n            </div>\n          </ng-container>\n          <div\n            *ngIf=\"message?.text || (message?.quoted_message && hasAttachment)\"\n            class=\"str-chat__message-text\"\n            tabindex=\"0\"\n            [class.str-chat__message-text--pointer-cursor]=\"\n              (message?.status === 'failed' &&\n                message?.errorStatusCode !== 403) ||\n              (this.message?.type === 'error' &&\n                this.message?.moderation_details) ||\n              message?.message_text_updated_at\n            \"\n            (click)=\"messageClicked()\"\n            (keyup.enter)=\"messageClicked()\"\n          >\n            <div\n              data-testid=\"inner-message\"\n              class=\"\n                str-chat__message-text-inner str-chat__message-simple-text-inner\n              \"\n              [class.str-chat__message-light-text-inner--has-attachment]=\"\n                hasAttachment\n              \"\n            >\n              <ng-container *ngTemplateOutlet=\"quotedMessage\"></ng-container>\n              <ng-container *ngIf=\"hasAttachment && message?.quoted_message\">\n                <ng-container\n                  *ngTemplateOutlet=\"attachmentsTemplate\"\n                ></ng-container>\n              </ng-container>\n              <div\n                *ngIf=\"message?.type === 'error'\"\n                data-testid=\"client-error-message\"\n                class=\"\n                  str-chat__simple-message--error-message\n                  str-chat__message--error-message\n                \"\n              >\n                <ng-container *ngIf=\"!message?.moderation_details\">{{\n                  \"streamChat.Error \u00B7 Unsent\" | translate\n                }}</ng-container>\n              </div>\n              <div\n                *ngIf=\"message?.status === 'failed'\"\n                data-testid=\"error-message\"\n                class=\"\n                  str-chat__simple-message--error-message\n                  str-chat__message--error-message\n                \"\n              >\n                {{\n                  (message?.errorStatusCode === 403\n                    ? \"streamChat.Message Failed \u00B7 Unauthorized\"\n                    : \"streamChat.Message Failed \u00B7 Click to try again\"\n                  ) | translate\n                }}\n              </div>\n              <div #messageTextElement data-testid=\"text\">\n                <p>\n                  <ng-container *ngIf=\"messageTextParts; else defaultContent\">\n                    <!-- eslint-disable-next-line @angular-eslint/template/use-track-by-function -->\n                    <ng-container *ngFor=\"let part of messageTextParts\">\n                      <span\n                        *ngIf=\"part.type === 'text'; else mention\"\n                        [innerHTML]=\"part.content\"\n                      ></span>\n                      <ng-template #mention>\n                        <ng-template #defaultMention let-content=\"content\">\n                          <span class=\"str-chat__message-mention\">{{\n                            content\n                          }}</span>\n                        </ng-template>\n                        <ng-container\n                          *ngTemplateOutlet=\"\n                            (customTemplatesService.mentionTemplate$ | async) ||\n                              defaultMention;\n                            context: getMentionContext(part)\n                          \"\n                        ></ng-container>\n                      </ng-template>\n                    </ng-container>\n                  </ng-container>\n                  <ng-template #defaultContent>\n                    <ng-container *ngIf=\"displayAs === 'text'; else asHTML\">\n                      {{ messageText || \"\" }}\n                    </ng-container>\n                    <ng-template #asHTML\n                      ><span\n                        data-testid=\"html-content\"\n                        [innerHTML]=\"messageText\"\n                      ></span\n                    ></ng-template>\n                  </ng-template>\n                </p>\n              </div>\n            </div>\n          </div>\n          <stream-icon-placeholder\n            class=\"str-chat__message-error-icon\"\n            icon=\"error\"\n          ></stream-icon-placeholder>\n        </div>\n      </div>\n      <ng-container\n        *ngTemplateOutlet=\"replyCountButton; context: { message: message }\"\n      ></ng-container>\n\n      <ng-container *ngTemplateOutlet=\"messageDateAndSender\"></ng-container>\n    </ng-container>\n  </ng-container>\n</div>\n\n<ng-template #deletedMessage>\n  <div data-testid=\"message-deleted-component\">\n    <div class=\"str-chat__message--deleted-inner\" translate>\n      streamChat.This message was deleted...\n    </div>\n  </div>\n</ng-template>\n\n<ng-template #systemMessage>\n  <ng-container\n    *ngTemplateOutlet=\"\n      (customTemplatesService.systemMessageTemplate$ | async) ||\n        defaultSystemMessage;\n      context: getMessageContext()\n    \"\n  ></ng-container>\n  <ng-template #defaultSystemMessage let-messageInput=\"message\">\n    <div data-testid=\"system-message\" class=\"str-chat__message--system\">\n      <div class=\"str-chat__message--system__text\">\n        <div class=\"str-chat__message--system__line\"></div>\n        <p>{{ messageInput?.text }}</p>\n        <div class=\"str-chat__message--system__line\"></div>\n      </div>\n      <div class=\"str-chat__message--system__date\">\n        {{ parsedDate }}\n      </div>\n    </div>\n  </ng-template>\n</ng-template>\n\n<ng-template #quotedMessage>\n  <div\n    *ngIf=\"message?.quoted_message\"\n    class=\"quoted-message str-chat__quoted-message-preview\"\n    data-testid=\"quoted-message-container\"\n    [class.mine]=\"isSentByCurrentUser\"\n    (click)=\"\n      jumpToMessage(\n        (message?.quoted_message)!.id,\n        message?.quoted_message?.parent_id\n      )\n    \"\n    (keyup.enter)=\"\n      jumpToMessage(\n        (message?.quoted_message)!.id,\n        message?.quoted_message?.parent_id\n      )\n    \"\n  >\n    <stream-avatar-placeholder\n      data-testid=\"qouted-message-avatar\"\n      class=\"str-chat-angular__avatar-host str-chat__message-sender-avatar\"\n      type=\"user\"\n      location=\"quoted-message-sender\"\n      [imageUrl]=\"message?.quoted_message?.user?.image\"\n      [name]=\"\n        message?.quoted_message?.user?.name || message?.quoted_message?.user?.id\n      \"\n      [user]=\"message?.quoted_message?.user || undefined\"\n    ></stream-avatar-placeholder>\n    <div class=\"quoted-message-inner str-chat__quoted-message-bubble\">\n      <ng-container\n        *ngIf=\"\n          message?.quoted_message?.attachments &&\n          message?.quoted_message?.attachments?.length\n        \"\n      >\n        <ng-template\n          #defaultAttachments\n          let-messageId=\"messageId\"\n          let-attachments=\"attachments\"\n          let-parentMessageId=\"parentMessageId\"\n          let-imageModalStateChangeHandler=\"imageModalStateChangeHandler\"\n        >\n          <stream-attachment-list\n            [messageId]=\"messageId\"\n            [attachments]=\"attachments\"\n            [parentMessageId]=\"parentMessageId\"\n            (imageModalStateChange)=\"imageModalStateChangeHandler($event)\"\n          ></stream-attachment-list>\n        </ng-template>\n        <ng-container\n          *ngTemplateOutlet=\"\n            (customTemplatesService.attachmentListTemplate$ | async) ||\n              defaultAttachments;\n            context: getQuotedMessageAttachmentListContext()\n          \"\n        ></ng-container>\n      </ng-container>\n      <div\n        data-testid=\"quoted-message-text\"\n        [innerHTML]=\"\n          message?.quoted_message?.translation ||\n          message?.quoted_message?.html ||\n          message?.quoted_message?.text\n        \"\n      ></div>\n    </div>\n  </div>\n</ng-template>\n\n<ng-template #messageDateAndSender>\n  <ng-container>\n    <div\n      *ngIf=\"shouldDisplayTranslationNotice\"\n      class=\"str-chat__translation-notice\"\n      data-testid=\"translation-notice\"\n    >\n      <button\n        *ngIf=\"displayedMessageTextContent === 'translation'\"\n        data-testid=\"see-original\"\n        translate\n        (click)=\"displayOriginalMessage()\"\n        (keyup.enter)=\"displayOriginalMessage()\"\n      >\n        streamChat.See original (automatically translated)\n      </button>\n      <button\n        *ngIf=\"displayedMessageTextContent === 'original'\"\n        data-testid=\"see-translation\"\n        translate\n        (click)=\"displayTranslatedMessage()\"\n        (keyup.enter)=\"displayTranslatedMessage()\"\n      >\n        streamChat.See translation\n      </button>\n    </div>\n    <ng-container\n      *ngIf=\"customTemplatesService.customMessageMetadataTemplate$ | async\"\n    >\n      <div class=\"str-chat__custom-message-metadata\">\n        <ng-container\n          *ngTemplateOutlet=\"\n            (customTemplatesService.customMessageMetadataTemplate$ | async)!;\n            context: getMessageMetadataContext()\n          \"\n        ></ng-container>\n      </div>\n    </ng-container>\n    <div\n      class=\"\n        str-chat__message-data\n        str-chat__message-simple-data\n        str-chat__message-metadata\n      \"\n    >\n      <ng-container *ngTemplateOutlet=\"messageStatus\"></ng-container>\n\n      <span\n        *ngIf=\"!isSentByCurrentUser\"\n        data-testid=\"sender\"\n        class=\"str-chat__message-simple-name str-chat__message-sender-name\"\n      >\n        {{ message?.user?.name ? message?.user?.name : message?.user?.id }}\n      </span>\n      <span\n        data-testid=\"date\"\n        class=\"str-chat__message-simple-timestamp str-chat__message-simple-time\"\n      >\n        {{ parsedDate }}\n      </span>\n      <ng-container *ngIf=\"message?.message_text_updated_at\">\n        <span\n          data-testid=\"edited-flag\"\n          class=\"str-chat__mesage-simple-edited\"\n          translate\n          >streamChat.Edited</span\n        >\n        <div\n          data-testid=\"edited-timestamp\"\n          class=\"str-chat__message-edited-timestamp\"\n          [ngClass]=\"{\n            'str-chat__message-edited-timestamp--open': isEditedFlagOpened,\n            'str-chat__message-edited-timestamp--collapsed': !isEditedFlagOpened\n          }\"\n        >\n          <span translate>streamChat.Edited</span>\n          <time\n            dateTime=\"{{ message?.message_text_updated_at }}\"\n            title=\"{{ message?.message_text_updated_at }}\"\n          >\n            {{ pasedEditedDate }}\n          </time>\n        </div>\n      </ng-container>\n    </div>\n  </ng-container>\n</ng-template>\n\n<ng-template #messageStatus>\n  <ng-container\n    *ngIf=\"\n      isSentByCurrentUser &&\n      ((isLastSentMessage && message?.status === 'received') ||\n        message?.status === 'sending')\n    \"\n  >\n    <ng-container *ngIf=\"message?.status === 'sending'; else sentStatus\">\n      <ng-container *ngTemplateOutlet=\"sendingStatus\"></ng-container>\n    </ng-container>\n    <ng-template #sentStatus>\n      <ng-container\n        *ngIf=\"\n          mode === 'main' && isMessageDeliveredAndRead && canDisplayReadStatus;\n          else deliveredStatus\n        \"\n      >\n        <ng-container *ngTemplateOutlet=\"readStatus\"></ng-container>\n      </ng-container>\n    </ng-template>\n    <ng-template #deliveredStatus>\n      <ng-container\n        *ngTemplateOutlet=\"\n          (customTemplatesService.deliveredStatusTemplate$ | async) ||\n            defaultDeliveredStatus;\n          context: getDeliveredStatusContext()\n        \"\n      ></ng-container>\n    </ng-template>\n    <ng-template #defaultDeliveredStatus>\n      <span\n        *ngIf=\"mode === 'main'\"\n        class=\"\n          str-chat__message-simple-status\n          str-chat__message-simple-status-angular\n          str-chat__message-status\n        \"\n        data-testid=\"delivered-indicator\"\n        tabindex=\"0\"\n        [floatUiLoose]=\"floatingContent\"\n        loosePlacement=\"top\"\n        [looseTrigger]=\"hasTouchSupport ? 'click' : 'hover'\"\n        [disableAnimation]=\"true\"\n        [hideOnClickOutside]=\"true\"\n        [positionFixed]=\"true\"\n        [preventOverflow]=\"true\"\n      >\n        <float-ui-content #floatingContent>\n          <div class=\"str-chat__tooltip str-chat__tooltip-angular\">\n            {{ \"streamChat.Delivered\" | translate }}\n          </div>\n        </float-ui-content>\n        <stream-icon-placeholder\n          data-testid=\"delivered-icon\"\n          icon=\"delivered\"\n        ></stream-icon-placeholder>\n      </span>\n    </ng-template>\n    <ng-template #sendingStatus>\n      <ng-container\n        *ngTemplateOutlet=\"\n          (customTemplatesService.sendingStatusTemplate$ | async) ||\n            defaultSendingStatus;\n          context: getSendingStatusContext()\n        \"\n      ></ng-container>\n    </ng-template>\n    <ng-template #defaultSendingStatus>\n      <span\n        class=\"\n          str-chat__message-simple-status\n          str-chat__message-simple-status-angular\n          str-chat__message-status\n        \"\n        data-testid=\"sending-indicator\"\n        tabindex=\"0\"\n        [floatUiLoose]=\"floatingContent\"\n        loosePlacement=\"top\"\n        [looseTrigger]=\"hasTouchSupport ? 'click' : 'hover'\"\n        [disableAnimation]=\"true\"\n        [hideOnClickOutside]=\"true\"\n        [positionFixed]=\"true\"\n        [preventOverflow]=\"true\"\n      >\n        <float-ui-content #floatingContent>\n          <div class=\"str-chat__tooltip str-chat__tooltip-angular\">\n            {{ \"streamChat.Sending...\" | translate }}\n          </div>\n        </float-ui-content>\n        <stream-loading-indicator-placeholder\n          data-testid=\"loading-indicator\"\n        ></stream-loading-indicator-placeholder>\n      </span>\n    </ng-template>\n    <ng-template #readStatus>\n      <ng-container\n        *ngTemplateOutlet=\"\n          (customTemplatesService.readStatusTemplate$ | async) ||\n            defaultReadStatus;\n          context: getReadStatusContext()\n        \"\n      ></ng-container>\n    </ng-template>\n    <ng-template #defaultReadStatus let-readByText=\"readByText\">\n      <span\n        class=\"\n          str-chat__message-simple-status\n          str-chat__message-simple-status-angular\n          str-chat__message-status\n        \"\n        data-testid=\"read-indicator\"\n        tabindex=\"0\"\n        [floatUiLoose]=\"floatingContent\"\n        loosePlacement=\"top\"\n        [looseTrigger]=\"hasTouchSupport ? 'click' : 'hover'\"\n        [disableAnimation]=\"true\"\n        [hideOnClickOutside]=\"true\"\n        [positionFixed]=\"true\"\n        [preventOverflow]=\"true\"\n      >\n        <float-ui-content #floatingContent>\n          <div\n            class=\"str-chat__tooltip str-chat__tooltip-angular\"\n            data-testid=\"read-by-tooltip\"\n          >\n            {{ readByText }}\n          </div>\n        </float-ui-content>\n        <stream-icon-placeholder icon=\"read\"></stream-icon-placeholder>\n      </span>\n    </ng-template>\n  </ng-container>\n</ng-template>\n\n<ng-template #replyCountButton>\n  <div\n    class=\"\n      str-chat__message-simple-reply-button\n      str-chat__message-replies-count-button-wrapper\n    \"\n  >\n    <button\n      *ngIf=\"shouldDisplayThreadLink\"\n      class=\"str-chat__message-replies-count-button\"\n      data-testid=\"reply-count-button\"\n      (click)=\"setAsActiveParentMessage()\"\n    >\n      {{message?.reply_count === 1 ? ('streamChat.1 reply' | translate) : ('streamChat.{{ replyCount }}\n      replies' | translate:replyCountParam)}}\n    </button>\n  </div>\n</ng-template>\n\n<ng-template #attachmentsTemplate>\n  <ng-template\n    #defaultAttachments\n    let-messageId=\"messageId\"\n    let-attachments=\"attachments\"\n    let-parentMessageId=\"parentMessageId\"\n    let-imageModalStateChangeHandler=\"imageModalStateChangeHandler\"\n  >\n    <stream-attachment-list\n      [messageId]=\"messageId\"\n      [attachments]=\"attachments\"\n      [parentMessageId]=\"parentMessageId\"\n      (imageModalStateChange)=\"imageModalStateChangeHandler($event)\"\n    ></stream-attachment-list>\n  </ng-template>\n  <ng-container\n    *ngTemplateOutlet=\"\n      (customTemplatesService.attachmentListTemplate$ | async) ||\n        defaultAttachments;\n      context: getAttachmentListContext()\n    \"\n  ></ng-container>\n</ng-template>\n" }]
        }], ctorParameters: function () { return [{ type: ChatClientService }, { type: ChannelService }, { type: CustomTemplatesService }, { type: i0.ChangeDetectorRef }, { type: DateParserService }, { type: MessageService }, { type: MessageActionsService }, { type: i0.NgZone }]; }, propDecorators: { message: [{
                type: Input
            }], enabledMessageActions: [{
                type: Input
            }], isLastSentMessage: [{
                type: Input
            }], mode: [{
                type: Input
            }], isHighlighted: [{
                type: Input
            }], scroll$: [{
                type: Input
            }], messageMenuTrigger: [{
                type: ViewChild,
                args: ['messageMenuTrigger']
            }], messageMenuFloat: [{
                type: ViewChild,
                args: ['messageMenuFloat']
            }], messageTextElement: [{
                type: ViewChild,
                args: ['messageTextElement']
            }], messageBubble: [{
                type: ViewChild,
                args: ['messageBubble']
            }] } });

const textareaInjectionToken = new InjectionToken('textareaInjectionToken');

class TextareaDirective {
    constructor(viewContainerRef) {
        this.viewContainerRef = viewContainerRef;
        this.value = '';
        this.valueChange = new EventEmitter();
        this.send = new EventEmitter();
        this.userMentions = new EventEmitter();
        this.subscriptions = [];
        this.unpropagatedChanges = [];
    }
    ngOnChanges(changes) {
        this.unpropagatedChanges.push(changes);
        if (!this.componentRef) {
            return;
        }
        if (changes.componentRef) {
            this.subscriptions.forEach((s) => s.unsubscribe());
            if (this.componentRef) {
                this.subscriptions.push(this.componentRef.instance.valueChange.subscribe((value) => this.valueChange.next(value)));
                this.subscriptions.push(this.componentRef.instance.send.subscribe((value) => this.send.next(value)));
                if (this.componentRef.instance.userMentions) {
                    this.subscriptions.push(this.componentRef.instance.userMentions.subscribe((value) => this.userMentions.next(value)));
                }
                this.componentRef.instance.areMentionsEnabled = this.areMentionsEnabled;
                this.componentRef.instance.mentionScope = this.mentionScope;
                this.componentRef.instance.value = this.value;
                this.componentRef.instance.placeholder = this.placeholder;
                this.componentRef.instance.inputMode = this.inputMode;
                this.componentRef.instance.autoFocus = this.autoFocus;
            }
        }
        if (changes.areMentionsEnabled) {
            this.componentRef.instance.areMentionsEnabled = this.areMentionsEnabled;
        }
        if (changes.mentionScope) {
            this.componentRef.instance.mentionScope = this.mentionScope;
        }
        if (changes.value) {
            this.componentRef.instance.value = this.value;
        }
        if (changes.placeholder) {
            this.componentRef.instance.placeholder = this.placeholder;
        }
        if (changes.inputMode) {
            this.componentRef.instance.inputMode = this.inputMode;
        }
        if (changes.autoFocus) {
            this.componentRef.instance.autoFocus = this.autoFocus;
        }
        // ngOnChanges not called for dynamic components since we don't use template binding
        let changesToPropagate = {};
        this.unpropagatedChanges.forEach((c) => (changesToPropagate = { ...changesToPropagate, ...c }));
        // eslint-disable-next-line @angular-eslint/no-lifecycle-call
        this.componentRef.instance.ngOnChanges?.(changesToPropagate);
        this.unpropagatedChanges = [];
    }
}
TextareaDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: TextareaDirective, deps: [{ token: i0.ViewContainerRef }], target: i0.ɵɵFactoryTarget.Directive });
TextareaDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.0.4", type: TextareaDirective, selector: "[streamTextarea]", inputs: { componentRef: "componentRef", areMentionsEnabled: "areMentionsEnabled", mentionScope: "mentionScope", inputMode: "inputMode", value: "value", placeholder: "placeholder", autoFocus: "autoFocus" }, outputs: { valueChange: "valueChange", send: "send", userMentions: "userMentions" }, usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: TextareaDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[streamTextarea]',
                }]
        }], ctorParameters: function () { return [{ type: i0.ViewContainerRef }]; }, propDecorators: { componentRef: [{
                type: Input
            }], areMentionsEnabled: [{
                type: Input
            }], mentionScope: [{
                type: Input
            }], inputMode: [{
                type: Input
            }], value: [{
                type: Input
            }], placeholder: [{
                type: Input
            }], autoFocus: [{
                type: Input
            }], valueChange: [{
                type: Output
            }], send: [{
                type: Output
            }], userMentions: [{
                type: Output
            }] } });

/**
 * If you have an emoji picker in your application, you can propagate the selected emoji to the textarea using this service, more info can be found in [custom emoji picker guide](../code-examples/emoji-picker.mdx)
 */
class EmojiInputService {
    constructor() {
        /**
         * If you have an emoji picker in your application, you can propagate the selected emoji to the textarea using this Subject, more info can be found in [custom emoji picker guide](../code-examples/emoji-picker.mdx)
         */
        this.emojiInput$ = new Subject();
    }
}
EmojiInputService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: EmojiInputService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
EmojiInputService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: EmojiInputService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: EmojiInputService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return []; } });

/**
 * The `MessageInputConfigService` is used to keep a consistent configuration among the different [`MessageInput`](../components/MessageInputComponent.mdx) components if your UI has more than one input component.
 */
class MessageInputConfigService {
    constructor() {
        /**
         * If file upload is enabled, the user can open a file selector from the input. Please note that the user also needs to have the necessary [channel capability](https://getstream.io/chat/docs/javascript/channel_capabilities/?language=javascript).
         */
        this.isFileUploadEnabled = true;
        /**
         * If true, users can mention other users in messages. You also [need to use the `AutocompleteTextarea`](../concepts/opt-in-architecture.mdx) for this feature to work.
         */
        this.areMentionsEnabled = true;
        /**
         * If `false`, users can only upload one attachment per message
         */
        this.isMultipleFileUploadEnabled = true;
        /**
         * The scope for user mentions, either members of the current channel of members of the application
         */
        this.mentionScope = 'channel';
        /**
         * In `desktop` mode the `Enter` key will trigger message sending, in `mobile` mode the `Enter` key will insert a new line to the message input.
         */
        this.inputMode = 'desktop';
    }
}
MessageInputConfigService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: MessageInputConfigService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
MessageInputConfigService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: MessageInputConfigService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: MessageInputConfigService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return []; } });

/**
 * The `AttachmentPreviewList` component displays a preview of the attachments uploaded to a message. Users can delete attachments using the preview component, or retry upload if it failed previously.
 */
class AttachmentPreviewListComponent {
    constructor() {
        /**
         * An output to notify the parent component if the user tries to retry a failed upload
         */
        this.retryAttachmentUpload = new EventEmitter();
        /**
         * An output to notify the parent component if the user wants to delete a file
         */
        this.deleteAttachment = new EventEmitter();
    }
    attachmentUploadRetried(file) {
        this.retryAttachmentUpload.emit(file);
    }
    attachmentDeleted(upload) {
        this.deleteAttachment.emit(upload);
    }
    trackByFile(_, item) {
        return item.file;
    }
}
AttachmentPreviewListComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: AttachmentPreviewListComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
AttachmentPreviewListComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.0.4", type: AttachmentPreviewListComponent, selector: "stream-attachment-preview-list", inputs: { attachmentUploads$: "attachmentUploads$" }, outputs: { retryAttachmentUpload: "retryAttachmentUpload", deleteAttachment: "deleteAttachment" }, ngImport: i0, template: "<div\n  *ngIf=\"(attachmentUploads$ | async)?.length\"\n  class=\"str-chat__attachment-preview-list\"\n>\n  <div class=\"str-chat__attachment-list-scroll-container\">\n    <ng-container\n      *ngFor=\"\n        let attachmentUpload of attachmentUploads$ | async;\n        trackBy: trackByFile\n      \"\n    >\n      <div\n        *ngIf=\"attachmentUpload.type === 'image'\"\n        class=\"str-chat__attachment-preview-image\"\n        data-testclass=\"attachment-image-preview\"\n      >\n        <ng-container\n          *ngTemplateOutlet=\"\n            deleteButton;\n            context: { attachmentUpload: attachmentUpload }\n          \"\n        ></ng-container>\n        <div\n          *ngIf=\"attachmentUpload.state === 'uploading'\"\n          class=\"str-chat__attachment-preview-image-loading\"\n        >\n          <stream-loading-indicator-placeholder\n            data-testclass=\"loading-indicator\"\n          ></stream-loading-indicator-placeholder>\n        </div>\n        <ng-container\n          *ngTemplateOutlet=\"\n            retryButton;\n            context: { attachmentUpload: attachmentUpload }\n          \"\n        ></ng-container>\n        <img\n          *ngIf=\"attachmentUpload.url || attachmentUpload.previewUri\"\n          class=\"str-chat__attachment-preview-thumbnail\"\n          data-testclass=\"attachment-image\"\n          src=\"{{\n            attachmentUpload.url\n              ? attachmentUpload.url\n              : attachmentUpload.previewUri\n          }}\"\n          alt=\"{{ attachmentUpload.file.name }}\"\n        />\n      </div>\n      <div\n        *ngIf=\"\n          attachmentUpload.type === 'file' || attachmentUpload.type === 'video'\n        \"\n        class=\"str-chat__attachment-preview-file\"\n        data-testclass=\"attachment-file-preview\"\n      >\n        <stream-icon-placeholder\n          class=\"str-chat__attachment-preview-file-icon\"\n          icon=\"unspecified-filetype\"\n        ></stream-icon-placeholder>\n\n        <div class=\"str-chat__attachment-preview-file-end\">\n          <div class=\"str-chat__attachment-preview-file-name\">\n            {{ attachmentUpload.file.name }}\n          </div>\n          <a\n            *ngIf=\"attachmentUpload.state === 'success'\"\n            class=\"str-chat__attachment-preview-file-download\"\n            data-testclass=\"file-download-link\"\n            download\n            href=\"{{ attachmentUpload.url }}\"\n            (click)=\"attachmentUpload.url ? null : $event.preventDefault()\"\n            (keyup.enter)=\"\n              attachmentUpload.url ? null : $event.preventDefault()\n            \"\n          >\n            <stream-icon-placeholder icon=\"download\"></stream-icon-placeholder>\n          </a>\n          <stream-loading-indicator-placeholder\n            *ngIf=\"attachmentUpload.state === 'uploading'\"\n            data-testclass=\"loading-indicator\"\n          ></stream-loading-indicator-placeholder>\n        </div>\n        <ng-container\n          *ngTemplateOutlet=\"\n            deleteButton;\n            context: { attachmentUpload: attachmentUpload }\n          \"\n        ></ng-container>\n        <ng-container\n          *ngTemplateOutlet=\"\n            retryButton;\n            context: { attachmentUpload: attachmentUpload }\n          \"\n        ></ng-container>\n      </div>\n    </ng-container>\n  </div>\n</div>\n\n<ng-template #deleteButton let-attachmentUpload=\"attachmentUpload\">\n  <div\n    class=\"str-chat__attachment-preview-delete\"\n    data-testclass=\"file-delete\"\n    role=\"button\"\n    (click)=\"attachmentDeleted(attachmentUpload)\"\n    (keyup.enter)=\"attachmentDeleted(attachmentUpload)\"\n  >\n    <stream-icon-placeholder icon=\"close\"></stream-icon-placeholder>\n  </div>\n</ng-template>\n\n<ng-template #retryButton let-attachmentUpload=\"attachmentUpload\">\n  <div\n    *ngIf=\"attachmentUpload.state === 'error'\"\n    data-testclass=\"upload-retry\"\n    class=\"str-chat__attachment-preview-error str-chat__attachment-preview-error-{{\n      attachmentUpload.type === 'image' ? 'image' : 'file'\n    }}\"\n    (click)=\"attachmentUploadRetried(attachmentUpload.file)\"\n    (keyup.enter)=\"attachmentUploadRetried(attachmentUpload.file)\"\n  >\n    <stream-icon-placeholder icon=\"retry\"></stream-icon-placeholder>\n  </div>\n</ng-template>\n", dependencies: [{ kind: "directive", type: i4.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i4.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i4.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "component", type: IconPlaceholderComponent, selector: "stream-icon-placeholder", inputs: ["icon"] }, { kind: "component", type: LoadingIndicatorPlaceholderComponent, selector: "stream-loading-indicator-placeholder" }, { kind: "pipe", type: i4.AsyncPipe, name: "async" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: AttachmentPreviewListComponent, decorators: [{
            type: Component,
            args: [{ selector: 'stream-attachment-preview-list', template: "<div\n  *ngIf=\"(attachmentUploads$ | async)?.length\"\n  class=\"str-chat__attachment-preview-list\"\n>\n  <div class=\"str-chat__attachment-list-scroll-container\">\n    <ng-container\n      *ngFor=\"\n        let attachmentUpload of attachmentUploads$ | async;\n        trackBy: trackByFile\n      \"\n    >\n      <div\n        *ngIf=\"attachmentUpload.type === 'image'\"\n        class=\"str-chat__attachment-preview-image\"\n        data-testclass=\"attachment-image-preview\"\n      >\n        <ng-container\n          *ngTemplateOutlet=\"\n            deleteButton;\n            context: { attachmentUpload: attachmentUpload }\n          \"\n        ></ng-container>\n        <div\n          *ngIf=\"attachmentUpload.state === 'uploading'\"\n          class=\"str-chat__attachment-preview-image-loading\"\n        >\n          <stream-loading-indicator-placeholder\n            data-testclass=\"loading-indicator\"\n          ></stream-loading-indicator-placeholder>\n        </div>\n        <ng-container\n          *ngTemplateOutlet=\"\n            retryButton;\n            context: { attachmentUpload: attachmentUpload }\n          \"\n        ></ng-container>\n        <img\n          *ngIf=\"attachmentUpload.url || attachmentUpload.previewUri\"\n          class=\"str-chat__attachment-preview-thumbnail\"\n          data-testclass=\"attachment-image\"\n          src=\"{{\n            attachmentUpload.url\n              ? attachmentUpload.url\n              : attachmentUpload.previewUri\n          }}\"\n          alt=\"{{ attachmentUpload.file.name }}\"\n        />\n      </div>\n      <div\n        *ngIf=\"\n          attachmentUpload.type === 'file' || attachmentUpload.type === 'video'\n        \"\n        class=\"str-chat__attachment-preview-file\"\n        data-testclass=\"attachment-file-preview\"\n      >\n        <stream-icon-placeholder\n          class=\"str-chat__attachment-preview-file-icon\"\n          icon=\"unspecified-filetype\"\n        ></stream-icon-placeholder>\n\n        <div class=\"str-chat__attachment-preview-file-end\">\n          <div class=\"str-chat__attachment-preview-file-name\">\n            {{ attachmentUpload.file.name }}\n          </div>\n          <a\n            *ngIf=\"attachmentUpload.state === 'success'\"\n            class=\"str-chat__attachment-preview-file-download\"\n            data-testclass=\"file-download-link\"\n            download\n            href=\"{{ attachmentUpload.url }}\"\n            (click)=\"attachmentUpload.url ? null : $event.preventDefault()\"\n            (keyup.enter)=\"\n              attachmentUpload.url ? null : $event.preventDefault()\n            \"\n          >\n            <stream-icon-placeholder icon=\"download\"></stream-icon-placeholder>\n          </a>\n          <stream-loading-indicator-placeholder\n            *ngIf=\"attachmentUpload.state === 'uploading'\"\n            data-testclass=\"loading-indicator\"\n          ></stream-loading-indicator-placeholder>\n        </div>\n        <ng-container\n          *ngTemplateOutlet=\"\n            deleteButton;\n            context: { attachmentUpload: attachmentUpload }\n          \"\n        ></ng-container>\n        <ng-container\n          *ngTemplateOutlet=\"\n            retryButton;\n            context: { attachmentUpload: attachmentUpload }\n          \"\n        ></ng-container>\n      </div>\n    </ng-container>\n  </div>\n</div>\n\n<ng-template #deleteButton let-attachmentUpload=\"attachmentUpload\">\n  <div\n    class=\"str-chat__attachment-preview-delete\"\n    data-testclass=\"file-delete\"\n    role=\"button\"\n    (click)=\"attachmentDeleted(attachmentUpload)\"\n    (keyup.enter)=\"attachmentDeleted(attachmentUpload)\"\n  >\n    <stream-icon-placeholder icon=\"close\"></stream-icon-placeholder>\n  </div>\n</ng-template>\n\n<ng-template #retryButton let-attachmentUpload=\"attachmentUpload\">\n  <div\n    *ngIf=\"attachmentUpload.state === 'error'\"\n    data-testclass=\"upload-retry\"\n    class=\"str-chat__attachment-preview-error str-chat__attachment-preview-error-{{\n      attachmentUpload.type === 'image' ? 'image' : 'file'\n    }}\"\n    (click)=\"attachmentUploadRetried(attachmentUpload.file)\"\n    (keyup.enter)=\"attachmentUploadRetried(attachmentUpload.file)\"\n  >\n    <stream-icon-placeholder icon=\"retry\"></stream-icon-placeholder>\n  </div>\n</ng-template>\n" }]
        }], ctorParameters: function () { return []; }, propDecorators: { attachmentUploads$: [{
                type: Input
            }], retryAttachmentUpload: [{
                type: Output
            }], deleteAttachment: [{
                type: Output
            }] } });

/**
 * The `MessageInput` component displays an input where users can type their messages and upload files, and sends the message to the active channel. The component can be used to compose new messages or update existing ones. To send messages, the chat user needs to have the necessary [channel capability](https://getstream.io/chat/docs/javascript/channel_capabilities/?language=javascript).
 */
class MessageInputComponent {
    constructor(channelService, notificationService, attachmentService, configService, textareaType, componentFactoryResolver, cdRef, emojiInputService, customTemplatesService, messageActionsService) {
        this.channelService = channelService;
        this.notificationService = notificationService;
        this.attachmentService = attachmentService;
        this.configService = configService;
        this.textareaType = textareaType;
        this.componentFactoryResolver = componentFactoryResolver;
        this.cdRef = cdRef;
        this.emojiInputService = emojiInputService;
        this.customTemplatesService = customTemplatesService;
        this.messageActionsService = messageActionsService;
        /**
         * Determines if the message is being dispalyed in a channel or in a [thread](https://getstream.io/chat/docs/javascript/threads/?language=javascript).
         */
        this.mode = 'main';
        /**
         * Enables or disables auto focus on the textarea element
         */
        this.autoFocus = true;
        /**
         * By default the input will react to changes in `messageToEdit$` from [`MessageActionsService`](../services/MessageActionsService.mdx) and display the message to be edited (taking into account the current `mode`).
         *
         * If you don't need that behavior, you can turn this of with this flag. In that case you should create your own edit message UI.
         */
        this.watchForMessageToEdit = true;
        /**
         * Use this input to control wether a send button is rendered or not. If you don't render a send button, you can still trigger message send using the `sendMessage$` input.
         */
        this.displaySendButton = true;
        /**
         * Emits when a message was successfuly sent or updated
         */
        this.messageUpdate = new EventEmitter();
        this.class = 'str-chat__message-input-angular-host';
        this.textareaValue = '';
        this.mentionedUsers = [];
        this.typingStart$ = new Subject();
        this.isCooldownInProgress = false;
        this.fileInputId = v4();
        this.subscriptions = [];
        this.isViewInited = false;
        this.defaultTextareaPlaceholder = 'streamChat.Type your message';
        this.slowModeTextareaPlaceholder = 'streamChat.Slow Mode ON';
        this.textareaPlaceholder = this.defaultTextareaPlaceholder;
        this.subscriptions.push(this.attachmentService.attachmentUploadInProgressCounter$.subscribe((counter) => {
            if (counter === 0 && this.hideNotification) {
                this.hideNotification();
                this.hideNotification = undefined;
            }
        }));
        this.subscriptions.push(this.channelService.activeChannel$.subscribe((channel) => {
            if (channel && this.channel && channel.id !== this.channel.id) {
                this.textareaValue = '';
                this.attachmentService.resetAttachmentUploads();
            }
            const capabilities = channel?.data?.own_capabilities;
            if (capabilities) {
                this.isFileUploadAuthorized =
                    capabilities.indexOf('upload-file') !== -1;
                this.canSendLinks = capabilities.indexOf('send-links') !== -1;
                this.channel = channel;
                this.setCanSendMessages();
            }
        }));
        this.subscriptions.push(this.channelService.messageToQuote$.subscribe((m) => {
            const isThreadReply = m && m.parent_id;
            if ((this.mode === 'thread' && isThreadReply) ||
                (this.mode === 'thread' && this.quotedMessage && !m) ||
                (this.mode === 'main' && !isThreadReply)) {
                this.quotedMessage = m;
            }
        }));
        this.subscriptions.push(this.messageActionsService.messageToEdit$.subscribe((message) => {
            this.messageToEdit = message;
            this.checkIfInEditMode();
        }));
        this.attachmentUploads$ = this.attachmentService.attachmentUploads$;
        this.attachmentUploadInProgressCounter$ =
            this.attachmentService.attachmentUploadInProgressCounter$;
        this.isFileUploadEnabled = this.configService.isFileUploadEnabled;
        this.isMultipleFileUploadEnabled =
            this.configService.isMultipleFileUploadEnabled;
        this.areMentionsEnabled = this.configService.areMentionsEnabled;
        this.mentionScope = this.configService.mentionScope;
        this.inputMode = this.configService.inputMode;
        this.subscriptions.push(this.typingStart$.subscribe(() => void this.channelService.typingStarted(this.parentMessageId)));
        this.subscriptions.push(combineLatest([
            this.channelService.latestMessageDateByUserByChannels$,
            this.channelService.activeChannel$,
        ])
            .pipe(map(([latestMessages, channel]) => [latestMessages[channel?.cid || ''], channel]))
            .subscribe(([latestMessageDate, channel]) => {
            const cooldown = channel?.data?.cooldown &&
                latestMessageDate &&
                Math.round(channel?.data?.cooldown -
                    (new Date().getTime() - latestMessageDate.getTime()) / 1000);
            if (cooldown &&
                cooldown > 0 &&
                (channel?.data?.own_capabilities).includes('slow-mode')) {
                this.startCooldown(cooldown);
            }
            else if (this.isCooldownInProgress) {
                this.stopCooldown();
            }
        }));
    }
    ngOnInit() {
        this.subscriptions.push(this.customTemplatesService.emojiPickerTemplate$.subscribe((template) => {
            this.emojiPickerTemplate = template;
            this.cdRef.detectChanges();
        }));
        this.subscriptions.push(this.customTemplatesService.attachmentPreviewListTemplate$.subscribe((template) => {
            this.attachmentPreviewListTemplate = template;
            this.cdRef.detectChanges();
        }));
        this.subscriptions.push(this.customTemplatesService.customAttachmentUploadTemplate$.subscribe((template) => {
            this.customAttachmentUploadTemplate = template;
            this.cdRef.detectChanges();
        }));
    }
    ngAfterViewInit() {
        this.isViewInited = true;
        this.initTextarea();
    }
    ngOnChanges(changes) {
        if (changes.message) {
            this.messageToUpdateChanged();
        }
        if (changes.isFileUploadEnabled) {
            this.configService.isFileUploadEnabled = this.isFileUploadEnabled;
        }
        if (changes.isMultipleFileUploadEnabled) {
            this.configService.isMultipleFileUploadEnabled =
                this.isMultipleFileUploadEnabled;
        }
        if (changes.areMentionsEnabled) {
            this.configService.areMentionsEnabled = this.areMentionsEnabled;
        }
        if (changes.mentionScope) {
            this.configService.mentionScope = this.mentionScope;
        }
        if (changes.mode) {
            this.setCanSendMessages();
            this.checkIfInEditMode();
        }
        if (changes.watchForMessageToEdit) {
            this.checkIfInEditMode();
        }
        if (changes.inputMode) {
            this.configService.inputMode = this.inputMode;
        }
        if (changes.sendMessage$) {
            if (this.sendMessageSubcription) {
                this.sendMessageSubcription.unsubscribe();
            }
            if (this.sendMessage$) {
                this.sendMessageSubcription = this.sendMessage$.subscribe(() => void this.messageSent());
            }
        }
    }
    ngOnDestroy() {
        if (this.sendMessageSubcription) {
            this.sendMessageSubcription.unsubscribe();
        }
        this.subscriptions.forEach((s) => s.unsubscribe());
    }
    async messageSent() {
        if (this.isCooldownInProgress) {
            return;
        }
        let attachmentUploadInProgressCounter;
        this.attachmentService.attachmentUploadInProgressCounter$
            .pipe(first())
            .subscribe((counter) => (attachmentUploadInProgressCounter = counter));
        if (attachmentUploadInProgressCounter > 0) {
            if (!this.hideNotification) {
                this.hideNotification =
                    this.notificationService.addPermanentNotification('streamChat.Wait until all attachments have uploaded');
            }
            return;
        }
        const attachments = this.attachmentService.mapToAttachments();
        let text = this.textareaValue;
        text = text.replace(/^\n+/g, ''); // leading empty lines
        text = text.replace(/\n+$/g, ''); // ending empty lines
        const textContainsOnlySpaceChars = !text.replace(/ /g, ''); //spcae
        if ((!text || textContainsOnlySpaceChars) &&
            (!attachments || attachments.length === 0)) {
            return;
        }
        if (textContainsOnlySpaceChars) {
            text = '';
        }
        if (this.containsLinks && !this.canSendLinks) {
            this.notificationService.addTemporaryNotification('streamChat.Sending links is not allowed in this conversation');
            return;
        }
        if (!this.isUpdate) {
            this.textareaValue = '';
        }
        try {
            const message = await (this.isUpdate
                ? this.channelService.updateMessage({
                    ...this.message,
                    text: text,
                    attachments: attachments,
                })
                : this.channelService.sendMessage(text, attachments, this.mentionedUsers, this.parentMessageId, this.quotedMessage?.id));
            this.messageUpdate.emit({ message });
            if (this.isUpdate) {
                this.deselectMessageToEdit();
            }
            else {
                this.attachmentService.resetAttachmentUploads();
            }
        }
        catch (error) {
            if (this.isUpdate) {
                this.notificationService.addTemporaryNotification('streamChat.Edit message request failed');
            }
        }
        void this.channelService.typingStopped(this.parentMessageId);
        if (this.quotedMessage) {
            this.deselectMessageToQuote();
        }
    }
    get containsLinks() {
        return /(?:(?:https?|ftp):\/\/)?[\w/\-?=%.]+\.[\w/\-&?=%.]+/.test(this.textareaValue);
    }
    get quotedMessageAttachments() {
        const originalAttachments = this.quotedMessage?.attachments;
        return originalAttachments && originalAttachments.length
            ? [originalAttachments[0]]
            : [];
    }
    get disabledTextareaText() {
        if (!this.canSendMessages) {
            return this.mode === 'thread'
                ? "streamChat.You can't send thread replies in this channel"
                : "streamChat.You can't send messages in this channel";
        }
        return '';
    }
    async filesSelected(fileList) {
        await this.attachmentService.filesSelected(fileList);
        this.clearFileInput();
    }
    deselectMessageToQuote() {
        this.channelService.selectMessageToQuote(undefined);
    }
    deselectMessageToEdit() {
        this.messageActionsService.messageToEdit$.next(undefined);
    }
    getEmojiPickerContext() {
        return {
            emojiInput$: this.emojiInputService.emojiInput$,
        };
    }
    getAttachmentPreviewListContext() {
        return {
            attachmentUploads$: this.attachmentService.attachmentUploads$,
            deleteUploadHandler: this.deleteUpload.bind(this),
            retryUploadHandler: this.retryUpload.bind(this),
        };
    }
    getAttachmentUploadContext() {
        return {
            isMultipleFileUploadEnabled: this.isMultipleFileUploadEnabled,
            attachmentService: this.attachmentService,
        };
    }
    get isUpdate() {
        return !!this.message;
    }
    deleteUpload(upload) {
        if (this.isUpdate) {
            // Delay delete to avoid modal detecting this click as outside click
            setTimeout(() => {
                void this.attachmentService.deleteAttachment(upload);
            });
        }
        else {
            void this.attachmentService.deleteAttachment(upload);
        }
    }
    retryUpload(file) {
        void this.attachmentService.retryAttachmentUpload(file);
    }
    clearFileInput() {
        this.fileInput.nativeElement.value = '';
    }
    initTextarea() {
        // cleanup previously built textarea
        if (!this.canSendMessages) {
            this.textareaRef = undefined;
        }
        if (!this.canSendMessages || this.textareaRef || !this.textareaAnchor) {
            return;
        }
        const componentFactory = this.componentFactoryResolver.resolveComponentFactory(this.textareaType);
        this.textareaRef =
            this.textareaAnchor.viewContainerRef.createComponent(componentFactory);
        this.cdRef.detectChanges();
    }
    setCanSendMessages() {
        const capabilities = this.channel?.data?.own_capabilities;
        if (!capabilities) {
            this.canSendMessages = false;
        }
        else {
            this.canSendMessages =
                capabilities.indexOf(this.mode === 'main' ? 'send-message' : 'send-reply') !== -1 || this.isUpdate;
        }
        if (this.isViewInited) {
            this.cdRef.detectChanges();
            this.initTextarea();
        }
    }
    get parentMessageId() {
        let parentMessageId = undefined;
        if (this.mode === 'thread') {
            this.channelService.activeParentMessageId$
                .pipe(first())
                .subscribe((id) => (parentMessageId = id));
        }
        return parentMessageId;
    }
    startCooldown(cooldown) {
        this.textareaPlaceholder = this.slowModeTextareaPlaceholder;
        this.isCooldownInProgress = true;
        this.cooldown$ = timer(0, 1000).pipe(take(cooldown + 1), map((v) => cooldown - v), tap((v) => {
            if (v === 0) {
                this.stopCooldown();
            }
        }));
    }
    stopCooldown() {
        this.cooldown$ = undefined;
        this.isCooldownInProgress = false;
        this.textareaPlaceholder = this.defaultTextareaPlaceholder;
    }
    checkIfInEditMode() {
        if (!this.watchForMessageToEdit) {
            return;
        }
        if (!this.messageToEdit && this.message) {
            this.message = undefined;
            this.messageToUpdateChanged();
            if (this.isViewInited) {
                this.cdRef.detectChanges();
            }
        }
        if (this.messageToEdit &&
            ((this.mode === 'main' && !this.messageToEdit.parent_id) ||
                (this.mode === 'thread' && this.messageToEdit.parent_id))) {
            this.message = this.messageToEdit;
            this.messageToUpdateChanged();
            if (this.isViewInited) {
                this.cdRef.detectChanges();
            }
        }
    }
    messageToUpdateChanged() {
        this.attachmentService.resetAttachmentUploads();
        this.setCanSendMessages();
        if (this.isUpdate) {
            this.attachmentService.createFromAttachments(this.message.attachments || []);
            this.textareaValue = this.message.text || '';
        }
        else {
            this.textareaValue = '';
        }
    }
}
MessageInputComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: MessageInputComponent, deps: [{ token: ChannelService }, { token: NotificationService }, { token: AttachmentService }, { token: MessageInputConfigService }, { token: textareaInjectionToken }, { token: i0.ComponentFactoryResolver }, { token: i0.ChangeDetectorRef }, { token: EmojiInputService }, { token: CustomTemplatesService }, { token: MessageActionsService }], target: i0.ɵɵFactoryTarget.Component });
MessageInputComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.0.4", type: MessageInputComponent, selector: "stream-message-input", inputs: { isFileUploadEnabled: "isFileUploadEnabled", areMentionsEnabled: "areMentionsEnabled", mentionScope: "mentionScope", mode: "mode", isMultipleFileUploadEnabled: "isMultipleFileUploadEnabled", message: "message", sendMessage$: "sendMessage$", inputMode: "inputMode", autoFocus: "autoFocus", watchForMessageToEdit: "watchForMessageToEdit", displaySendButton: "displaySendButton" }, outputs: { messageUpdate: "messageUpdate" }, host: { properties: { "class": "this.class" } }, providers: [AttachmentService, EmojiInputService], viewQueries: [{ propertyName: "fileInput", first: true, predicate: ["fileInput"], descendants: true }, { propertyName: "textareaAnchor", first: true, predicate: TextareaDirective, descendants: true }], usesOnChanges: true, ngImport: i0, template: "<div class=\"str-chat__message-input str-chat-angular__message-input\">\n  <div *ngIf=\"quotedMessage\" class=\"str-chat__quoted-message-preview-header\">\n    <div class=\"str-chat__quoted-message-reply-to-message\">\n      {{ \"streamChat.Reply to Message\" | translate }}\n    </div>\n    <button\n      class=\"str-chat__quoted-message-remove\"\n      data-testid=\"remove-quote\"\n      (click)=\"deselectMessageToQuote()\"\n      (keyup.enter)=\"deselectMessageToQuote()\"\n    >\n      <stream-icon-placeholder icon=\"close\"></stream-icon-placeholder>\n    </button>\n  </div>\n  <div *ngIf=\"isUpdate\" class=\"str-chat__quoted-message-preview-header\">\n    <div class=\"str-chat__quoted-message-reply-to-message\">\n      {{ \"streamChat.Edit Message\" | translate }}\n    </div>\n    <button\n      class=\"str-chat__quoted-message-remove\"\n      data-testid=\"remove-quote\"\n      (click)=\"deselectMessageToEdit()\"\n      (keyup.enter)=\"deselectMessageToEdit()\"\n    >\n      <stream-icon-placeholder icon=\"close\"></stream-icon-placeholder>\n    </button>\n  </div>\n  <ng-container *ngIf=\"canSendMessages; else notAllowed\">\n    <div\n      class=\"\n        str-chat__message-input-inner\n        str-chat-angular__message-input-inner\n      \"\n    >\n      <ng-container\n        *ngIf=\"isFileUploadEnabled && isFileUploadAuthorized && canSendMessages\"\n      >\n        <ng-container\n          *ngTemplateOutlet=\"\n            customAttachmentUploadTemplate || defaultAttachmentUpload;\n            context: getAttachmentUploadContext()\n          \"\n        ></ng-container>\n        <ng-template #defaultAttachmentUpload>\n          <div\n            class=\"str-chat__file-input-container\"\n            data-testid=\"file-upload-button\"\n          >\n            <input\n              #fileInput\n              type=\"file\"\n              class=\"str-chat__file-input\"\n              data-testid=\"file-input\"\n              [multiple]=\"isMultipleFileUploadEnabled\"\n              id=\"{{ fileInputId }}\"\n              (change)=\"filesSelected(fileInput.files)\"\n            />\n            <label class=\"str-chat__file-input-label\" for=\"{{ fileInputId }}\">\n              <stream-icon-placeholder icon=\"attach\"></stream-icon-placeholder>\n            </label>\n          </div>\n        </ng-template>\n      </ng-container>\n      <div class=\"str-chat__message-textarea-container\">\n        <div\n          *ngIf=\"quotedMessage\"\n          data-testid=\"quoted-message-container\"\n          class=\"str-chat__quoted-message-preview\"\n        >\n          <stream-avatar-placeholder\n            data-testid=\"qouted-message-avatar\"\n            class=\"\n              str-chat-angular__avatar-host\n              str-chat__message-sender-avatar\n            \"\n            type=\"user\"\n            location=\"quoted-message-sender\"\n            [imageUrl]=\"quotedMessage.user?.image\"\n            [name]=\"quotedMessage.user?.name || quotedMessage.user?.id\"\n            [user]=\"quotedMessage.user || undefined\"\n          ></stream-avatar-placeholder>\n          <div\n            class=\"\n              quoted-message-preview-content-inner\n              str-chat__quoted-message-bubble\n            \"\n          >\n            <stream-attachment-list\n              *ngIf=\"\n                quotedMessage?.attachments && quotedMessage?.attachments?.length\n              \"\n              [attachments]=\"quotedMessageAttachments\"\n              [messageId]=\"quotedMessage.id\"\n            ></stream-attachment-list>\n            <div\n              class=\"str-chat__quoted-message-text\"\n              data-testid=\"quoted-message-text\"\n              [innerHTML]=\"\n                quotedMessage.translation ||\n                quotedMessage.html ||\n                quotedMessage.text\n              \"\n            ></div>\n          </div>\n        </div>\n        <ng-template\n          #defaultAttachmentsPreview\n          let-attachmentUploads$=\"attachmentUploads$\"\n          let-retryUploadHandler=\"retryUploadHandler\"\n          let-deleteUploadHandler=\"deleteUploadHandler\"\n        >\n          <stream-attachment-preview-list\n            class=\"str-chat__attachment-preview-list-angular-host\"\n            [attachmentUploads$]=\"attachmentUploads$\"\n            (retryAttachmentUpload)=\"retryUploadHandler($event)\"\n            (deleteAttachment)=\"deleteUploadHandler($event)\"\n          ></stream-attachment-preview-list>\n        </ng-template>\n        <ng-container\n          *ngTemplateOutlet=\"\n            attachmentPreviewListTemplate || defaultAttachmentsPreview;\n            context: getAttachmentPreviewListContext()\n          \"\n        ></ng-container>\n        <div class=\"str-chat__message-textarea-with-emoji-picker\">\n          <ng-container\n            streamTextarea\n            [componentRef]=\"textareaRef\"\n            [areMentionsEnabled]=\"areMentionsEnabled\"\n            [mentionScope]=\"mentionScope\"\n            [inputMode]=\"inputMode\"\n            [autoFocus]=\"autoFocus\"\n            [placeholder]=\"textareaPlaceholder\"\n            [(value)]=\"textareaValue\"\n            (valueChange)=\"typingStart$.next()\"\n            (send)=\"messageSent()\"\n            (userMentions)=\"mentionedUsers = $event\"\n          ></ng-container>\n          <ng-container *ngIf=\"emojiPickerTemplate\" data-testid=\"emoji-picker\">\n            <ng-container\n              *ngTemplateOutlet=\"\n                emojiPickerTemplate;\n                context: getEmojiPickerContext()\n              \"\n            ></ng-container>\n          </ng-container>\n        </div>\n      </div>\n      <button\n        *ngIf=\"canSendMessages && !isCooldownInProgress && displaySendButton\"\n        data-testid=\"send-button\"\n        class=\"str-chat__send-button\"\n        [disabled]=\"\n          (attachmentUploadInProgressCounter$ | async)! > 0 ||\n          (!textareaValue && (attachmentUploads$ | async)!.length === 0)\n        \"\n        (click)=\"messageSent()\"\n        (keyup.enter)=\"messageSent()\"\n      >\n        <stream-icon-placeholder icon=\"send\"></stream-icon-placeholder>\n      </button>\n      <div\n        *ngIf=\"isCooldownInProgress\"\n        class=\"str-chat__message-input-cooldown\"\n        data-testid=\"cooldown-timer\"\n      >\n        {{ cooldown$ | async }}\n      </div>\n    </div>\n  </ng-container>\n  <ng-template #notAllowed>\n    <div\n      class=\"str-chat__message-input-not-allowed\"\n      data-testid=\"disabled-textarea\"\n    >\n      {{ disabledTextareaText | translate }}\n    </div>\n  </ng-template>\n</div>\n", dependencies: [{ kind: "directive", type: i4.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i4.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "component", type: AvatarPlaceholderComponent, selector: "stream-avatar-placeholder", inputs: ["name", "imageUrl", "location", "channel", "user", "type", "initialsType", "showOnlineIndicator"] }, { kind: "component", type: AttachmentListComponent, selector: "stream-attachment-list", inputs: ["messageId", "parentMessageId", "attachments"], outputs: ["imageModalStateChange"] }, { kind: "component", type: AttachmentPreviewListComponent, selector: "stream-attachment-preview-list", inputs: ["attachmentUploads$"], outputs: ["retryAttachmentUpload", "deleteAttachment"] }, { kind: "directive", type: TextareaDirective, selector: "[streamTextarea]", inputs: ["componentRef", "areMentionsEnabled", "mentionScope", "inputMode", "value", "placeholder", "autoFocus"], outputs: ["valueChange", "send", "userMentions"] }, { kind: "component", type: IconPlaceholderComponent, selector: "stream-icon-placeholder", inputs: ["icon"] }, { kind: "pipe", type: i4.AsyncPipe, name: "async" }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: MessageInputComponent, decorators: [{
            type: Component,
            args: [{ selector: 'stream-message-input', providers: [AttachmentService, EmojiInputService], template: "<div class=\"str-chat__message-input str-chat-angular__message-input\">\n  <div *ngIf=\"quotedMessage\" class=\"str-chat__quoted-message-preview-header\">\n    <div class=\"str-chat__quoted-message-reply-to-message\">\n      {{ \"streamChat.Reply to Message\" | translate }}\n    </div>\n    <button\n      class=\"str-chat__quoted-message-remove\"\n      data-testid=\"remove-quote\"\n      (click)=\"deselectMessageToQuote()\"\n      (keyup.enter)=\"deselectMessageToQuote()\"\n    >\n      <stream-icon-placeholder icon=\"close\"></stream-icon-placeholder>\n    </button>\n  </div>\n  <div *ngIf=\"isUpdate\" class=\"str-chat__quoted-message-preview-header\">\n    <div class=\"str-chat__quoted-message-reply-to-message\">\n      {{ \"streamChat.Edit Message\" | translate }}\n    </div>\n    <button\n      class=\"str-chat__quoted-message-remove\"\n      data-testid=\"remove-quote\"\n      (click)=\"deselectMessageToEdit()\"\n      (keyup.enter)=\"deselectMessageToEdit()\"\n    >\n      <stream-icon-placeholder icon=\"close\"></stream-icon-placeholder>\n    </button>\n  </div>\n  <ng-container *ngIf=\"canSendMessages; else notAllowed\">\n    <div\n      class=\"\n        str-chat__message-input-inner\n        str-chat-angular__message-input-inner\n      \"\n    >\n      <ng-container\n        *ngIf=\"isFileUploadEnabled && isFileUploadAuthorized && canSendMessages\"\n      >\n        <ng-container\n          *ngTemplateOutlet=\"\n            customAttachmentUploadTemplate || defaultAttachmentUpload;\n            context: getAttachmentUploadContext()\n          \"\n        ></ng-container>\n        <ng-template #defaultAttachmentUpload>\n          <div\n            class=\"str-chat__file-input-container\"\n            data-testid=\"file-upload-button\"\n          >\n            <input\n              #fileInput\n              type=\"file\"\n              class=\"str-chat__file-input\"\n              data-testid=\"file-input\"\n              [multiple]=\"isMultipleFileUploadEnabled\"\n              id=\"{{ fileInputId }}\"\n              (change)=\"filesSelected(fileInput.files)\"\n            />\n            <label class=\"str-chat__file-input-label\" for=\"{{ fileInputId }}\">\n              <stream-icon-placeholder icon=\"attach\"></stream-icon-placeholder>\n            </label>\n          </div>\n        </ng-template>\n      </ng-container>\n      <div class=\"str-chat__message-textarea-container\">\n        <div\n          *ngIf=\"quotedMessage\"\n          data-testid=\"quoted-message-container\"\n          class=\"str-chat__quoted-message-preview\"\n        >\n          <stream-avatar-placeholder\n            data-testid=\"qouted-message-avatar\"\n            class=\"\n              str-chat-angular__avatar-host\n              str-chat__message-sender-avatar\n            \"\n            type=\"user\"\n            location=\"quoted-message-sender\"\n            [imageUrl]=\"quotedMessage.user?.image\"\n            [name]=\"quotedMessage.user?.name || quotedMessage.user?.id\"\n            [user]=\"quotedMessage.user || undefined\"\n          ></stream-avatar-placeholder>\n          <div\n            class=\"\n              quoted-message-preview-content-inner\n              str-chat__quoted-message-bubble\n            \"\n          >\n            <stream-attachment-list\n              *ngIf=\"\n                quotedMessage?.attachments && quotedMessage?.attachments?.length\n              \"\n              [attachments]=\"quotedMessageAttachments\"\n              [messageId]=\"quotedMessage.id\"\n            ></stream-attachment-list>\n            <div\n              class=\"str-chat__quoted-message-text\"\n              data-testid=\"quoted-message-text\"\n              [innerHTML]=\"\n                quotedMessage.translation ||\n                quotedMessage.html ||\n                quotedMessage.text\n              \"\n            ></div>\n          </div>\n        </div>\n        <ng-template\n          #defaultAttachmentsPreview\n          let-attachmentUploads$=\"attachmentUploads$\"\n          let-retryUploadHandler=\"retryUploadHandler\"\n          let-deleteUploadHandler=\"deleteUploadHandler\"\n        >\n          <stream-attachment-preview-list\n            class=\"str-chat__attachment-preview-list-angular-host\"\n            [attachmentUploads$]=\"attachmentUploads$\"\n            (retryAttachmentUpload)=\"retryUploadHandler($event)\"\n            (deleteAttachment)=\"deleteUploadHandler($event)\"\n          ></stream-attachment-preview-list>\n        </ng-template>\n        <ng-container\n          *ngTemplateOutlet=\"\n            attachmentPreviewListTemplate || defaultAttachmentsPreview;\n            context: getAttachmentPreviewListContext()\n          \"\n        ></ng-container>\n        <div class=\"str-chat__message-textarea-with-emoji-picker\">\n          <ng-container\n            streamTextarea\n            [componentRef]=\"textareaRef\"\n            [areMentionsEnabled]=\"areMentionsEnabled\"\n            [mentionScope]=\"mentionScope\"\n            [inputMode]=\"inputMode\"\n            [autoFocus]=\"autoFocus\"\n            [placeholder]=\"textareaPlaceholder\"\n            [(value)]=\"textareaValue\"\n            (valueChange)=\"typingStart$.next()\"\n            (send)=\"messageSent()\"\n            (userMentions)=\"mentionedUsers = $event\"\n          ></ng-container>\n          <ng-container *ngIf=\"emojiPickerTemplate\" data-testid=\"emoji-picker\">\n            <ng-container\n              *ngTemplateOutlet=\"\n                emojiPickerTemplate;\n                context: getEmojiPickerContext()\n              \"\n            ></ng-container>\n          </ng-container>\n        </div>\n      </div>\n      <button\n        *ngIf=\"canSendMessages && !isCooldownInProgress && displaySendButton\"\n        data-testid=\"send-button\"\n        class=\"str-chat__send-button\"\n        [disabled]=\"\n          (attachmentUploadInProgressCounter$ | async)! > 0 ||\n          (!textareaValue && (attachmentUploads$ | async)!.length === 0)\n        \"\n        (click)=\"messageSent()\"\n        (keyup.enter)=\"messageSent()\"\n      >\n        <stream-icon-placeholder icon=\"send\"></stream-icon-placeholder>\n      </button>\n      <div\n        *ngIf=\"isCooldownInProgress\"\n        class=\"str-chat__message-input-cooldown\"\n        data-testid=\"cooldown-timer\"\n      >\n        {{ cooldown$ | async }}\n      </div>\n    </div>\n  </ng-container>\n  <ng-template #notAllowed>\n    <div\n      class=\"str-chat__message-input-not-allowed\"\n      data-testid=\"disabled-textarea\"\n    >\n      {{ disabledTextareaText | translate }}\n    </div>\n  </ng-template>\n</div>\n" }]
        }], ctorParameters: function () { return [{ type: ChannelService }, { type: NotificationService }, { type: AttachmentService }, { type: MessageInputConfigService }, { type: i0.Type, decorators: [{
                    type: Inject,
                    args: [textareaInjectionToken]
                }] }, { type: i0.ComponentFactoryResolver }, { type: i0.ChangeDetectorRef }, { type: EmojiInputService }, { type: CustomTemplatesService }, { type: MessageActionsService }]; }, propDecorators: { isFileUploadEnabled: [{
                type: Input
            }], areMentionsEnabled: [{
                type: Input
            }], mentionScope: [{
                type: Input
            }], mode: [{
                type: Input
            }], isMultipleFileUploadEnabled: [{
                type: Input
            }], message: [{
                type: Input
            }], sendMessage$: [{
                type: Input
            }], inputMode: [{
                type: Input
            }], autoFocus: [{
                type: Input
            }], watchForMessageToEdit: [{
                type: Input
            }], displaySendButton: [{
                type: Input
            }], messageUpdate: [{
                type: Output
            }], class: [{
                type: HostBinding
            }], fileInput: [{
                type: ViewChild,
                args: ['fileInput']
            }], textareaAnchor: [{
                type: ViewChild,
                args: [TextareaDirective, { static: false }]
            }] } });

/**
 * The `Textarea` component is used by the [`MessageInput`](./MessageInputComponent.mdx) component to display the input HTML element where users can type their message.
 */
class TextareaComponent {
    constructor(emojiInputService, themeService) {
        this.emojiInputService = emojiInputService;
        this.themeService = themeService;
        this.class = 'str-chat__textarea str-chat__message-textarea-angular-host';
        /**
         * The value of the input HTML element.
         */
        this.value = '';
        /**
         * Placeholder of the textarea
         */
        this.placeholder = '';
        /**
         * Enables or disables auto focus on the textarea element
         */
        this.autoFocus = true;
        /**
         * Emits the current value of the input element when a user types.
         */
        this.valueChange = new EventEmitter();
        /**
         * Emits when a user triggers a message send event (this happens when they hit the `Enter` key).
         */
        this.send = new EventEmitter();
        this.subscriptions = [];
        this.isViewInited = false;
        this.subscriptions.push(this.emojiInputService.emojiInput$.subscribe((emoji) => {
            this.messageInput.nativeElement.focus();
            const { selectionStart } = this.messageInput.nativeElement;
            this.messageInput.nativeElement.setRangeText(emoji);
            this.messageInput.nativeElement.selectionStart =
                selectionStart + emoji.length;
            this.messageInput.nativeElement.selectionEnd =
                selectionStart + emoji.length;
            this.inputChanged();
        }));
    }
    ngOnChanges(changes) {
        if (changes.value && !this.value && this.messageInput) {
            this.messageInput.nativeElement.style.height = 'auto';
        }
        else if (changes.value &&
            this.value &&
            this.messageInput &&
            this.isViewInited) {
            setTimeout(() => {
                if (this.messageInput.nativeElement.scrollHeight > 0) {
                    this.adjustTextareaHeight();
                }
            }, 0);
        }
    }
    ngAfterViewInit() {
        this.isViewInited = true;
        if (this.messageInput.nativeElement.scrollHeight > 0) {
            this.adjustTextareaHeight();
        }
    }
    ngOnDestroy() {
        this.subscriptions.forEach((s) => s.unsubscribe());
    }
    inputChanged() {
        this.valueChange.emit(this.messageInput.nativeElement.value);
        this.adjustTextareaHeight();
    }
    enterHit(event) {
        if (this.inputMode === 'desktop') {
            event.preventDefault();
            this.send.next();
        }
    }
    adjustTextareaHeight() {
        this.messageInput.nativeElement.style.height = '';
        this.messageInput.nativeElement.style.height = `${this.messageInput.nativeElement.scrollHeight}px`;
    }
}
TextareaComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: TextareaComponent, deps: [{ token: EmojiInputService }, { token: ThemeService }], target: i0.ɵɵFactoryTarget.Component });
TextareaComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.0.4", type: TextareaComponent, selector: "stream-textarea", inputs: { value: "value", placeholder: "placeholder", inputMode: "inputMode", autoFocus: "autoFocus" }, outputs: { valueChange: "valueChange", send: "send" }, host: { properties: { "class": "this.class" } }, viewQueries: [{ propertyName: "messageInput", first: true, predicate: ["input"], descendants: true }], usesOnChanges: true, ngImport: i0, template: "<textarea\n  #input\n  data-testid=\"textarea\"\n  class=\"\n    rta__textarea\n    str-chat__textarea__textarea\n    str-chat__angular-textarea\n    str-chat__message-textarea\n  \"\n  rows=\"1\"\n  [value]=\"value || ''\"\n  [autofocus]=\"autoFocus\"\n  placeholder=\"{{ placeholder | translate }}\"\n  (input)=\"inputChanged()\"\n  (keydown.enter)=\"enterHit($event)\"\n></textarea>\n", dependencies: [{ kind: "pipe", type: i10.TranslatePipe, name: "translate" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: TextareaComponent, decorators: [{
            type: Component,
            args: [{ selector: 'stream-textarea', template: "<textarea\n  #input\n  data-testid=\"textarea\"\n  class=\"\n    rta__textarea\n    str-chat__textarea__textarea\n    str-chat__angular-textarea\n    str-chat__message-textarea\n  \"\n  rows=\"1\"\n  [value]=\"value || ''\"\n  [autofocus]=\"autoFocus\"\n  placeholder=\"{{ placeholder | translate }}\"\n  (input)=\"inputChanged()\"\n  (keydown.enter)=\"enterHit($event)\"\n></textarea>\n" }]
        }], ctorParameters: function () { return [{ type: EmojiInputService }, { type: ThemeService }]; }, propDecorators: { class: [{
                type: HostBinding
            }], value: [{
                type: Input
            }], placeholder: [{
                type: Input
            }], inputMode: [{
                type: Input
            }], autoFocus: [{
                type: Input
            }], valueChange: [{
                type: Output
            }], send: [{
                type: Output
            }], messageInput: [{
                type: ViewChild,
                args: ['input']
            }] } });

/**
 * The `TransliterationService` wraps the [@sindresorhus/transliterate](https://www.npmjs.com/package/@sindresorhus/transliterate) library
 */
class TransliterationService {
    constructor() { }
    /**
     *
     * @param s the string to be transliterated
     * @returns the result of the transliteration
     */
    transliterate(s) {
        return transliterate(s);
    }
}
TransliterationService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: TransliterationService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
TransliterationService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: TransliterationService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: TransliterationService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: function () { return []; } });

/**
 * The `AutocompleteTextarea` component is used by the [`MessageInput`](./MessageInputComponent.mdx) component to display the input HTML element where users can type their message.
 */
class AutocompleteTextareaComponent {
    constructor(channelService, chatClientService, transliterationService, emojiInputService, customTemplatesService, themeService, cdRef) {
        this.channelService = channelService;
        this.chatClientService = chatClientService;
        this.transliterationService = transliterationService;
        this.emojiInputService = emojiInputService;
        this.customTemplatesService = customTemplatesService;
        this.themeService = themeService;
        this.cdRef = cdRef;
        this.class = 'str-chat__textarea str-chat__message-textarea-angular-host';
        /**
         * The value of the input HTML element.
         */
        this.value = '';
        /**
         * Placeholder of the textarea
         */
        this.placeholder = '';
        /**
         * If true, users can mention other users in messages. You can also set this input on the [`MessageInput`](./MessageInputComponent.mdx/#inputs-and-outputs) component.
         */
        this.areMentionsEnabled = true;
        /**
         * The scope for user mentions, either members of the current channel of members of the application. You can also set this input on the [`MessageInput`](./MessageInputComponent.mdx/#inputs-and-outputs) component.
         */
        this.mentionScope = 'channel';
        /**
         * Enables or disables auto focus on the textarea element
         */
        this.autoFocus = true;
        /**
         * Emits the current value of the input element when a user types.
         */
        this.valueChange = new EventEmitter();
        /**
         * Emits when a user triggers a message send event (this happens when they hit the `Enter` key).
         */
        this.send = new EventEmitter();
        /**
         * Emits the array of users that are mentioned in the message, it is updated when a user mentions a new user or deletes a mention.
         */
        this.userMentions = new EventEmitter();
        this.autocompleteKey = 'autocompleteLabel';
        this.mentionTriggerChar = '@';
        this.commandTriggerChar = '/';
        this.autocompleteConfig = {
            mentions: [],
        };
        this.subscriptions = [];
        this.mentionedUsers = [];
        this.userMentionConfig = {
            triggerChar: this.mentionTriggerChar,
            dropUp: true,
            labelKey: this.autocompleteKey,
            returnTrigger: true,
            mentionFilter: (searchString, items) => this.filter(searchString, items),
            mentionSelect: (item, triggerChar) => this.itemSelectedFromAutocompleteList(item, triggerChar),
        };
        this.slashCommandConfig = {
            triggerChar: this.commandTriggerChar,
            dropUp: true,
            labelKey: 'name',
            returnTrigger: true,
            mentionFilter: (searchString, items) => this.filter(searchString, items),
            mentionSelect: (item, triggerChar) => this.itemSelectedFromAutocompleteList(item, triggerChar),
        };
        this.searchTerm$ = new BehaviorSubject('');
        this.isViewInited = false;
        this.searchTerm$.pipe(debounceTime(300)).subscribe((searchTerm) => {
            if (searchTerm.startsWith(this.mentionTriggerChar)) {
                void this.updateMentionOptions(searchTerm);
            }
        });
        this.subscriptions.push(this.channelService.activeChannel$.subscribe((channel) => {
            const commands = channel?.getConfig()?.commands || [];
            this.slashCommandConfig.items = commands.map((c) => ({
                ...c,
                [this.autocompleteKey]: c.name,
                type: 'command',
            }));
            this.mentionedUsers = [];
            this.userMentions.next([...this.mentionedUsers]);
            void this.updateMentionOptions(this.searchTerm$.getValue());
        }));
        this.subscriptions.push(this.emojiInputService.emojiInput$.subscribe((emoji) => {
            this.messageInput.nativeElement.focus();
            const { selectionStart } = this.messageInput.nativeElement;
            this.messageInput.nativeElement.setRangeText(emoji);
            this.messageInput.nativeElement.selectionStart =
                selectionStart + emoji.length;
            this.messageInput.nativeElement.selectionEnd =
                selectionStart + emoji.length;
            this.inputChanged();
        }));
        this.subscriptions.push(this.customTemplatesService.mentionAutocompleteItemTemplate$.subscribe((template) => (this.mentionAutocompleteItemTemplate = template)));
        this.subscriptions.push(this.customTemplatesService.commandAutocompleteItemTemplate$.subscribe((template) => (this.commandAutocompleteItemTemplate = template)));
        this.autocompleteConfig.mentions = [
            this.userMentionConfig,
            this.slashCommandConfig,
        ];
    }
    ngOnChanges(changes) {
        if (changes.areMentionsEnabled) {
            if (this.areMentionsEnabled) {
                this.autocompleteConfig.mentions = [
                    this.userMentionConfig,
                    this.slashCommandConfig,
                ];
                this.autocompleteConfig = { ...this.autocompleteConfig };
            }
            else {
                this.autocompleteConfig.mentions = [this.slashCommandConfig];
                this.autocompleteConfig = { ...this.autocompleteConfig };
            }
        }
        if (changes.mentionScope) {
            void this.updateMentionOptions(this.searchTerm$.getValue());
        }
        if (changes.value && !this.value && this.messageInput) {
            this.messageInput.nativeElement.style.height = 'auto';
            this.updateMentionedUsersFromText();
        }
        else if (changes.value &&
            this.value &&
            this.messageInput &&
            this.isViewInited) {
            setTimeout(() => {
                if (this.messageInput.nativeElement.scrollHeight > 0) {
                    this.adjustTextareaHeight();
                }
            }, 0);
        }
    }
    ngAfterViewInit() {
        this.isViewInited = true;
        if (this.messageInput.nativeElement.scrollHeight > 0) {
            this.adjustTextareaHeight();
        }
    }
    filter(searchString, items) {
        return items.filter((item) => this.transliterate(item.autocompleteLabel.toLowerCase()).includes(this.transliterate(searchString.toLowerCase())));
    }
    itemSelectedFromAutocompleteList(item, triggerChar = '') {
        if (triggerChar === this.mentionTriggerChar) {
            this.mentionedUsers.push((item.user ? item.user : item));
            this.userMentions.next([...this.mentionedUsers]);
        }
        return triggerChar + item.autocompleteLabel + ' ';
    }
    autcompleteSearchTermChanged(searchTerm) {
        if (searchTerm === this.mentionTriggerChar) {
            void this.updateMentionOptions();
        }
        else {
            this.searchTerm$.next(searchTerm);
        }
    }
    inputChanged() {
        this.valueChange.emit(this.messageInput.nativeElement.value);
        this.adjustTextareaHeight();
    }
    inputLeft() {
        this.updateMentionedUsersFromText();
    }
    enterHit(event) {
        if (this.inputMode === 'desktop') {
            event.preventDefault();
            this.updateMentionedUsersFromText();
            this.send.next();
        }
    }
    adjustTextareaHeight() {
        this.messageInput.nativeElement.style.height = '';
        this.messageInput.nativeElement.style.height = `${this.messageInput.nativeElement.scrollHeight}px`;
    }
    transliterate(s) {
        if (this.transliterationService) {
            return this.transliterationService.transliterate(s);
        }
        else {
            return s;
        }
    }
    async updateMentionOptions(searchTerm) {
        if (!this.areMentionsEnabled) {
            return;
        }
        searchTerm = searchTerm?.replace(this.mentionTriggerChar, '');
        const request = this.mentionScope === 'application'
            ? (s) => this.chatClientService.autocompleteUsers(s)
            : (s) => this.channelService.autocompleteMembers(s);
        const result = await request(searchTerm || '');
        const items = this.filter(searchTerm || '', result.map((i) => {
            const user = (i.user ? i.user : i);
            return {
                ...i,
                autocompleteLabel: user.name || user.id,
                type: 'mention',
            };
        }));
        this.userMentionConfig.items = items;
        this.autocompleteConfig.mentions = [
            this.userMentionConfig,
            this.slashCommandConfig,
        ];
        this.autocompleteConfig = { ...this.autocompleteConfig };
        this.cdRef.detectChanges();
    }
    updateMentionedUsersFromText() {
        const updatedMentionedUsers = [];
        this.mentionedUsers.forEach((u) => {
            const key = u.name || u.id;
            if (this.value.includes(`${this.mentionTriggerChar}${key}`)) {
                updatedMentionedUsers.push(u);
            }
        });
        if (updatedMentionedUsers.length !== this.mentionedUsers.length) {
            this.userMentions.next([...updatedMentionedUsers]);
            this.mentionedUsers = updatedMentionedUsers;
        }
    }
}
AutocompleteTextareaComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: AutocompleteTextareaComponent, deps: [{ token: ChannelService }, { token: ChatClientService }, { token: TransliterationService }, { token: EmojiInputService }, { token: CustomTemplatesService }, { token: ThemeService }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
AutocompleteTextareaComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.0.4", type: AutocompleteTextareaComponent, selector: "stream-autocomplete-textarea", inputs: { value: "value", placeholder: "placeholder", areMentionsEnabled: "areMentionsEnabled", inputMode: "inputMode", mentionScope: "mentionScope", autoFocus: "autoFocus" }, outputs: { valueChange: "valueChange", send: "send", userMentions: "userMentions" }, host: { properties: { "class": "this.class" } }, viewQueries: [{ propertyName: "messageInput", first: true, predicate: ["input"], descendants: true }], usesOnChanges: true, ngImport: i0, template: "<textarea\n  #input\n  data-testid=\"textarea\"\n  class=\"\n    rta__textarea\n    str-chat__textarea__textarea\n    str-chat__angular-textarea\n    str-chat__message-textarea\n  \"\n  rows=\"1\"\n  [value]=\"value || ''\"\n  [autofocus]=\"autoFocus\"\n  placeholder=\"{{ placeholder | translate }}\"\n  [mentionConfig]=\"autocompleteConfig\"\n  [mentionListTemplate]=\"autocompleteItem\"\n  (input)=\"inputChanged()\"\n  (keydown.enter)=\"enterHit($event)\"\n  (searchTerm)=\"autcompleteSearchTermChanged($event)\"\n  (blur)=\"inputLeft()\"\n></textarea>\n<ng-template #autocompleteItem let-item=\"item\">\n  <div class=\"rta rta__item str-chat__emojisearch__item\" [ngSwitch]=\"item.type\">\n    <div *ngSwitchCase=\"'mention'\" class=\"rta__entity\">\n      <ng-container\n        *ngTemplateOutlet=\"\n          mentionAutocompleteItemTemplate || defaultMentionTemplate;\n          context: { item: item }\n        \"\n      ></ng-container>\n    </div>\n    <div *ngSwitchCase=\"'command'\" class=\"rta__entity\">\n      <ng-container\n        *ngTemplateOutlet=\"\n          commandAutocompleteItemTemplate || defaultCommandTemplate;\n          context: { item: item }\n        \"\n      ></ng-container>\n    </div>\n  </div>\n</ng-template>\n\n<ng-template #defaultCommandTemplate let-item=\"item\">\n  <div class=\"str-chat__slash-command\">\n    <span class=\"str-chat__slash-command-header\">\n      <strong\n        class=\"str-chat__slash-command-name\"\n        data-testclass=\"command-name\"\n        >{{ item.name }}</strong\n      >\n      <span class=\"str-chat__slash-command-args\"\n        >/{{ item.name }} {{ item.args }}</span\n      >\n    </span>\n    <br />\n  </div>\n</ng-template>\n\n<ng-template #defaultMentionTemplate let-item=\"item\">\n  <div class=\"str-chat__user-item\">\n    <stream-avatar-placeholder\n      data-testclass=\"avatar\"\n      class=\"str-chat__avatar str-chat__avatar--circle\"\n      type=\"user\"\n      location=\"autocomplete-item\"\n      [imageUrl]=\"item.image || item.user?.image\"\n      [name]=\"item.autocompleteLabel\"\n      [user]=\"item.user || item\"\n    ></stream-avatar-placeholder>\n    <span data-testclass=\"username\" class=\"str-chat__user-item--name\">{{\n      item.autocompleteLabel\n    }}</span>\n  </div>\n</ng-template>\n", dependencies: [{ kind: "directive", type: i4.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: i4.NgSwitch, selector: "[ngSwitch]", inputs: ["ngSwitch"] }, { kind: "directive", type: i4.NgSwitchCase, selector: "[ngSwitchCase]", inputs: ["ngSwitchCase"] }, { kind: "directive", type: i8$1.MentionDirective, selector: "[mention], [mentionConfig]", inputs: ["mentionConfig", "mention", "mentionListTemplate"], outputs: ["searchTerm", "itemSelected", "opened", "closed"] }, { kind: "component", type: AvatarPlaceholderComponent, selector: "stream-avatar-placeholder", inputs: ["name", "imageUrl", "location", "channel", "user", "type", "initialsType", "showOnlineIndicator"] }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: AutocompleteTextareaComponent, decorators: [{
            type: Component,
            args: [{ selector: 'stream-autocomplete-textarea', template: "<textarea\n  #input\n  data-testid=\"textarea\"\n  class=\"\n    rta__textarea\n    str-chat__textarea__textarea\n    str-chat__angular-textarea\n    str-chat__message-textarea\n  \"\n  rows=\"1\"\n  [value]=\"value || ''\"\n  [autofocus]=\"autoFocus\"\n  placeholder=\"{{ placeholder | translate }}\"\n  [mentionConfig]=\"autocompleteConfig\"\n  [mentionListTemplate]=\"autocompleteItem\"\n  (input)=\"inputChanged()\"\n  (keydown.enter)=\"enterHit($event)\"\n  (searchTerm)=\"autcompleteSearchTermChanged($event)\"\n  (blur)=\"inputLeft()\"\n></textarea>\n<ng-template #autocompleteItem let-item=\"item\">\n  <div class=\"rta rta__item str-chat__emojisearch__item\" [ngSwitch]=\"item.type\">\n    <div *ngSwitchCase=\"'mention'\" class=\"rta__entity\">\n      <ng-container\n        *ngTemplateOutlet=\"\n          mentionAutocompleteItemTemplate || defaultMentionTemplate;\n          context: { item: item }\n        \"\n      ></ng-container>\n    </div>\n    <div *ngSwitchCase=\"'command'\" class=\"rta__entity\">\n      <ng-container\n        *ngTemplateOutlet=\"\n          commandAutocompleteItemTemplate || defaultCommandTemplate;\n          context: { item: item }\n        \"\n      ></ng-container>\n    </div>\n  </div>\n</ng-template>\n\n<ng-template #defaultCommandTemplate let-item=\"item\">\n  <div class=\"str-chat__slash-command\">\n    <span class=\"str-chat__slash-command-header\">\n      <strong\n        class=\"str-chat__slash-command-name\"\n        data-testclass=\"command-name\"\n        >{{ item.name }}</strong\n      >\n      <span class=\"str-chat__slash-command-args\"\n        >/{{ item.name }} {{ item.args }}</span\n      >\n    </span>\n    <br />\n  </div>\n</ng-template>\n\n<ng-template #defaultMentionTemplate let-item=\"item\">\n  <div class=\"str-chat__user-item\">\n    <stream-avatar-placeholder\n      data-testclass=\"avatar\"\n      class=\"str-chat__avatar str-chat__avatar--circle\"\n      type=\"user\"\n      location=\"autocomplete-item\"\n      [imageUrl]=\"item.image || item.user?.image\"\n      [name]=\"item.autocompleteLabel\"\n      [user]=\"item.user || item\"\n    ></stream-avatar-placeholder>\n    <span data-testclass=\"username\" class=\"str-chat__user-item--name\">{{\n      item.autocompleteLabel\n    }}</span>\n  </div>\n</ng-template>\n" }]
        }], ctorParameters: function () { return [{ type: ChannelService }, { type: ChatClientService }, { type: TransliterationService }, { type: EmojiInputService }, { type: CustomTemplatesService }, { type: ThemeService }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { class: [{
                type: HostBinding
            }], value: [{
                type: Input
            }], placeholder: [{
                type: Input
            }], areMentionsEnabled: [{
                type: Input
            }], inputMode: [{
                type: Input
            }], mentionScope: [{
                type: Input
            }], autoFocus: [{
                type: Input
            }], valueChange: [{
                type: Output
            }], send: [{
                type: Output
            }], userMentions: [{
                type: Output
            }], messageInput: [{
                type: ViewChild,
                args: ['input']
            }] } });

const getGroupStyles = (message, previousMessage, nextMessage, options = {
    noGroupByUser: false,
    lastReadMessageId: undefined,
    noGroupByReadState: false,
}) => {
    if (options.noGroupByUser ||
        (message.attachments && message.attachments.length !== 0))
        return 'single';
    const isTopMessage = !previousMessage ||
        !isOnSameDay(previousMessage.created_at, message.created_at) ||
        previousMessage.type === 'system' ||
        (previousMessage.attachments &&
            previousMessage.attachments?.length !== 0) ||
        message.user?.id !== previousMessage.user?.id ||
        previousMessage.type === 'error' ||
        previousMessage.deleted_at ||
        (previousMessage.id === options.lastReadMessageId &&
            !options.noGroupByReadState) ||
        previousMessage.message_text_updated_at ||
        (message.reaction_counts &&
            Object.keys(message.reaction_counts).length > 0);
    const isBottomMessage = !nextMessage ||
        !isOnSameDay(message.created_at, nextMessage.created_at) ||
        nextMessage.type === 'system' ||
        (nextMessage.attachments && nextMessage.attachments?.length !== 0) ||
        message.user?.id !== nextMessage.user?.id ||
        nextMessage.type === 'error' ||
        nextMessage.deleted_at ||
        (message.id === options.lastReadMessageId && !options.noGroupByReadState) ||
        message.message_text_updated_at ||
        (nextMessage.reaction_counts &&
            Object.keys(nextMessage.reaction_counts).length > 0);
    if (!isTopMessage && !isBottomMessage) {
        if (message.deleted_at || message.type === 'error')
            return 'single';
        return 'middle';
    }
    if (isBottomMessage) {
        if (isTopMessage || message.deleted_at || message.type === 'error')
            return 'single';
        return 'bottom';
    }
    if (isTopMessage)
        return 'top';
    return '';
};
const isOnSameDay = (date1, date2) => {
    return (date1.getFullYear() === date2.getFullYear() &&
        date1.getMonth() === date2.getMonth() &&
        date1.getDate() === date2.getDate());
};

/**
 * The `MessageList` component renders a scrollable list of messages.
 */
class MessageListComponent {
    constructor(channelService, chatClientService, customTemplatesService, dateParser, ngZone, cdRef) {
        this.channelService = channelService;
        this.chatClientService = chatClientService;
        this.customTemplatesService = customTemplatesService;
        this.dateParser = dateParser;
        this.ngZone = ngZone;
        this.cdRef = cdRef;
        /**
         * Determines if the message list should display channel messages or [thread messages](https://getstream.io/chat/docs/javascript/threads/?language=javascript).
         */
        this.mode = 'main';
        /**
         * The direction of the messages in the list, `bottom-to-top` means newest message is at the bottom of the message list and users scroll upwards to load older messages
         */
        this.direction = 'bottom-to-top';
        /**
         * You can hide the "jump to latest" button while scrolling. A potential use-case for this input would be to [workaround a known issue on iOS Safar webview](https://github.com/GetStream/stream-chat-angular/issues/418)
         *
         */
        this.hideJumpToLatestButtonDuringScroll = false;
        /**
         * If `true` date separators will be displayed
         */
        this.displayDateSeparator = true;
        /**
         * If `true` unread indicator will be displayed
         */
        this.displayUnreadSeparator = true;
        /**
         * If date separators are displayed, you can set the horizontal position of the date text.
         */
        this.dateSeparatorTextPos = 'center';
        /**
         * `last-message` option will open the message list at the last message, `last-read-message` will open the list at the last unread message. This option only works if mode is `main`.
         */
        this.openMessageListAt = 'last-message';
        /**
         * If the user has unread messages when they open the channel the UI shows the unread indicator / notification which features the unread count by default. This count will be increased every time a user receives a new message. If you don't want to show the unread count, you can turn that off.
         *
         * This is only applicable for `main` mode, as threads doesn't have read infromation.
         */
        this.hideUnreadCountForNotificationAndIndicator = false;
        /**
         * You can turn on and off the loading indicator that signals to users that more messages are being loaded to the message list
         */
        this.displayLoadingIndicator = true;
        /**
         * @internal
         */
        this.limitNumberOfMessagesInList = true;
        this.emptyMainMessageListTemplate = null;
        this.emptyThreadMessageListTemplate = null;
        this.enabledMessageActions = [];
        this.isEmpty = true;
        this.newMessageCountWhileBeingScrolled = 0;
        this.groupStyles = [];
        this.isNextMessageOnSeparateDate = [];
        this.isLoading = false;
        this.isUnreadNotificationVisible = true;
        this.isJumpingToLatestUnreadMessage = false;
        this.isJumpToLatestButtonVisible = true;
        this.scroll$ = new Subject();
        this.subscriptions = [];
        this.isLatestMessageInList = true;
        this.parsedDates = new Map();
        this.isViewInited = false;
        this.isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
        this.forceRepaintSubject = new Subject();
        this.messageNotificationJumpClicked = () => {
            this.jumpToFirstUnreadMessage();
            this.isUnreadNotificationVisible = false;
        };
        this.messageNotificationDismissClicked = () => {
            this.isUnreadNotificationVisible = false;
        };
        this.usersTypingInChannel$ = this.channelService.usersTypingInChannel$;
        this.usersTypingInThread$ = this.channelService.usersTypingInThread$;
    }
    get class() {
        return `str-chat-angular__main-panel-inner str-chat-angular__message-list-host str-chat__main-panel-inner ${this.isEmpty ? 'str-chat-angular__message-list-host--empty' : ''}`;
    }
    ngOnInit() {
        this.subscriptions.push(this.forceRepaintSubject.pipe(throttleTime(1000)).subscribe(() => {
            this.forceRepaint();
        }));
        this.subscriptions.push(this.channelService.activeChannel$.subscribe((channel) => {
            this.chatClientService.chatClient?.logger?.('info', `${channel?.cid || 'undefined'} selected`, { tags: `message list ${this.mode}` });
            let isNewChannel = false;
            if (this.channelId !== channel?.id) {
                isNewChannel = true;
                if (this.checkIfUnreadNotificationIsVisibleTimeout) {
                    clearTimeout(this.checkIfUnreadNotificationIsVisibleTimeout);
                }
                this.isUnreadNotificationVisible = false;
                this.chatClientService?.chatClient?.logger?.('info', `new channel is different from prev channel, reseting scroll state`, { tags: `message list ${this.mode}` });
                this.parsedDates = new Map();
                if (this.messageRemoveTimeout) {
                    clearTimeout(this.messageRemoveTimeout);
                }
                this.resetScrollState();
                this.channelId = channel?.id;
                if (this.isViewInited) {
                    this.cdRef.detectChanges();
                }
            }
            if (this.mode === 'main') {
                const lastReadMessageId = this.channelService.activeChannelLastReadMessageId;
                const unreadCount = this.channelService.activeChannelUnreadCount;
                if (lastReadMessageId !== this.lastReadMessageId ||
                    unreadCount !== this.unreadCount) {
                    this.lastReadMessageId = lastReadMessageId;
                    this.unreadCount = unreadCount || 0;
                    if (isNewChannel && this.lastReadMessageId) {
                        if (this.openMessageListAt === 'last-read-message') {
                            this.jumpToFirstUnreadMessage();
                        }
                        else {
                            // Wait till messages and the unread banner is rendered
                            // If unread banner isn't visible on the screen, we display the unread notificaion
                            setTimeout(() => {
                                const bannerElement = document.getElementById('stream-chat-new-message-indicator');
                                if (!bannerElement ||
                                    bannerElement?.offsetTop <
                                        this.scrollContainer?.nativeElement?.scrollHeight -
                                            this.scrollContainer?.nativeElement?.clientHeight) {
                                    this.isUnreadNotificationVisible = true;
                                    if (this.isViewInited) {
                                        this.cdRef.detectChanges();
                                    }
                                }
                            }, 100);
                        }
                    }
                    if (this.isViewInited) {
                        this.cdRef.detectChanges();
                    }
                }
            }
            else if (this.lastReadMessageId) {
                this.lastReadMessageId = undefined;
                this.unreadCount = 0;
                if (this.isViewInited) {
                    this.cdRef.detectChanges();
                }
            }
            const capabilites = channel?.data?.own_capabilities;
            const capabilitesString = [...(capabilites || [])].sort().join('');
            const enabledActionsString = [...(this.enabledMessageActions || [])]
                .sort()
                .join('');
            if (capabilitesString !== enabledActionsString) {
                this.enabledMessageActions = capabilites || [];
                if (this.isViewInited) {
                    this.cdRef.detectChanges();
                }
            }
            this.newMessageSubscription?.unsubscribe();
            if (channel) {
                this.newMessageSubscription = channel.on('message.new', (event) => {
                    // If we display main channel messages and we're switched to an older message set -> use message.new event to update unread count and detect new messages sent by current user
                    if (!event.message ||
                        channel.state.messages === channel.state.latestMessages ||
                        this.mode === 'thread') {
                        return;
                    }
                    this.newMessageReceived({
                        id: event.message.id,
                        user: event.message.user,
                        created_at: new Date(event.message.created_at || ''),
                    });
                });
            }
        }));
        this.subscriptions.push(this.channelService.activeParentMessage$.subscribe((message) => {
            if (message &&
                this.parentMessage &&
                message.id !== this.parentMessage.id &&
                this.mode === 'thread') {
                this.resetScrollState();
            }
            if (this.parentMessage === message) {
                return;
            }
            this.parentMessage = message;
            if (this.isViewInited) {
                this.cdRef.detectChanges();
            }
        }));
        this.subscriptions.push(this.customTemplatesService.messageTemplate$.subscribe((template) => {
            if (this.messageTemplate === template) {
                return;
            }
            this.messageTemplate = template;
            if (this.isViewInited) {
                this.cdRef.detectChanges();
            }
        }));
        this.subscriptions.push(this.customTemplatesService.dateSeparatorTemplate$.subscribe((template) => {
            if (this.customDateSeparatorTemplate === template) {
                return;
            }
            this.customDateSeparatorTemplate = template;
            if (this.isViewInited) {
                this.cdRef.detectChanges();
            }
        }));
        this.subscriptions.push(this.customTemplatesService.newMessagesIndicatorTemplate$.subscribe((template) => {
            if (this.customnewMessagesIndicatorTemplate === template) {
                return;
            }
            this.customnewMessagesIndicatorTemplate = template;
            if (this.isViewInited) {
                this.cdRef.detectChanges();
            }
        }));
        this.subscriptions.push(this.customTemplatesService.newMessagesNotificationTemplate$.subscribe((template) => {
            if (this.customnewMessagesNotificationTemplate === template) {
                return;
            }
            this.customnewMessagesNotificationTemplate = template;
            if (this.isViewInited) {
                this.cdRef.detectChanges();
            }
        }));
        this.subscriptions.push(this.customTemplatesService.typingIndicatorTemplate$.subscribe((template) => {
            if (this.typingIndicatorTemplate === template) {
                return;
            }
            this.typingIndicatorTemplate = template;
            if (this.isViewInited) {
                this.cdRef.detectChanges();
            }
        }));
        this.subscriptions.push(this.channelService.jumpToMessage$
            .pipe(filter((config) => !!config.id))
            .subscribe((config) => {
            let messageId = undefined;
            if (this.messageRemoveTimeout) {
                clearTimeout(this.messageRemoveTimeout);
            }
            if (this.mode === 'main') {
                messageId = config.parentId || config.id;
            }
            else if (config.parentId) {
                messageId = config.id;
            }
            this.chatClientService.chatClient?.logger?.('info', `Jumping to ${messageId || ''}`, { tags: `message list ${this.mode}` });
            if (messageId) {
                if (messageId === 'latest') {
                    this.scrollToLatestMessage();
                    if (this.isViewInited) {
                        this.cdRef.detectChanges();
                    }
                }
                else {
                    if (this.isJumpingToLatestUnreadMessage) {
                        this.scrollMessageIntoView(this.firstUnreadMessageId || messageId);
                        this.highlightedMessageId =
                            this.firstUnreadMessageId || messageId;
                    }
                    else {
                        this.scrollMessageIntoView(messageId);
                        this.highlightedMessageId = messageId;
                    }
                }
            }
            this.channelService.clearMessageJump();
        }));
        this.subscriptions.push(this.customTemplatesService.emptyMainMessageListPlaceholder$.subscribe((template) => {
            const isChanged = this.emptyMainMessageListTemplate !== template;
            this.emptyMainMessageListTemplate = template || null;
            if (isChanged && this.isViewInited) {
                this.cdRef.detectChanges();
            }
        }));
        this.subscriptions.push(this.customTemplatesService.emptyThreadMessageListPlaceholder$.subscribe((template) => {
            const isChanged = this.emptyThreadMessageListTemplate !== template;
            this.emptyThreadMessageListTemplate = template || null;
            if (isChanged && this.isViewInited) {
                this.cdRef.detectChanges();
            }
        }));
        this.setMessages$();
    }
    ngOnChanges(changes) {
        if (changes.mode || changes.direction) {
            this.setMessages$();
        }
        if (changes.direction) {
            if (this.scrollContainer?.nativeElement) {
                this.jumpToLatestMessage();
            }
        }
    }
    ngAfterViewInit() {
        this.isViewInited = true;
        this.ngZone.runOutsideAngular(() => {
            this.scrollContainer.nativeElement.addEventListener('scroll', () => this.scrolled());
        });
    }
    ngAfterViewChecked() {
        if (this.highlightedMessageId) {
            // Turn off programatic scroll adjustments while jump to message is in progress
            this.hasNewMessages = false;
            this.olderMassagesLoaded = false;
        }
        if (this.direction === 'top-to-bottom') {
            if (this.hasNewMessages &&
                (this.isNewMessageSentByUser || !this.isUserScrolled)) {
                this.isLatestMessageInList
                    ? this.scrollToTop()
                    : this.jumpToLatestMessage();
                this.hasNewMessages = false;
                this.containerHeight = this.scrollContainer.nativeElement.scrollHeight;
            }
        }
        else {
            if (this.hasNewMessages) {
                if (!this.isUserScrolled || this.isNewMessageSentByUser) {
                    this.chatClientService.chatClient?.logger?.('info', `User has new messages, and not scrolled or sent new messages, therefore we ${this.isLatestMessageInList ? 'scroll' : 'jump'} to latest message`, { tags: `message list ${this.mode}` });
                    this.isLatestMessageInList
                        ? this.scrollToBottom()
                        : this.jumpToLatestMessage();
                }
                this.hasNewMessages = false;
                this.containerHeight = this.scrollContainer.nativeElement.scrollHeight;
            }
            else if (this.olderMassagesLoaded) {
                this.chatClientService.chatClient?.logger?.('info', `Older messages are loaded, we preserve the scroll position`, { tags: `message list ${this.mode}` });
                this.preserveScrollbarPosition();
                this.containerHeight = this.scrollContainer.nativeElement.scrollHeight;
                this.olderMassagesLoaded = false;
            }
            else if (this.getScrollPosition() !== 'bottom' &&
                !this.isUserScrolled &&
                !this.highlightedMessageId) {
                this.chatClientService.chatClient?.logger?.('info', `Container grew and user didn't scroll therefore we ${this.isLatestMessageInList ? 'scroll' : 'jump'} to latest message`, { tags: `message list ${this.mode}` });
                this.isLatestMessageInList
                    ? this.scrollToBottom()
                    : this.jumpToLatestMessage();
                this.containerHeight = this.scrollContainer.nativeElement.scrollHeight;
            }
        }
    }
    ngOnDestroy() {
        this.subscriptions.forEach((s) => s.unsubscribe());
        this.newMessageSubscription?.unsubscribe();
        if (this.scrollEndTimeout) {
            clearTimeout(this.scrollEndTimeout);
        }
        if (this.checkIfUnreadNotificationIsVisibleTimeout) {
            clearTimeout(this.checkIfUnreadNotificationIsVisibleTimeout);
        }
        if (this.jumpToLatestButtonVisibilityTimeout) {
            clearTimeout(this.jumpToLatestButtonVisibilityTimeout);
        }
        if (this.messageRemoveTimeout) {
            clearTimeout(this.messageRemoveTimeout);
        }
        this.removeOldMessagesSubscription?.unsubscribe();
    }
    trackByMessageId(index, item) {
        return item.id;
    }
    trackByUserId(index, user) {
        return user.id;
    }
    jumpToLatestMessage() {
        void this.channelService.jumpToMessage('latest', this.mode === 'thread' ? this.parentMessage?.id : undefined);
    }
    scrollToBottom() {
        this.scrollContainer.nativeElement.scrollTop =
            this.scrollContainer.nativeElement.scrollHeight + 0.1;
        if (this.isSafari) {
            this.forceRepaintSubject.next();
        }
    }
    scrollToTop() {
        this.scrollContainer.nativeElement.scrollTop = 0;
    }
    scrolled() {
        if (this.scrollContainer.nativeElement.scrollHeight ===
            this.scrollContainer.nativeElement.clientHeight) {
            if (this.isJumpToLatestButtonVisible) {
                this.isJumpToLatestButtonVisible = false;
                this.newMessageCountWhileBeingScrolled = 0;
                this.cdRef.detectChanges();
            }
            return;
        }
        this.scroll$.next();
        const scrollPosition = this.getScrollPosition();
        this.chatClientService.chatClient?.logger?.('info', `Scrolled - scroll position: ${scrollPosition}, container height: ${this.scrollContainer.nativeElement.scrollHeight}`, { tags: `message list ${this.mode}` });
        const isUserScrolled = (this.direction === 'bottom-to-top'
            ? scrollPosition !== 'bottom'
            : scrollPosition !== 'top') || !this.isLatestMessageInList;
        if (this.isUserScrolled !== isUserScrolled) {
            this.ngZone.run(() => {
                this.isUserScrolled = isUserScrolled;
                if (!this.isUserScrolled) {
                    this.newMessageCountWhileBeingScrolled = 0;
                }
                this.cdRef.detectChanges();
            });
        }
        if (this.hideJumpToLatestButtonDuringScroll) {
            if (this.isJumpToLatestButtonVisible) {
                this.isJumpToLatestButtonVisible = false;
                this.cdRef.detectChanges();
            }
            if (this.jumpToLatestButtonVisibilityTimeout) {
                clearTimeout(this.jumpToLatestButtonVisibilityTimeout);
            }
            this.jumpToLatestButtonVisibilityTimeout = setTimeout(() => {
                if (this.isUserScrolled) {
                    this.isJumpToLatestButtonVisible = true;
                    this.jumpToLatestButtonVisibilityTimeout = undefined;
                    this.cdRef.detectChanges();
                }
            }, 100);
        }
        if (this.shouldLoadMoreMessages(scrollPosition)) {
            this.ngZone.run(() => {
                this.containerHeight = this.scrollContainer.nativeElement.scrollHeight;
                let direction;
                if (this.direction === 'top-to-bottom') {
                    direction = scrollPosition === 'top' ? 'newer' : 'older';
                }
                else {
                    direction = scrollPosition === 'top' ? 'older' : 'newer';
                }
                const result = this.mode === 'main'
                    ? this.channelService.loadMoreMessages(direction)
                    : this.channelService.loadMoreThreadReplies(direction);
                if (result) {
                    this.chatClientService.chatClient?.logger?.('info', `Displaying loading indicator`, { tags: `message list ${this.mode}` });
                    this.isLoading = true;
                    result.catch?.(() => {
                        this.isLoading = false;
                    });
                }
                this.cdRef.detectChanges();
            });
        }
        this.prevScrollTop = this.scrollContainer.nativeElement.scrollTop;
    }
    jumpToFirstUnreadMessage() {
        if (!this.lastReadMessageId) {
            return;
        }
        this.isJumpingToLatestUnreadMessage = true;
        void this.channelService.jumpToMessage(this.lastReadMessageId);
    }
    getTypingIndicatorContext() {
        return {
            usersTyping$: this.usersTyping$,
        };
    }
    getTypingIndicatorText(users) {
        const text = listUsers(users);
        return text;
    }
    isSentByCurrentUser(message) {
        if (!message) {
            return false;
        }
        return message.user?.id === this.chatClientService.chatClient.user?.id;
    }
    parseDate(date) {
        if (this.parsedDates.has(date)) {
            return this.parsedDates.get(date);
        }
        const parsedDate = this.dateParser.parseDate(date);
        this.parsedDates.set(date, parsedDate);
        return parsedDate;
    }
    get replyCountParam() {
        return { replyCount: this.parentMessage?.reply_count };
    }
    get emptyListTemplate() {
        return this.mode === 'main'
            ? this.emptyMainMessageListTemplate
            : this.emptyThreadMessageListTemplate;
    }
    preserveScrollbarPosition() {
        this.scrollContainer.nativeElement.scrollTop =
            (this.prevScrollTop || 0) +
                (this.scrollContainer.nativeElement.scrollHeight - this.containerHeight);
    }
    forceRepaint() {
        // Solves the issue of empty screen on Safari when scrolling
        this.scrollContainer.nativeElement.style.display = 'none';
        this.scrollContainer.nativeElement.offsetHeight; // no need to store this anywhere, the reference is enough
        this.scrollContainer.nativeElement.style.display = '';
    }
    getScrollPosition() {
        let position = 'middle';
        if (Math.floor(this.scrollContainer.nativeElement.scrollTop) <=
            (this.parentMessageElement?.nativeElement.clientHeight || 0) &&
            (this.prevScrollTop === undefined ||
                this.prevScrollTop >
                    (this.parentMessageElement?.nativeElement.clientHeight || 0))) {
            position = 'top';
        }
        else if (Math.ceil(this.scrollContainer.nativeElement.scrollTop) +
            this.scrollContainer.nativeElement.clientHeight +
            1 >=
            this.scrollContainer.nativeElement.scrollHeight) {
            position = 'bottom';
        }
        return position;
    }
    shouldLoadMoreMessages(scrollPosition) {
        return (scrollPosition !== 'middle' &&
            !this.highlightedMessageId &&
            !this.isLoading);
    }
    setMessages$() {
        this.messages$ = (this.mode === 'main'
            ? this.channelService.activeChannelMessages$
            : this.channelService.activeThreadMessages$).pipe(tap((messages) => {
            if (this.isLoading) {
                this.isLoading = false;
            }
            if (messages.length === 0) {
                this.chatClientService.chatClient?.logger?.('info', `Empty messages array, reseting scroll state`, {
                    tags: `message list ${this.mode}`,
                });
                this.resetScrollState();
                return;
            }
            if (this.isEmpty) {
                // cdRef.detectChanges() isn't enough here, test will fail
                setTimeout(() => (this.isEmpty = false), 0);
            }
            this.chatClientService.chatClient?.logger?.('info', `Received one or more messages`, {
                tags: `message list ${this.mode}`,
            });
            const currentLatestMessageInState = messages[messages.length - 1];
            this.newMessageReceived(currentLatestMessageInState);
            const currentOldestMessage = messages[0];
            if (!this.oldestMessage ||
                !messages.find((m) => m.id === this.oldestMessage.id)) {
                this.oldestMessage = currentOldestMessage;
            }
            else if (this.oldestMessage.created_at.getTime() >
                currentOldestMessage.created_at.getTime()) {
                this.oldestMessage = currentOldestMessage;
                this.olderMassagesLoaded = true;
            }
        }), tap((messages) => {
            if (this.isJumpingToLatestUnreadMessage &&
                !this.firstUnreadMessageId &&
                this.lastReadMessageId) {
                const lastReadIndex = messages.findIndex((m) => m.id === this.lastReadMessageId);
                this.firstUnreadMessageId =
                    messages[lastReadIndex + 1]?.id || this.lastReadMessageId;
            }
        }), tap((messages) => (this.lastSentMessageId = [...messages]
            .reverse()
            .find((m) => m.user?.id === this.chatClientService.chatClient?.user?.id &&
            m.status !== 'sending')?.id)), tap((messages) => {
            this.isLatestMessageInList =
                !this.latestMessage ||
                    messages.length === 0 ||
                    messages[messages.length - 1].id === this.latestMessage.id ||
                    this.mode === 'thread';
            if (!this.isLatestMessageInList) {
                this.isUserScrolled = true;
            }
        }), map((messages) => this.direction === 'bottom-to-top' ? messages : [...messages].reverse()), tap((messages) => {
            this.groupStyles = messages.map((m, i) => getGroupStyles(m, messages[i - 1], messages[i + 1], {
                lastReadMessageId: this.lastReadMessageId,
            }));
            this.isNextMessageOnSeparateDate = messages.map((m, i) => this.checkIfOnSeparateDates(m, messages[i + 1]));
        }), shareReplay(1));
        this.removeOldMessagesSubscription?.unsubscribe();
        this.removeOldMessagesSubscription = combineLatest([
            this.channelService.jumpToMessage$,
            this.messages$,
        ]).subscribe(([jumpToMessage, messages]) => {
            if (this.limitNumberOfMessagesInList &&
                this.mode === 'main' &&
                messages.length >
                    ChannelService.MAX_MESSAGE_COUNT_IN_MESSAGE_LIST * 0.5 &&
                !this.isUserScrolled &&
                !jumpToMessage?.id &&
                this.isLatestMessageInList) {
                if (this.messageRemoveTimeout) {
                    clearTimeout(this.messageRemoveTimeout);
                }
                if (messages.length >= ChannelService.MAX_MESSAGE_COUNT_IN_MESSAGE_LIST) {
                    this.channelService.removeOldMessageFromMessageList();
                }
                else {
                    this.messageRemoveTimeout = setTimeout(() => {
                        if (this.limitNumberOfMessagesInList &&
                            this.mode === 'main' &&
                            messages.length >
                                ChannelService.MAX_MESSAGE_COUNT_IN_MESSAGE_LIST * 0.5 &&
                            !this.isUserScrolled &&
                            !this.highlightedMessageId &&
                            this.isLatestMessageInList) {
                            this.channelService.removeOldMessageFromMessageList();
                        }
                    }, 1500);
                }
            }
        });
    }
    resetScrollState() {
        this.isEmpty = true;
        this.latestMessage = undefined;
        this.hasNewMessages = true;
        this.isUserScrolled = false;
        this.containerHeight = undefined;
        this.olderMassagesLoaded = false;
        this.oldestMessage = undefined;
        this.newMessageCountWhileBeingScrolled = 0;
        this.prevScrollTop = undefined;
        this.isNewMessageSentByUser = undefined;
        this.isLatestMessageInList = true;
    }
    get usersTyping$() {
        return this.mode === 'thread'
            ? this.usersTypingInThread$
            : this.usersTypingInChannel$;
    }
    scrollMessageIntoView(messageId, withRetry = true) {
        const element = document.getElementById(messageId);
        if (!element && withRetry) {
            // If the message was newly inserted into activeChannelMessages$, the message will be rendered after the current change detection cycle -> wait for this cycle to complete
            setTimeout(() => this.scrollMessageIntoView(messageId, false));
        }
        else if (element) {
            element.scrollIntoView({
                block: 'center',
            });
            setTimeout(() => {
                this.highlightedMessageId = undefined;
                this.firstUnreadMessageId = undefined;
                this.isJumpingToLatestUnreadMessage = false;
                this.cdRef.detectChanges();
            }, 1000);
        }
    }
    scrollToLatestMessage(withRetry = true) {
        if (document.getElementById(this.latestMessage.id)) {
            this.direction === 'bottom-to-top'
                ? this.scrollToBottom()
                : this.scrollToTop();
        }
        else if (withRetry) {
            // If the message was newly inserted into activeChannelMessages$, the message will be rendered after the current change detection cycle -> wait for this cycle to complete
            setTimeout(() => this.scrollToLatestMessage(false), 0);
        }
    }
    newMessageReceived(message) {
        const latestMessages = this.channelService.activeChannel?.state?.latestMessages;
        if (!this.latestMessage ||
            this.latestMessage.created_at?.getTime() < message.created_at.getTime() ||
            (this.mode === 'main' &&
                latestMessages &&
                this.latestMessage &&
                latestMessages[latestMessages.length - 1]?.id !== this.latestMessage.id)) {
            this.chatClientService.chatClient?.logger?.('info', `Received new message`, { tags: `message list ${this.mode}` });
            const isNewChannel = !this.latestMessage;
            this.latestMessage = message;
            this.hasNewMessages = true;
            this.isNewMessageSentByUser =
                message.user?.id === this.chatClientService.chatClient?.user?.id;
            if (this.isUserScrolled) {
                this.newMessageCountWhileBeingScrolled++;
            }
            if (!this.isNewMessageSentByUser &&
                this.unreadCount !== undefined &&
                !isNewChannel) {
                this.unreadCount++;
            }
            this.cdRef.detectChanges();
        }
    }
    checkIfOnSeparateDates(message, nextMessage) {
        if (!message || !nextMessage) {
            return false;
        }
        return isOnSeparateDate(message.created_at, nextMessage.created_at);
    }
}
MessageListComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: MessageListComponent, deps: [{ token: ChannelService }, { token: ChatClientService }, { token: CustomTemplatesService }, { token: DateParserService }, { token: i0.NgZone }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
MessageListComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.0.4", type: MessageListComponent, selector: "stream-message-list", inputs: { mode: "mode", direction: "direction", hideJumpToLatestButtonDuringScroll: "hideJumpToLatestButtonDuringScroll", displayDateSeparator: "displayDateSeparator", displayUnreadSeparator: "displayUnreadSeparator", dateSeparatorTextPos: "dateSeparatorTextPos", openMessageListAt: "openMessageListAt", hideUnreadCountForNotificationAndIndicator: "hideUnreadCountForNotificationAndIndicator", displayLoadingIndicator: "displayLoadingIndicator", limitNumberOfMessagesInList: "limitNumberOfMessagesInList" }, host: { properties: { "class": "this.class" } }, viewQueries: [{ propertyName: "scrollContainer", first: true, predicate: ["scrollContainer"], descendants: true }, { propertyName: "parentMessageElement", first: true, predicate: ["parentMessageElement"], descendants: true }], usesOnChanges: true, ngImport: i0, template: "<ng-container\n  *ngIf=\"\n    lastReadMessageId &&\n    isUnreadNotificationVisible &&\n    openMessageListAt === 'last-message' &&\n    displayUnreadSeparator\n  \"\n>\n  <ng-container\n    *ngTemplateOutlet=\"\n      customnewMessagesNotificationTemplate ||\n        defaultUnreadMessagesNotification;\n      context: {\n        unreadCount: unreadCount,\n        onDismiss: messageNotificationDismissClicked,\n        onJump: messageNotificationJumpClicked\n      }\n    \"\n  ></ng-container>\n</ng-container>\n<ng-template\n  #defaultUnreadMessagesNotification\n  let-unreadCount=\"unreadCount\"\n  let-onDismiss=\"onDismiss\"\n  let-onJump=\"onJump\"\n>\n  <div\n    class=\"str-chat__unread-messages-notification\"\n    data-testid=\"unread-messages-notification\"\n  >\n    <button\n      data-testid=\"unread-messages-notification-jump-to-message\"\n      (click)=\"onJump()\"\n    >\n      <ng-container\n        *ngIf=\"\n          unreadCount > 0 && !hideUnreadCountForNotificationAndIndicator;\n          else noUnreadCount\n        \"\n      >\n        {{\n          (unreadCount === 1\n            ? \"streamChat.\\{\\{count\\}\\} unread message\"\n            : \"streamChat.\\{\\{count\\}\\} unread messages\"\n          ) | translate: { count: unreadCount }\n        }}\n      </ng-container>\n      <ng-template #noUnreadCount>\n        {{ \"streamChat.Unread messages\" | translate }}\n      </ng-template>\n    </button>\n    <button\n      data-testid=\"unread-messages-notification-dismiss\"\n      (click)=\"onDismiss()\"\n    >\n      <stream-icon-placeholder icon=\"close\"></stream-icon-placeholder>\n    </button>\n  </div>\n</ng-template>\n<div #scrollContainer data-testid=\"scroll-container\" class=\"str-chat__list\">\n  <ng-container *ngIf=\"mode === 'main' && isEmpty && emptyListTemplate\">\n    <ng-container *ngTemplateOutlet=\"emptyListTemplate\"></ng-container>\n  </ng-container>\n  <div class=\"str-chat__reverse-infinite-scroll str-chat__message-list-scroll\">\n    <ul class=\"str-chat__ul\">\n      <li\n        *ngIf=\"mode === 'thread' && parentMessage\"\n        #parentMessageElement\n        data-testid=\"parent-message\"\n        class=\"str-chat__parent-message-li\"\n      >\n        <ng-container\n          *ngTemplateOutlet=\"\n            messageTemplateContainer;\n            context: { message: parentMessage, index: 'parent' }\n          \"\n        ></ng-container>\n        <div data-testid=\"reply-count\" class=\"str-chat__thread-start\">\n          {{parentMessage.reply_count === 1 ? ('streamChat.1 reply' | translate) : ('streamChat.{{ replyCount }}\n          replies' | translate:replyCountParam)}}\n        </div>\n      </li>\n      <ng-container *ngIf=\"mode === 'thread' && isEmpty && emptyListTemplate\">\n        <ng-container *ngTemplateOutlet=\"emptyListTemplate\"></ng-container>\n      </ng-container>\n      <stream-loading-indicator\n        *ngIf=\"\n          isLoading && direction === 'bottom-to-top' && displayLoadingIndicator\n        \"\n        data-testid=\"top-loading-indicator\"\n      ></stream-loading-indicator>\n      <ng-container *ngIf=\"messages$ | async as messages\">\n        <ng-container\n          *ngFor=\"\n            let message of messages;\n            let i = index;\n            let isFirst = first;\n            let isLast = last;\n            trackBy: trackByMessageId\n          \"\n        >\n          <ng-container *ngIf=\"isFirst\">\n            <ng-container\n              *ngTemplateOutlet=\"\n                dateSeparator;\n                context: {\n                  date: message.created_at,\n                  parsedDate: parseDate(message.created_at)\n                }\n              \"\n            ></ng-container>\n          </ng-container>\n          <li\n            tabindex=\"0\"\n            data-testclass=\"message\"\n            class=\"str-chat__li str-chat__li--{{ groupStyles[i] }}\"\n            id=\"{{ message.id }}\"\n          >\n            <ng-container\n              *ngTemplateOutlet=\"\n                messageTemplateContainer;\n                context: { message: message, index: i }\n              \"\n            ></ng-container>\n          </li>\n          <ng-container\n            *ngIf=\"\n              (lastReadMessageId === message?.id &&\n                direction === 'bottom-to-top') ||\n              (direction === 'top-to-bottom' &&\n                lastReadMessageId === messages[i + 1]?.id)\n            \"\n          >\n            <li\n              *ngIf=\"displayUnreadSeparator\"\n              id=\"stream-chat-new-message-indicator\"\n              data-testid=\"new-messages-indicator\"\n              class=\"str-chat__li str-chat__unread-messages-separator-wrapper\"\n            >\n              <ng-container\n                *ngTemplateOutlet=\"\n                  customnewMessagesIndicatorTemplate ||\n                    defaultNewMessagesIndicator;\n                  context: { unreadCount: unreadCount }\n                \"\n              ></ng-container>\n            </li>\n          </ng-container>\n          <ng-container *ngIf=\"isNextMessageOnSeparateDate[i]\">\n            <ng-container\n              *ngTemplateOutlet=\"\n                dateSeparator;\n                context: {\n                  date: messages[i + 1].created_at,\n                  parsedDate: parseDate(messages[i + 1].created_at)\n                }\n              \"\n            ></ng-container>\n          </ng-container>\n        </ng-container>\n      </ng-container>\n      <stream-loading-indicator\n        *ngIf=\"\n          isLoading && direction === 'top-to-bottom' && displayLoadingIndicator\n        \"\n        data-testid=\"bottom-loading-indicator\"\n      ></stream-loading-indicator>\n    </ul>\n    <ng-template #defaultTypingIndicator let-usersTyping$=\"usersTyping$\">\n      <!-- eslint-disable-next-line @angular-eslint/template/no-any -->\n      <ng-container *ngIf=\"$any(usersTyping$ | async) as users\">\n        <div\n          *ngIf=\"users.length > 0\"\n          data-testid=\"typing-indicator\"\n          class=\"str-chat__typing-indicator str-chat__typing-indicator--typing\"\n        >\n          <div class=\"str-chat__typing-indicator__dots\">\n            <span class=\"str-chat__typing-indicator__dot\"></span>\n            <span class=\"str-chat__typing-indicator__dot\"></span>\n            <span class=\"str-chat__typing-indicator__dot\"></span>\n          </div>\n          <div\n            data-testid=\"typing-users\"\n            class=\"str-chat__typing-indicator__users\"\n          >\n            {{\n              users.length === 1\n                ? (\"streamChat.user is typing\"\n                  | translate: { user: getTypingIndicatorText(users) })\n                : (\"streamChat.users are typing\"\n                  | translate: { users: getTypingIndicatorText(users) })\n            }}\n          </div>\n        </div>\n      </ng-container>\n    </ng-template>\n    <ng-container\n      *ngTemplateOutlet=\"\n        typingIndicatorTemplate || defaultTypingIndicator;\n        context: getTypingIndicatorContext()\n      \"\n    ></ng-container>\n  </div>\n</div>\n<div class=\"str-chat__jump-to-latest-message\">\n  <button\n    *ngIf=\"isUserScrolled && isJumpToLatestButtonVisible\"\n    data-testid=\"scroll-to-latest\"\n    class=\"\n      str-chat__message-notification-scroll-to-latest\n      str-chat__message-notification-scroll-to-latest-right\n      str-chat__circle-fab\n    \"\n    (keyup.enter)=\"jumpToLatestMessage()\"\n    (click)=\"jumpToLatestMessage()\"\n  >\n    <stream-icon\n      class=\"str-chat__jump-to-latest-icon str-chat__circle-fab-icon\"\n      [icon]=\"direction === 'bottom-to-top' ? 'arrow-down' : 'arrow-up'\"\n    ></stream-icon>\n    <div\n      *ngIf=\"newMessageCountWhileBeingScrolled > 0\"\n      class=\"\n        str-chat__message-notification\n        str-chat__message-notification-scroll-to-latest-unread-count\n        str-chat__jump-to-latest-unread-count\n      \"\n    >\n      {{ newMessageCountWhileBeingScrolled }}\n    </div>\n  </button>\n</div>\n\n<ng-template #messageTemplateContainer let-message=\"message\" let-index=\"index\">\n  <ng-template\n    #defaultMessageTemplate\n    let-messageInput=\"message\"\n    let-isLastSentMessage=\"isLastSentMessage\"\n    let-enabledMessageActions=\"enabledMessageActions\"\n    let-mode=\"mode\"\n    let-isHighlighted=\"isHighlighted\"\n    let-scroll$=\"scroll$\"\n  >\n    <stream-message\n      [message]=\"messageInput\"\n      [isLastSentMessage]=\"isLastSentMessage\"\n      [enabledMessageActions]=\"enabledMessageActions\"\n      [mode]=\"mode\"\n      [isHighlighted]=\"isHighlighted\"\n      [scroll$]=\"scroll$\"\n    ></stream-message>\n  </ng-template>\n  <ng-container\n    *ngTemplateOutlet=\"\n      messageTemplate || defaultMessageTemplate;\n      context: {\n        message: message,\n        isLastSentMessage: !!(\n          lastSentMessageId && message?.id === lastSentMessageId\n        ),\n        enabledMessageActions: enabledMessageActions,\n        mode: mode,\n        isHighlighted: message?.id === highlightedMessageId,\n        scroll$: scroll$\n      }\n    \"\n  ></ng-container>\n</ng-template>\n\n<ng-template #dateSeparator let-date=\"date\" let-parsedDate=\"parsedDate\">\n  <ng-container *ngIf=\"displayDateSeparator\">\n    <ng-container\n      *ngTemplateOutlet=\"\n        customDateSeparatorTemplate || defaultDateSeparator;\n        context: {\n          date: date,\n          parsedDate: parsedDate\n        }\n      \"\n    ></ng-container>\n  </ng-container>\n\n  <ng-template\n    #defaultDateSeparator\n    let-date=\"date\"\n    let-parsedDate=\"parsedDate\"\n  >\n    <div data-testid=\"date-separator\" class=\"str-chat__date-separator\">\n      <hr\n        *ngIf=\"\n          dateSeparatorTextPos === 'right' || dateSeparatorTextPos === 'center'\n        \"\n        class=\"str-chat__date-separator-line\"\n      />\n      <div class=\"str-chat__date-separator-date\">\n        {{ parsedDate }}\n      </div>\n      <hr\n        *ngIf=\"\n          dateSeparatorTextPos === 'left' || dateSeparatorTextPos === 'center'\n        \"\n        class=\"str-chat__date-separator-line\"\n      />\n    </div>\n  </ng-template>\n</ng-template>\n\n<ng-template #defaultNewMessagesIndicator let-unreadCount=\"unreadCount\">\n  <div class=\"str-chat__unread-messages-separator\">\n    <ng-container\n      *ngIf=\"\n        unreadCount > 0 && !hideUnreadCountForNotificationAndIndicator;\n        else noUnreadCount\n      \"\n    >\n      {{\n        (unreadCount === 1\n          ? \"streamChat.\\{\\{count\\}\\} unread message\"\n          : \"streamChat.\\{\\{count\\}\\} unread messages\"\n        ) | translate: { count: unreadCount }\n      }}\n    </ng-container>\n    <ng-template #noUnreadCount>\n      {{ \"streamChat.Unread messages\" | translate }}\n    </ng-template>\n  </div>\n</ng-template>\n", dependencies: [{ kind: "directive", type: i4.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i4.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i4.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "component", type: MessageComponent, selector: "stream-message", inputs: ["message", "enabledMessageActions", "isLastSentMessage", "mode", "isHighlighted", "scroll$"] }, { kind: "component", type: LoadingIndicatorComponent, selector: "stream-loading-indicator" }, { kind: "component", type: IconComponent, selector: "stream-icon", inputs: ["icon"] }, { kind: "component", type: IconPlaceholderComponent, selector: "stream-icon-placeholder", inputs: ["icon"] }, { kind: "pipe", type: i4.AsyncPipe, name: "async" }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: MessageListComponent, decorators: [{
            type: Component,
            args: [{ selector: 'stream-message-list', changeDetection: ChangeDetectionStrategy.OnPush, template: "<ng-container\n  *ngIf=\"\n    lastReadMessageId &&\n    isUnreadNotificationVisible &&\n    openMessageListAt === 'last-message' &&\n    displayUnreadSeparator\n  \"\n>\n  <ng-container\n    *ngTemplateOutlet=\"\n      customnewMessagesNotificationTemplate ||\n        defaultUnreadMessagesNotification;\n      context: {\n        unreadCount: unreadCount,\n        onDismiss: messageNotificationDismissClicked,\n        onJump: messageNotificationJumpClicked\n      }\n    \"\n  ></ng-container>\n</ng-container>\n<ng-template\n  #defaultUnreadMessagesNotification\n  let-unreadCount=\"unreadCount\"\n  let-onDismiss=\"onDismiss\"\n  let-onJump=\"onJump\"\n>\n  <div\n    class=\"str-chat__unread-messages-notification\"\n    data-testid=\"unread-messages-notification\"\n  >\n    <button\n      data-testid=\"unread-messages-notification-jump-to-message\"\n      (click)=\"onJump()\"\n    >\n      <ng-container\n        *ngIf=\"\n          unreadCount > 0 && !hideUnreadCountForNotificationAndIndicator;\n          else noUnreadCount\n        \"\n      >\n        {{\n          (unreadCount === 1\n            ? \"streamChat.\\{\\{count\\}\\} unread message\"\n            : \"streamChat.\\{\\{count\\}\\} unread messages\"\n          ) | translate: { count: unreadCount }\n        }}\n      </ng-container>\n      <ng-template #noUnreadCount>\n        {{ \"streamChat.Unread messages\" | translate }}\n      </ng-template>\n    </button>\n    <button\n      data-testid=\"unread-messages-notification-dismiss\"\n      (click)=\"onDismiss()\"\n    >\n      <stream-icon-placeholder icon=\"close\"></stream-icon-placeholder>\n    </button>\n  </div>\n</ng-template>\n<div #scrollContainer data-testid=\"scroll-container\" class=\"str-chat__list\">\n  <ng-container *ngIf=\"mode === 'main' && isEmpty && emptyListTemplate\">\n    <ng-container *ngTemplateOutlet=\"emptyListTemplate\"></ng-container>\n  </ng-container>\n  <div class=\"str-chat__reverse-infinite-scroll str-chat__message-list-scroll\">\n    <ul class=\"str-chat__ul\">\n      <li\n        *ngIf=\"mode === 'thread' && parentMessage\"\n        #parentMessageElement\n        data-testid=\"parent-message\"\n        class=\"str-chat__parent-message-li\"\n      >\n        <ng-container\n          *ngTemplateOutlet=\"\n            messageTemplateContainer;\n            context: { message: parentMessage, index: 'parent' }\n          \"\n        ></ng-container>\n        <div data-testid=\"reply-count\" class=\"str-chat__thread-start\">\n          {{parentMessage.reply_count === 1 ? ('streamChat.1 reply' | translate) : ('streamChat.{{ replyCount }}\n          replies' | translate:replyCountParam)}}\n        </div>\n      </li>\n      <ng-container *ngIf=\"mode === 'thread' && isEmpty && emptyListTemplate\">\n        <ng-container *ngTemplateOutlet=\"emptyListTemplate\"></ng-container>\n      </ng-container>\n      <stream-loading-indicator\n        *ngIf=\"\n          isLoading && direction === 'bottom-to-top' && displayLoadingIndicator\n        \"\n        data-testid=\"top-loading-indicator\"\n      ></stream-loading-indicator>\n      <ng-container *ngIf=\"messages$ | async as messages\">\n        <ng-container\n          *ngFor=\"\n            let message of messages;\n            let i = index;\n            let isFirst = first;\n            let isLast = last;\n            trackBy: trackByMessageId\n          \"\n        >\n          <ng-container *ngIf=\"isFirst\">\n            <ng-container\n              *ngTemplateOutlet=\"\n                dateSeparator;\n                context: {\n                  date: message.created_at,\n                  parsedDate: parseDate(message.created_at)\n                }\n              \"\n            ></ng-container>\n          </ng-container>\n          <li\n            tabindex=\"0\"\n            data-testclass=\"message\"\n            class=\"str-chat__li str-chat__li--{{ groupStyles[i] }}\"\n            id=\"{{ message.id }}\"\n          >\n            <ng-container\n              *ngTemplateOutlet=\"\n                messageTemplateContainer;\n                context: { message: message, index: i }\n              \"\n            ></ng-container>\n          </li>\n          <ng-container\n            *ngIf=\"\n              (lastReadMessageId === message?.id &&\n                direction === 'bottom-to-top') ||\n              (direction === 'top-to-bottom' &&\n                lastReadMessageId === messages[i + 1]?.id)\n            \"\n          >\n            <li\n              *ngIf=\"displayUnreadSeparator\"\n              id=\"stream-chat-new-message-indicator\"\n              data-testid=\"new-messages-indicator\"\n              class=\"str-chat__li str-chat__unread-messages-separator-wrapper\"\n            >\n              <ng-container\n                *ngTemplateOutlet=\"\n                  customnewMessagesIndicatorTemplate ||\n                    defaultNewMessagesIndicator;\n                  context: { unreadCount: unreadCount }\n                \"\n              ></ng-container>\n            </li>\n          </ng-container>\n          <ng-container *ngIf=\"isNextMessageOnSeparateDate[i]\">\n            <ng-container\n              *ngTemplateOutlet=\"\n                dateSeparator;\n                context: {\n                  date: messages[i + 1].created_at,\n                  parsedDate: parseDate(messages[i + 1].created_at)\n                }\n              \"\n            ></ng-container>\n          </ng-container>\n        </ng-container>\n      </ng-container>\n      <stream-loading-indicator\n        *ngIf=\"\n          isLoading && direction === 'top-to-bottom' && displayLoadingIndicator\n        \"\n        data-testid=\"bottom-loading-indicator\"\n      ></stream-loading-indicator>\n    </ul>\n    <ng-template #defaultTypingIndicator let-usersTyping$=\"usersTyping$\">\n      <!-- eslint-disable-next-line @angular-eslint/template/no-any -->\n      <ng-container *ngIf=\"$any(usersTyping$ | async) as users\">\n        <div\n          *ngIf=\"users.length > 0\"\n          data-testid=\"typing-indicator\"\n          class=\"str-chat__typing-indicator str-chat__typing-indicator--typing\"\n        >\n          <div class=\"str-chat__typing-indicator__dots\">\n            <span class=\"str-chat__typing-indicator__dot\"></span>\n            <span class=\"str-chat__typing-indicator__dot\"></span>\n            <span class=\"str-chat__typing-indicator__dot\"></span>\n          </div>\n          <div\n            data-testid=\"typing-users\"\n            class=\"str-chat__typing-indicator__users\"\n          >\n            {{\n              users.length === 1\n                ? (\"streamChat.user is typing\"\n                  | translate: { user: getTypingIndicatorText(users) })\n                : (\"streamChat.users are typing\"\n                  | translate: { users: getTypingIndicatorText(users) })\n            }}\n          </div>\n        </div>\n      </ng-container>\n    </ng-template>\n    <ng-container\n      *ngTemplateOutlet=\"\n        typingIndicatorTemplate || defaultTypingIndicator;\n        context: getTypingIndicatorContext()\n      \"\n    ></ng-container>\n  </div>\n</div>\n<div class=\"str-chat__jump-to-latest-message\">\n  <button\n    *ngIf=\"isUserScrolled && isJumpToLatestButtonVisible\"\n    data-testid=\"scroll-to-latest\"\n    class=\"\n      str-chat__message-notification-scroll-to-latest\n      str-chat__message-notification-scroll-to-latest-right\n      str-chat__circle-fab\n    \"\n    (keyup.enter)=\"jumpToLatestMessage()\"\n    (click)=\"jumpToLatestMessage()\"\n  >\n    <stream-icon\n      class=\"str-chat__jump-to-latest-icon str-chat__circle-fab-icon\"\n      [icon]=\"direction === 'bottom-to-top' ? 'arrow-down' : 'arrow-up'\"\n    ></stream-icon>\n    <div\n      *ngIf=\"newMessageCountWhileBeingScrolled > 0\"\n      class=\"\n        str-chat__message-notification\n        str-chat__message-notification-scroll-to-latest-unread-count\n        str-chat__jump-to-latest-unread-count\n      \"\n    >\n      {{ newMessageCountWhileBeingScrolled }}\n    </div>\n  </button>\n</div>\n\n<ng-template #messageTemplateContainer let-message=\"message\" let-index=\"index\">\n  <ng-template\n    #defaultMessageTemplate\n    let-messageInput=\"message\"\n    let-isLastSentMessage=\"isLastSentMessage\"\n    let-enabledMessageActions=\"enabledMessageActions\"\n    let-mode=\"mode\"\n    let-isHighlighted=\"isHighlighted\"\n    let-scroll$=\"scroll$\"\n  >\n    <stream-message\n      [message]=\"messageInput\"\n      [isLastSentMessage]=\"isLastSentMessage\"\n      [enabledMessageActions]=\"enabledMessageActions\"\n      [mode]=\"mode\"\n      [isHighlighted]=\"isHighlighted\"\n      [scroll$]=\"scroll$\"\n    ></stream-message>\n  </ng-template>\n  <ng-container\n    *ngTemplateOutlet=\"\n      messageTemplate || defaultMessageTemplate;\n      context: {\n        message: message,\n        isLastSentMessage: !!(\n          lastSentMessageId && message?.id === lastSentMessageId\n        ),\n        enabledMessageActions: enabledMessageActions,\n        mode: mode,\n        isHighlighted: message?.id === highlightedMessageId,\n        scroll$: scroll$\n      }\n    \"\n  ></ng-container>\n</ng-template>\n\n<ng-template #dateSeparator let-date=\"date\" let-parsedDate=\"parsedDate\">\n  <ng-container *ngIf=\"displayDateSeparator\">\n    <ng-container\n      *ngTemplateOutlet=\"\n        customDateSeparatorTemplate || defaultDateSeparator;\n        context: {\n          date: date,\n          parsedDate: parsedDate\n        }\n      \"\n    ></ng-container>\n  </ng-container>\n\n  <ng-template\n    #defaultDateSeparator\n    let-date=\"date\"\n    let-parsedDate=\"parsedDate\"\n  >\n    <div data-testid=\"date-separator\" class=\"str-chat__date-separator\">\n      <hr\n        *ngIf=\"\n          dateSeparatorTextPos === 'right' || dateSeparatorTextPos === 'center'\n        \"\n        class=\"str-chat__date-separator-line\"\n      />\n      <div class=\"str-chat__date-separator-date\">\n        {{ parsedDate }}\n      </div>\n      <hr\n        *ngIf=\"\n          dateSeparatorTextPos === 'left' || dateSeparatorTextPos === 'center'\n        \"\n        class=\"str-chat__date-separator-line\"\n      />\n    </div>\n  </ng-template>\n</ng-template>\n\n<ng-template #defaultNewMessagesIndicator let-unreadCount=\"unreadCount\">\n  <div class=\"str-chat__unread-messages-separator\">\n    <ng-container\n      *ngIf=\"\n        unreadCount > 0 && !hideUnreadCountForNotificationAndIndicator;\n        else noUnreadCount\n      \"\n    >\n      {{\n        (unreadCount === 1\n          ? \"streamChat.\\{\\{count\\}\\} unread message\"\n          : \"streamChat.\\{\\{count\\}\\} unread messages\"\n        ) | translate: { count: unreadCount }\n      }}\n    </ng-container>\n    <ng-template #noUnreadCount>\n      {{ \"streamChat.Unread messages\" | translate }}\n    </ng-template>\n  </div>\n</ng-template>\n" }]
        }], ctorParameters: function () { return [{ type: ChannelService }, { type: ChatClientService }, { type: CustomTemplatesService }, { type: DateParserService }, { type: i0.NgZone }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { mode: [{
                type: Input
            }], direction: [{
                type: Input
            }], hideJumpToLatestButtonDuringScroll: [{
                type: Input
            }], displayDateSeparator: [{
                type: Input
            }], displayUnreadSeparator: [{
                type: Input
            }], dateSeparatorTextPos: [{
                type: Input
            }], openMessageListAt: [{
                type: Input
            }], hideUnreadCountForNotificationAndIndicator: [{
                type: Input
            }], displayLoadingIndicator: [{
                type: Input
            }], limitNumberOfMessagesInList: [{
                type: Input
            }], scrollContainer: [{
                type: ViewChild,
                args: ['scrollContainer']
            }], parentMessageElement: [{
                type: ViewChild,
                args: ['parentMessageElement']
            }], class: [{
                type: HostBinding,
                args: ['class']
            }] } });

/**
 * The `Thread` component represents a [message thread](https://getstream.io/chat/docs/javascript/threads/?language=javascript), it is a container component that displays a thread with a header, [`MessageList`](./MessageListComponent.mdx) and [`MessageInput`](./MessageInputComponent.mdx) components.
 */
class ThreadComponent {
    constructor(customTemplatesService, channelService, chatClientService) {
        this.customTemplatesService = customTemplatesService;
        this.channelService = channelService;
        this.chatClientService = chatClientService;
        this.class = 'str-chat__thread';
        this.subscriptions = [];
        this.subscriptions.push(this.channelService.activeParentMessage$.subscribe((parentMessage) => (this.parentMessage = parentMessage)));
        this.subscriptions.push(this.channelService.activeChannel$.subscribe((channel) => (this.channel = channel)));
    }
    ngOnDestroy() {
        this.subscriptions.forEach((s) => s.unsubscribe());
    }
    getThreadHeaderContext() {
        return {
            parentMessage: this.parentMessage,
            closeThreadHandler: () => this.closeThread(),
        };
    }
    closeThread() {
        void this.channelService.setAsActiveParentMessage(undefined);
    }
    get channelName() {
        if (!this.channel || !this.chatClientService.chatClient.user) {
            return '';
        }
        return getChannelDisplayText(this.channel, this.chatClientService.chatClient.user);
    }
}
ThreadComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: ThreadComponent, deps: [{ token: CustomTemplatesService }, { token: ChannelService }, { token: ChatClientService }], target: i0.ɵɵFactoryTarget.Component });
ThreadComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.0.4", type: ThreadComponent, selector: "stream-thread", host: { properties: { "class": "this.class" } }, ngImport: i0, template: "<div class=\"str-chat__thread-container\">\n  <ng-container\n    *ngTemplateOutlet=\"\n      (customTemplatesService.threadHeaderTemplate$ | async) ||\n        defaultThreadHeader;\n      context: getThreadHeaderContext()\n    \"\n  ></ng-container>\n  <ng-content></ng-content>\n</div>\n\n<ng-template\n  #defaultThreadHeader\n  let-parentMessage=\"parentMessage\"\n  let-closeThreadHandler=\"closeThreadHandler\"\n>\n  <div class=\"str-chat__thread-header\">\n    <div class=\"str-chat__thread-header-details\">\n      <div class=\"str-chat__thread-header-name\" translate>\n        streamChat.Thread\n      </div>\n      <div\n        class=\"str-chat__thread-header-channel-name\"\n        data-testid=\"channel-name\"\n      >\n        {{ channelName }}\n      </div>\n    </div>\n    <button\n      class=\"str-chat__square-button str-chat__close-thread-button\"\n      data-testid=\"close-button\"\n      (click)=\"closeThreadHandler()\"\n    >\n      <stream-icon-placeholder icon=\"close\"></stream-icon-placeholder>\n    </button>\n  </div>\n</ng-template>\n", dependencies: [{ kind: "directive", type: i4.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: i10.TranslateDirective, selector: "[translate],[ngx-translate]", inputs: ["translate", "translateParams"] }, { kind: "component", type: IconPlaceholderComponent, selector: "stream-icon-placeholder", inputs: ["icon"] }, { kind: "pipe", type: i4.AsyncPipe, name: "async" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: ThreadComponent, decorators: [{
            type: Component,
            args: [{ selector: 'stream-thread', template: "<div class=\"str-chat__thread-container\">\n  <ng-container\n    *ngTemplateOutlet=\"\n      (customTemplatesService.threadHeaderTemplate$ | async) ||\n        defaultThreadHeader;\n      context: getThreadHeaderContext()\n    \"\n  ></ng-container>\n  <ng-content></ng-content>\n</div>\n\n<ng-template\n  #defaultThreadHeader\n  let-parentMessage=\"parentMessage\"\n  let-closeThreadHandler=\"closeThreadHandler\"\n>\n  <div class=\"str-chat__thread-header\">\n    <div class=\"str-chat__thread-header-details\">\n      <div class=\"str-chat__thread-header-name\" translate>\n        streamChat.Thread\n      </div>\n      <div\n        class=\"str-chat__thread-header-channel-name\"\n        data-testid=\"channel-name\"\n      >\n        {{ channelName }}\n      </div>\n    </div>\n    <button\n      class=\"str-chat__square-button str-chat__close-thread-button\"\n      data-testid=\"close-button\"\n      (click)=\"closeThreadHandler()\"\n    >\n      <stream-icon-placeholder icon=\"close\"></stream-icon-placeholder>\n    </button>\n  </div>\n</ng-template>\n" }]
        }], ctorParameters: function () { return [{ type: CustomTemplatesService }, { type: ChannelService }, { type: ChatClientService }]; }, propDecorators: { class: [{
                type: HostBinding,
                args: ['class']
            }] } });

class StreamAvatarModule {
}
StreamAvatarModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: StreamAvatarModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
StreamAvatarModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.0.4", ngImport: i0, type: StreamAvatarModule, declarations: [AvatarComponent, AvatarPlaceholderComponent], imports: [CommonModule, TranslateModule], exports: [AvatarComponent, AvatarPlaceholderComponent] });
StreamAvatarModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: StreamAvatarModule, imports: [CommonModule, TranslateModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: StreamAvatarModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [AvatarComponent, AvatarPlaceholderComponent],
                    imports: [CommonModule, TranslateModule],
                    exports: [AvatarComponent, AvatarPlaceholderComponent],
                }]
        }] });

class StreamChatModule {
}
StreamChatModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: StreamChatModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
StreamChatModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.0.4", ngImport: i0, type: StreamChatModule, declarations: [ChannelComponent,
        ChannelHeaderComponent,
        ChannelListComponent,
        ChannelPreviewComponent,
        MessageComponent,
        MessageInputComponent,
        MessageListComponent,
        LoadingIndicatorComponent,
        IconComponent,
        MessageActionsBoxComponent,
        AttachmentListComponent,
        MessageReactionsComponent,
        NotificationComponent,
        NotificationListComponent,
        AttachmentPreviewListComponent,
        ModalComponent,
        TextareaDirective,
        ThreadComponent,
        IconPlaceholderComponent,
        LoadingIndicatorPlaceholderComponent,
        MessageBouncePromptComponent,
        VoiceRecordingComponent,
        VoiceRecordingWavebarComponent,
        MessageReactionsSelectorComponent], imports: [CommonModule,
        NgxFloatUiModule,
        StreamAvatarModule,
        TranslateModule], exports: [ChannelComponent,
        ChannelHeaderComponent,
        ChannelListComponent,
        ChannelPreviewComponent,
        MessageComponent,
        MessageInputComponent,
        MessageListComponent,
        LoadingIndicatorComponent,
        IconComponent,
        MessageActionsBoxComponent,
        AttachmentListComponent,
        MessageReactionsComponent,
        NotificationComponent,
        NotificationListComponent,
        AttachmentPreviewListComponent,
        ModalComponent,
        StreamAvatarModule,
        ThreadComponent,
        IconPlaceholderComponent,
        LoadingIndicatorPlaceholderComponent,
        MessageBouncePromptComponent,
        VoiceRecordingComponent,
        VoiceRecordingWavebarComponent,
        MessageReactionsSelectorComponent] });
StreamChatModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: StreamChatModule, imports: [CommonModule,
        NgxFloatUiModule,
        StreamAvatarModule,
        TranslateModule, StreamAvatarModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: StreamChatModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [
                        ChannelComponent,
                        ChannelHeaderComponent,
                        ChannelListComponent,
                        ChannelPreviewComponent,
                        MessageComponent,
                        MessageInputComponent,
                        MessageListComponent,
                        LoadingIndicatorComponent,
                        IconComponent,
                        MessageActionsBoxComponent,
                        AttachmentListComponent,
                        MessageReactionsComponent,
                        NotificationComponent,
                        NotificationListComponent,
                        AttachmentPreviewListComponent,
                        ModalComponent,
                        TextareaDirective,
                        ThreadComponent,
                        IconPlaceholderComponent,
                        LoadingIndicatorPlaceholderComponent,
                        MessageBouncePromptComponent,
                        VoiceRecordingComponent,
                        VoiceRecordingWavebarComponent,
                        MessageReactionsSelectorComponent,
                    ],
                    imports: [
                        CommonModule,
                        NgxFloatUiModule,
                        StreamAvatarModule,
                        TranslateModule,
                    ],
                    exports: [
                        ChannelComponent,
                        ChannelHeaderComponent,
                        ChannelListComponent,
                        ChannelPreviewComponent,
                        MessageComponent,
                        MessageInputComponent,
                        MessageListComponent,
                        LoadingIndicatorComponent,
                        IconComponent,
                        MessageActionsBoxComponent,
                        AttachmentListComponent,
                        MessageReactionsComponent,
                        NotificationComponent,
                        NotificationListComponent,
                        AttachmentPreviewListComponent,
                        ModalComponent,
                        StreamAvatarModule,
                        ThreadComponent,
                        IconPlaceholderComponent,
                        LoadingIndicatorPlaceholderComponent,
                        MessageBouncePromptComponent,
                        VoiceRecordingComponent,
                        VoiceRecordingWavebarComponent,
                        MessageReactionsSelectorComponent,
                    ],
                }]
        }] });

class StreamAutocompleteTextareaModule {
}
StreamAutocompleteTextareaModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: StreamAutocompleteTextareaModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
StreamAutocompleteTextareaModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.0.4", ngImport: i0, type: StreamAutocompleteTextareaModule, declarations: [AutocompleteTextareaComponent], imports: [CommonModule, TranslateModule, MentionModule, StreamAvatarModule], exports: [AutocompleteTextareaComponent] });
StreamAutocompleteTextareaModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: StreamAutocompleteTextareaModule, providers: [
        {
            provide: textareaInjectionToken,
            useValue: AutocompleteTextareaComponent,
        },
    ], imports: [CommonModule, TranslateModule, MentionModule, StreamAvatarModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: StreamAutocompleteTextareaModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [AutocompleteTextareaComponent],
                    imports: [CommonModule, TranslateModule, MentionModule, StreamAvatarModule],
                    exports: [AutocompleteTextareaComponent],
                    providers: [
                        {
                            provide: textareaInjectionToken,
                            useValue: AutocompleteTextareaComponent,
                        },
                    ],
                }]
        }] });

class StreamTextareaModule {
}
StreamTextareaModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: StreamTextareaModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
StreamTextareaModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.0.4", ngImport: i0, type: StreamTextareaModule, declarations: [TextareaComponent], imports: [CommonModule, TranslateModule], exports: [TextareaComponent] });
StreamTextareaModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: StreamTextareaModule, providers: [
        {
            provide: textareaInjectionToken,
            useValue: TextareaComponent,
        },
    ], imports: [CommonModule, TranslateModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: StreamTextareaModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [TextareaComponent],
                    imports: [CommonModule, TranslateModule],
                    exports: [TextareaComponent],
                    providers: [
                        {
                            provide: textareaInjectionToken,
                            useValue: TextareaComponent,
                        },
                    ],
                }]
        }] });

/*
 * Public API Surface of stream-chat-angular
 */

/**
 * Generated bundle index. Do not edit.
 */

export { AttachmentConfigurationService, AttachmentListComponent, AttachmentPreviewListComponent, AttachmentService, AutocompleteTextareaComponent, AvatarComponent, AvatarPlaceholderComponent, ChannelComponent, ChannelHeaderComponent, ChannelListComponent, ChannelPreviewComponent, ChannelQuery, ChannelService, ChatClientService, CustomTemplatesService, DateParserService, EmojiInputService, IconComponent, IconPlaceholderComponent, LoadingIndicatorComponent, LoadingIndicatorPlaceholderComponent, MessageActionsBoxComponent, MessageActionsService, MessageBouncePromptComponent, MessageComponent, MessageInputComponent, MessageInputConfigService, MessageListComponent, MessageReactionsComponent, MessageReactionsSelectorComponent, MessageReactionsService, MessageService, ModalComponent, NotificationComponent, NotificationListComponent, NotificationService, StreamAutocompleteTextareaModule, StreamAvatarModule, StreamChatModule, StreamI18nService, StreamTextareaModule, TextareaComponent, TextareaDirective, ThemeService, ThreadComponent, TransliterationService, VoiceRecordingComponent, VoiceRecordingWavebarComponent, createMessagePreview, getChannelDisplayText, getGroupStyles, getMessageTranslation, getReadBy, isImageAttachment, isImageFile, isOnSeparateDate, listUsers, parseDate, textareaInjectionToken };
//# sourceMappingURL=stream-chat-angular.mjs.map
