import { Component, Input, ViewChild, } from '@angular/core';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
/**
 * This component can be used to visualize the wave bar of a voice recording
 */
export class VoiceRecordingWavebarComponent {
    constructor(ngZone, cdRef) {
        this.ngZone = ngZone;
        this.cdRef = cdRef;
        /**
         * The waveform data to visualize
         */
        this.waveFormData = [];
        this.resampledWaveFormData = [];
        this.progress = 0;
        this.isDragging = false;
        this.sampleSize = 40;
        this.isViewInited = false;
        this.upsample = () => {
            if (this.sampleSize === this.waveFormData.length)
                return this.waveFormData;
            // eslint-disable-next-line  prefer-const
            let [bucketSize, remainder] = this.divMod(this.sampleSize, this.waveFormData.length);
            const result = [];
            for (let i = 0; i < this.waveFormData.length; i++) {
                const extra = remainder && remainder-- ? 1 : 0;
                result.push(...Array(bucketSize + extra).fill(this.waveFormData[i]));
            }
            return result;
        };
        this.getNextBucketMean = (data, currentBucketIndex, bucketSize) => {
            const nextBucketStartIndex = Math.floor(currentBucketIndex * bucketSize) + 1;
            let nextNextBucketStartIndex = Math.floor((currentBucketIndex + 1) * bucketSize) + 1;
            nextNextBucketStartIndex =
                nextNextBucketStartIndex < data.length
                    ? nextNextBucketStartIndex
                    : data.length;
            return this.mean(data.slice(nextBucketStartIndex, nextNextBucketStartIndex));
        };
        this.mean = (values) => values.reduce((acc, value) => acc + value, 0) / values.length;
        this.triangleAreaHeron = (a, b, c) => {
            const s = (a + b + c) / 2;
            return Math.sqrt(s * (s - a) * (s - b) * (s - c));
        };
        this.triangleBase = (a, b) => Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));
        this.divMod = (num, divisor) => {
            return [Math.floor(num / divisor), num % divisor];
        };
    }
    ngOnInit() {
        this.containerSizeChanged();
        if (this.container?.nativeElement) {
            this.ngZone.runOutsideAngular(() => {
                new ResizeObserver(() => {
                    this.containerSizeChanged();
                }).observe(this.container.nativeElement);
            });
        }
    }
    ngOnChanges(changes) {
        if (changes.waveFormData) {
            this.resampledWaveFormData =
                this.waveFormData.length > this.sampleSize
                    ? this.downsample()
                    : this.upsample();
        }
        if (changes.audioElement) {
            this.ngZone.runOutsideAngular(() => {
                this.audioElement?.addEventListener('timeupdate', () => {
                    const progress = (this.audioElement?.currentTime || 0) / (this.duration || 0) || 0;
                    if (Math.abs(progress - this.progress) >= 0.02) {
                        this.ngZone.run(() => {
                            this.progress = progress;
                            this.cdRef.detectChanges();
                        });
                    }
                });
            });
        }
    }
    ngAfterViewInit() {
        this.isViewInited = true;
    }
    seek(event) {
        const containerWidth = this.container?.nativeElement?.getBoundingClientRect().width || 0;
        const containerStart = this.container?.nativeElement?.getBoundingClientRect()?.x || 0;
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        const progress = (event.x - containerStart) / containerWidth;
        if (!isNaN(progress) && this.audioElement) {
            const duration = this.duration || 0;
            const time = duration * progress;
            this.audioElement.currentTime = time;
        }
    }
    trackByIndex(index) {
        return index;
    }
    containerSizeChanged() {
        if (!this.container?.nativeElement) {
            return;
        }
        const containerWidth = this.container.nativeElement.clientWidth;
        if (containerWidth === 0) {
            return;
        }
        const barWidth = +getComputedStyle(this.container.nativeElement)
            .getPropertyValue('--str-chat__voice-recording-amplitude-bar-width')
            .replace('px', '');
        const barGap = +getComputedStyle(this.container.nativeElement)
            .getPropertyValue('--str-chat__voice-recording-amplitude-bar-gap-width')
            .replace('px', '');
        if (!isNaN(barWidth) && !isNaN(barGap)) {
            const sampleSize = Math.floor(containerWidth / (barWidth + barGap));
            if (sampleSize !== this.sampleSize &&
                !isNaN(sampleSize) &&
                sampleSize !== Infinity) {
                this.ngZone.run(() => {
                    this.sampleSize = sampleSize;
                    this.resampledWaveFormData =
                        this.waveFormData.length > this.sampleSize
                            ? this.downsample()
                            : this.upsample();
                    if (this.isViewInited) {
                        this.cdRef.detectChanges();
                    }
                });
            }
        }
    }
    downsample() {
        if (this.waveFormData.length <= this.sampleSize) {
            return this.waveFormData;
        }
        if (this.sampleSize === 1)
            return [this.mean(this.waveFormData)];
        const result = [];
        // bucket size adjusted due to the fact that the first and the last item in the original data array is kept in target output
        const bucketSize = (this.waveFormData.length - 2) / (this.sampleSize - 2);
        let lastSelectedPointIndex = 0;
        result.push(this.waveFormData[lastSelectedPointIndex]); // Always add the first point
        let maxAreaPoint, maxArea, triangleArea;
        for (let bucketIndex = 1; bucketIndex < this.sampleSize - 1; bucketIndex++) {
            const previousBucketRefPoint = this.waveFormData[lastSelectedPointIndex];
            const nextBucketMean = this.getNextBucketMean(this.waveFormData, bucketIndex, bucketSize);
            const currentBucketStartIndex = Math.floor((bucketIndex - 1) * bucketSize) + 1;
            const nextBucketStartIndex = Math.floor(bucketIndex * bucketSize) + 1;
            const countUnitsBetweenAtoC = 1 + nextBucketStartIndex - currentBucketStartIndex;
            maxArea = triangleArea = -1;
            for (let currentPointIndex = currentBucketStartIndex; currentPointIndex < nextBucketStartIndex; currentPointIndex++) {
                const countUnitsBetweenAtoB = Math.abs(currentPointIndex - currentBucketStartIndex) + 1;
                const countUnitsBetweenBtoC = countUnitsBetweenAtoC - countUnitsBetweenAtoB;
                const currentPointValue = this.waveFormData[currentPointIndex];
                triangleArea = this.triangleAreaHeron(this.triangleBase(Math.abs(previousBucketRefPoint - currentPointValue), countUnitsBetweenAtoB), this.triangleBase(Math.abs(currentPointValue - nextBucketMean), countUnitsBetweenBtoC), this.triangleBase(Math.abs(previousBucketRefPoint - nextBucketMean), countUnitsBetweenAtoC));
                if (triangleArea > maxArea) {
                    maxArea = triangleArea;
                    maxAreaPoint = this.waveFormData[currentPointIndex];
                    lastSelectedPointIndex = currentPointIndex;
                }
            }
            if (typeof maxAreaPoint !== 'undefined')
                result.push(maxAreaPoint);
        }
        result.push(this.waveFormData[this.waveFormData.length - 1]); // Always add the last point
        return result;
    }
}
VoiceRecordingWavebarComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: VoiceRecordingWavebarComponent, deps: [{ token: i0.NgZone }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
VoiceRecordingWavebarComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.0.4", type: VoiceRecordingWavebarComponent, selector: "stream-voice-recording-wavebar", inputs: { audioElement: "audioElement", waveFormData: "waveFormData", duration: "duration" }, viewQueries: [{ propertyName: "container", first: true, predicate: ["container"], descendants: true, static: true }], usesOnChanges: true, ngImport: i0, template: "<!--eslint-disable @angular-eslint/template/click-events-have-key-events-->\n<div\n  #container\n  class=\"str-chat__wave-progress-bar__track\"\n  data-testid=\"wave-progress-bar-track\"\n  role=\"progressbar\"\n  (mousedown)=\"isDragging = true\"\n  (mouseup)=\"isDragging = false\"\n  (mouseleave)=\"isDragging = false\"\n  (mousemove)=\"isDragging ? seek($event) : null\"\n  (click)=\"seek($event)\"\n>\n  <!--eslint-enable @angular-eslint/template/click-events-have-key-events-->\n  <div\n    *ngFor=\"\n      let dataPoint of resampledWaveFormData;\n      let i = index;\n      trackBy: trackByIndex\n    \"\n    class=\"str-chat__wave-progress-bar__amplitude-bar\"\n    [class.str-chat__wave-progress-bar__amplitude-bar--active]=\"\n      progress > i / resampledWaveFormData.length\n    \"\n    [style.--str-chat__wave-progress-bar__amplitude-bar-height]=\"\n      dataPoint ? dataPoint * 100 + '%' : '0%'\n    \"\n  ></div>\n  <div\n    class=\"str-chat__wave-progress-bar__progress-indicator\"\n    data-testid=\"wave-progress-bar-progress-indicator\"\n    [ngStyle]=\"{ 'inset-inline-start': progress * 100 + '%' }\"\n  ></div>\n</div>\n", dependencies: [{ kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: VoiceRecordingWavebarComponent, decorators: [{
            type: Component,
            args: [{ selector: 'stream-voice-recording-wavebar', template: "<!--eslint-disable @angular-eslint/template/click-events-have-key-events-->\n<div\n  #container\n  class=\"str-chat__wave-progress-bar__track\"\n  data-testid=\"wave-progress-bar-track\"\n  role=\"progressbar\"\n  (mousedown)=\"isDragging = true\"\n  (mouseup)=\"isDragging = false\"\n  (mouseleave)=\"isDragging = false\"\n  (mousemove)=\"isDragging ? seek($event) : null\"\n  (click)=\"seek($event)\"\n>\n  <!--eslint-enable @angular-eslint/template/click-events-have-key-events-->\n  <div\n    *ngFor=\"\n      let dataPoint of resampledWaveFormData;\n      let i = index;\n      trackBy: trackByIndex\n    \"\n    class=\"str-chat__wave-progress-bar__amplitude-bar\"\n    [class.str-chat__wave-progress-bar__amplitude-bar--active]=\"\n      progress > i / resampledWaveFormData.length\n    \"\n    [style.--str-chat__wave-progress-bar__amplitude-bar-height]=\"\n      dataPoint ? dataPoint * 100 + '%' : '0%'\n    \"\n  ></div>\n  <div\n    class=\"str-chat__wave-progress-bar__progress-indicator\"\n    data-testid=\"wave-progress-bar-progress-indicator\"\n    [ngStyle]=\"{ 'inset-inline-start': progress * 100 + '%' }\"\n  ></div>\n</div>\n" }]
        }], ctorParameters: function () { return [{ type: i0.NgZone }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { audioElement: [{
                type: Input
            }], waveFormData: [{
                type: Input
            }], duration: [{
                type: Input
            }], container: [{
                type: ViewChild,
                args: ['container', { static: true }]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidm9pY2UtcmVjb3JkaW5nLXdhdmViYXIuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvc3RyZWFtLWNoYXQtYW5ndWxhci9zcmMvbGliL3ZvaWNlLXJlY29yZGluZy92b2ljZS1yZWNvcmRpbmctd2F2ZWJhci92b2ljZS1yZWNvcmRpbmctd2F2ZWJhci5jb21wb25lbnQudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9zdHJlYW0tY2hhdC1hbmd1bGFyL3NyYy9saWIvdm9pY2UtcmVjb3JkaW5nL3ZvaWNlLXJlY29yZGluZy13YXZlYmFyL3ZvaWNlLXJlY29yZGluZy13YXZlYmFyLmNvbXBvbmVudC5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFHTCxTQUFTLEVBRVQsS0FBSyxFQUtMLFNBQVMsR0FDVixNQUFNLGVBQWUsQ0FBQzs7O0FBRXZCOztHQUVHO0FBTUgsTUFBTSxPQUFPLDhCQUE4QjtJQXVCekMsWUFBb0IsTUFBYyxFQUFVLEtBQXdCO1FBQWhELFdBQU0sR0FBTixNQUFNLENBQVE7UUFBVSxVQUFLLEdBQUwsS0FBSyxDQUFtQjtRQWhCcEU7O1dBRUc7UUFDTSxpQkFBWSxHQUFhLEVBQUUsQ0FBQztRQUtyQywwQkFBcUIsR0FBYSxFQUFFLENBQUM7UUFDckMsYUFBUSxHQUFXLENBQUMsQ0FBQztRQUNyQixlQUFVLEdBQUcsS0FBSyxDQUFDO1FBQ1gsZUFBVSxHQUFXLEVBQUUsQ0FBQztRQUd4QixpQkFBWSxHQUFHLEtBQUssQ0FBQztRQTJLckIsYUFBUSxHQUFHLEdBQUcsRUFBRTtZQUN0QixJQUFJLElBQUksQ0FBQyxVQUFVLEtBQUssSUFBSSxDQUFDLFlBQVksQ0FBQyxNQUFNO2dCQUFFLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQztZQUUzRSx5Q0FBeUM7WUFDekMsSUFBSSxDQUFDLFVBQVUsRUFBRSxTQUFTLENBQUMsR0FBRyxJQUFJ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LENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyw0QkFBNEI7UUFFMUYsT0FBTyxNQUFNLENBQUM7SUFDaEIsQ0FBQzs7MkhBOUxVLDhCQUE4QjsrR0FBOUIsOEJBQThCLCtTQ3JCM0MsNm5DQWlDQTsyRkRaYSw4QkFBOEI7a0JBTDFDLFNBQVM7K0JBQ0UsZ0NBQWdDOzZIQVVqQyxZQUFZO3NCQUFwQixLQUFLO2dCQUlHLFlBQVk7c0JBQXBCLEtBQUs7Z0JBSUcsUUFBUTtzQkFBaEIsS0FBSztnQkFNRSxTQUFTO3NCQURoQixTQUFTO3VCQUFDLFdBQVcsRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBBZnRlclZpZXdJbml0LFxuICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgQ29tcG9uZW50LFxuICBFbGVtZW50UmVmLFxuICBJbnB1dCxcbiAgTmdab25lLFxuICBPbkNoYW5nZXMsXG4gIE9uSW5pdCxcbiAgU2ltcGxlQ2hhbmdlcyxcbiAgVmlld0NoaWxkLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuLyoqXG4gKiBUaGlzIGNvbXBvbmVudCBjYW4gYmUgdXNlZCB0byB2aXN1YWxpemUgdGhlIHdhdmUgYmFyIG9mIGEgdm9pY2UgcmVjb3JkaW5nXG4gKi9cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ3N0cmVhbS12b2ljZS1yZWNvcmRpbmctd2F2ZWJhcicsXG4gIHRlbXBsYXRlVXJsOiAnLi92b2ljZS1yZWNvcmRpbmctd2F2ZWJhci5jb21wb25lbnQuaHRtbCcsXG4gIHN0eWxlczogW10sXG59KVxuZXhwb3J0IGNsYXNzIFZvaWNlUmVjb3JkaW5nV2F2ZWJhckNvbXBvbmVudFxuICBpbXBsZW1lbnRzIE9uSW5pdCwgT25DaGFuZ2VzLCBBZnRlclZpZXdJbml0XG57XG4gIC8qKlxuICAgKiBUaGUgYXVkaW8gZWxlbWVudCB0aGF0IHBsYXlzIHRoZSB2b2ljZSByZWNvcmRpbmdcbiAgICovXG4gIEBJbnB1dCgpIGF1ZGlvRWxlbWVudD86IEhUTUxBdWRpb0VsZW1lbnQ7XG4gIC8qKlxuICAgKiBUaGUgd2F2ZWZvcm0gZGF0YSB0byB2aXN1YWxpemVcbiAgICovXG4gIEBJbnB1dCgpIHdhdmVGb3JtRGF0YTogbnVtYmVyW10gPSBbXTtcbiAgLyoqXG4gICAqIFRoZSBkdXJhdGlvbiBvZiB0aGUgdm9pY2UgcmVjb3JkaW5nIGluIHNlY29uZHNcbiAgICovXG4gIEBJbnB1dCgpIGR1cmF0aW9uPzogbnVtYmVyO1xuICByZXNhbXBsZWRXYXZlRm9ybURhdGE6IG51bWJlcltdID0gW107XG4gIHByb2dyZXNzOiBudW1iZXIgPSAwO1xuICBpc0RyYWdnaW5nID0gZmFsc2U7XG4gIHByaXZhdGUgc2FtcGxlU2l6ZTogbnVtYmVyID0gNDA7XG4gIEBWaWV3Q2hpbGQoJ2NvbnRhaW5lcicsIHsgc3RhdGljOiB0cnVlIH0pXG4gIHByaXZhdGUgY29udGFpbmVyPzogRWxlbWVudFJlZjxIVE1MRWxlbWVudD47XG4gIHByaXZhdGUgaXNWaWV3SW5pdGVkID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBuZ1pvbmU6IE5nWm9uZSwgcHJpdmF0ZSBjZFJlZjogQ2hhbmdlRGV0ZWN0b3JSZWYpIHt9XG5cbiAgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgdGhpcy5jb250YWluZXJTaXplQ2hhbmdlZCgpO1xuICAgIGlmICh0aGlzLmNvbnRhaW5lcj8ubmF0aXZlRWxlbWVudCkge1xuICAgICAgdGhpcy5uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICBuZXcgUmVzaXplT2JzZXJ2ZXIoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuY29udGFpbmVyU2l6ZUNoYW5nZWQoKTtcbiAgICAgICAgfSkub2JzZXJ2ZSh0aGlzLmNvbnRhaW5lciEubmF0aXZlRWxlbWVudCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XG4gICAgaWYgKGNoYW5nZXMud2F2ZUZvcm1EYXRhKSB7XG4gICAgICB0aGlzLnJlc2FtcGxlZFdhdmVGb3JtRGF0YSA9XG4gICAgICAgIHRoaXMud2F2ZUZvcm1EYXRhLmxlbmd0aCA+IHRoaXMuc2FtcGxlU2l6ZVxuICAgICAgICAgID8gdGhpcy5kb3duc2FtcGxlKClcbiAgICAgICAgICA6IHRoaXMudXBzYW1wbGUoKTtcbiAgICB9XG4gICAgaWYgKGNoYW5nZXMuYXVkaW9FbGVtZW50KSB7XG4gICAgICB0aGlzLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgIHRoaXMuYXVkaW9FbGVtZW50Py5hZGRFdmVudExpc3RlbmVyKCd0aW1ldXBkYXRlJywgKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHByb2dyZXNzID1cbiAgICAgICAgICAgICh0aGlzLmF1ZGlvRWxlbWVudD8uY3VycmVudFRpbWUgfHwgMCkgLyAodGhpcy5kdXJhdGlvbiB8fCAwKSB8fCAwO1xuICAgICAgICAgIGlmIChNYXRoLmFicyhwcm9ncmVzcyAtIHRoaXMucHJvZ3Jlc3MpID49IDAuMDIpIHtcbiAgICAgICAgICAgIHRoaXMubmdab25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMucHJvZ3Jlc3MgPSBwcm9ncmVzcztcbiAgICAgICAgICAgICAgdGhpcy5jZFJlZi5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xuICAgIHRoaXMuaXNWaWV3SW5pdGVkID0gdHJ1ZTtcbiAgfVxuXG4gIHNlZWsoZXZlbnQ6IE1vdXNlRXZlbnQpIHtcbiAgICBjb25zdCBjb250YWluZXJXaWR0aCA9XG4gICAgICB0aGlzLmNvbnRhaW5lcj8ubmF0aXZlRWxlbWVudD8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggfHwgMDtcbiAgICBjb25zdCBjb250YWluZXJTdGFydCA9XG4gICAgICB0aGlzLmNvbnRhaW5lcj8ubmF0aXZlRWxlbWVudD8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk/LnggfHwgMDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzXG4gICAgY29uc3QgcHJvZ3Jlc3MgPSAoZXZlbnQueCAtIGNvbnRhaW5lclN0YXJ0KSAvIGNvbnRhaW5lcldpZHRoO1xuXG4gICAgaWYgKCFpc05hTihwcm9ncmVzcykgJiYgdGhpcy5hdWRpb0VsZW1lbnQpIHtcbiAgICAgIGNvbnN0IGR1cmF0aW9uID0gdGhpcy5kdXJhdGlvbiB8fCAwO1xuICAgICAgY29uc3QgdGltZSA9IGR1cmF0aW9uICogcHJvZ3Jlc3M7XG4gICAgICB0aGlzLmF1ZGlvRWxlbWVudC5jdXJyZW50VGltZSA9IHRpbWU7XG4gICAgfVxuICB9XG5cbiAgdHJhY2tCeUluZGV4KGluZGV4OiBudW1iZXIpIHtcbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICBwcml2YXRlIGNvbnRhaW5lclNpemVDaGFuZ2VkKCkge1xuICAgIGlmICghdGhpcy5jb250YWluZXI/Lm5hdGl2ZUVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY29udGFpbmVyV2lkdGggPSB0aGlzLmNvbnRhaW5lci5uYXRpdmVFbGVtZW50LmNsaWVudFdpZHRoO1xuICAgIGlmIChjb250YWluZXJXaWR0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBiYXJXaWR0aCA9ICtnZXRDb21wdXRlZFN0eWxlKHRoaXMuY29udGFpbmVyLm5hdGl2ZUVsZW1lbnQpXG4gICAgICAuZ2V0UHJvcGVydHlWYWx1ZSgnLS1zdHItY2hhdF9fdm9pY2UtcmVjb3JkaW5nLWFtcGxpdHVkZS1iYXItd2lkdGgnKVxuICAgICAgLnJlcGxhY2UoJ3B4JywgJycpO1xuICAgIGNvbnN0IGJhckdhcCA9ICtnZXRDb21wdXRlZFN0eWxlKHRoaXMuY29udGFpbmVyLm5hdGl2ZUVsZW1lbnQpXG4gICAgICAuZ2V0UHJvcGVydHlWYWx1ZSgnLS1zdHItY2hhdF9fdm9pY2UtcmVjb3JkaW5nLWFtcGxpdHVkZS1iYXItZ2FwLXdpZHRoJylcbiAgICAgIC5yZXBsYWNlKCdweCcsICcnKTtcbiAgICBpZiAoIWlzTmFOKGJhcldpZHRoKSAmJiAhaXNOYU4oYmFyR2FwKSkge1xuICAgICAgY29uc3Qgc2FtcGxlU2l6ZSA9IE1hdGguZmxvb3IoY29udGFpbmVyV2lkdGggLyAoYmFyV2lkdGggKyBiYXJHYXApKTtcbiAgICAgIGlmIChcbiAgICAgICAgc2FtcGxlU2l6ZSAhPT0gdGhpcy5zYW1wbGVTaXplICYmXG4gICAgICAgICFpc05hTihzYW1wbGVTaXplKSAmJlxuICAgICAgICBzYW1wbGVTaXplICE9PSBJbmZpbml0eVxuICAgICAgKSB7XG4gICAgICAgIHRoaXMubmdab25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgdGhpcy5zYW1wbGVTaXplID0gc2FtcGxlU2l6ZTtcbiAgICAgICAgICB0aGlzLnJlc2FtcGxlZFdhdmVGb3JtRGF0YSA9XG4gICAgICAgICAgICB0aGlzLndhdmVGb3JtRGF0YS5sZW5ndGggPiB0aGlzLnNhbXBsZVNpemVcbiAgICAgICAgICAgICAgPyB0aGlzLmRvd25zYW1wbGUoKVxuICAgICAgICAgICAgICA6IHRoaXMudXBzYW1wbGUoKTtcbiAgICAgICAgICBpZiAodGhpcy5pc1ZpZXdJbml0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2RSZWYuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBkb3duc2FtcGxlKCkge1xuICAgIGlmICh0aGlzLndhdmVGb3JtRGF0YS5sZW5ndGggPD0gdGhpcy5zYW1wbGVTaXplKSB7XG4gICAgICByZXR1cm4gdGhpcy53YXZlRm9ybURhdGE7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc2FtcGxlU2l6ZSA9PT0gMSkgcmV0dXJuIFt0aGlzLm1lYW4odGhpcy53YXZlRm9ybURhdGEpXTtcblxuICAgIGNvbnN0IHJlc3VsdDogbnVtYmVyW10gPSBbXTtcbiAgICAvLyBidWNrZXQgc2l6ZSBhZGp1c3RlZCBkdWUgdG8gdGhlIGZhY3QgdGhhdCB0aGUgZmlyc3QgYW5kIHRoZSBsYXN0IGl0ZW0gaW4gdGhlIG9yaWdpbmFsIGRhdGEgYXJyYXkgaXMga2VwdCBpbiB0YXJnZXQgb3V0cHV0XG4gICAgY29uc3QgYnVja2V0U2l6ZSA9ICh0aGlzLndhdmVGb3JtRGF0YS5sZW5ndGggLSAyKSAvICh0aGlzLnNhbXBsZVNpemUgLSAyKTtcbiAgICBsZXQgbGFzdFNlbGVjdGVkUG9pbnRJbmRleCA9IDA7XG4gICAgcmVzdWx0LnB1c2godGhpcy53YXZlRm9ybURhdGFbbGFzdFNlbGVjdGVkUG9pbnRJbmRleF0pOyAvLyBBbHdheXMgYWRkIHRoZSBmaXJzdCBwb2ludFxuICAgIGxldCBtYXhBcmVhUG9pbnQsIG1heEFyZWEsIHRyaWFuZ2xlQXJlYTtcblxuICAgIGZvciAoXG4gICAgICBsZXQgYnVja2V0SW5kZXggPSAxO1xuICAgICAgYnVja2V0SW5kZXggPCB0aGlzLnNhbXBsZVNpemUgLSAxO1xuICAgICAgYnVja2V0SW5kZXgrK1xuICAgICkge1xuICAgICAgY29uc3QgcHJldmlvdXNCdWNrZXRSZWZQb2ludCA9IHRoaXMud2F2ZUZvcm1EYXRhW2xhc3RTZWxlY3RlZFBvaW50SW5kZXhdO1xuICAgICAgY29uc3QgbmV4dEJ1Y2tldE1lYW4gPSB0aGlzLmdldE5leHRCdWNrZXRNZWFuKFxuICAgICAgICB0aGlzLndhdmVGb3JtRGF0YSxcbiAgICAgICAgYnVja2V0SW5kZXgsXG4gICAgICAgIGJ1Y2tldFNpemVcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IGN1cnJlbnRCdWNrZXRTdGFydEluZGV4ID1cbiAgICAgICAgTWF0aC5mbG9vcigoYnVja2V0SW5kZXggLSAxKSAqIGJ1Y2tldFNpemUpICsgMTtcbiAgICAgIGNvbnN0IG5leHRCdWNrZXRTdGFydEluZGV4ID0gTWF0aC5mbG9vcihidWNrZXRJbmRleCAqIGJ1Y2tldFNpemUpICsgMTtcbiAgICAgIGNvbnN0IGNvdW50VW5pdHNCZXR3ZWVuQXRvQyA9XG4gICAgICAgIDEgKyBuZXh0QnVja2V0U3RhcnRJbmRleCAtIGN1cnJlbnRCdWNrZXRTdGFydEluZGV4O1xuXG4gICAgICBtYXhBcmVhID0gdHJpYW5nbGVBcmVhID0gLTE7XG5cbiAgICAgIGZvciAoXG4gICAgICAgIGxldCBjdXJyZW50UG9pbnRJbmRleCA9IGN1cnJlbnRCdWNrZXRTdGFydEluZGV4O1xuICAgICAgICBjdXJyZW50UG9pbnRJbmRleCA8IG5leHRCdWNrZXRTdGFydEluZGV4O1xuICAgICAgICBjdXJyZW50UG9pbnRJbmRleCsrXG4gICAgICApIHtcbiAgICAgICAgY29uc3QgY291bnRVbml0c0JldHdlZW5BdG9CID1cbiAgICAgICAgICBNYXRoLmFicyhjdXJyZW50UG9pbnRJbmRleCAtIGN1cnJlbnRCdWNrZXRTdGFydEluZGV4KSArIDE7XG4gICAgICAgIGNvbnN0IGNvdW50VW5pdHNCZXR3ZWVuQnRvQyA9XG4gICAgICAgICAgY291bnRVbml0c0JldHdlZW5BdG9DIC0gY291bnRVbml0c0JldHdlZW5BdG9CO1xuICAgICAgICBjb25zdCBjdXJyZW50UG9pbnRWYWx1ZSA9IHRoaXMud2F2ZUZvcm1EYXRhW2N1cnJlbnRQb2ludEluZGV4XTtcblxuICAgICAgICB0cmlhbmdsZUFyZWEgPSB0aGlzLnRyaWFuZ2xlQXJlYUhlcm9uKFxuICAgICAgICAgIHRoaXMudHJpYW5nbGVCYXNlKFxuICAgICAgICAgICAgTWF0aC5hYnMocHJldmlvdXNCdWNrZXRSZWZQb2ludCAtIGN1cnJlbnRQb2ludFZhbHVlKSxcbiAgICAgICAgICAgIGNvdW50VW5pdHNCZXR3ZWVuQXRvQlxuICAgICAgICAgICksXG4gICAgICAgICAgdGhpcy50cmlhbmdsZUJhc2UoXG4gICAgICAgICAgICBNYXRoLmFicyhjdXJyZW50UG9pbnRWYWx1ZSAtIG5leHRCdWNrZXRNZWFuKSxcbiAgICAgICAgICAgIGNvdW50VW5pdHNCZXR3ZWVuQnRvQ1xuICAgICAgICAgICksXG4gICAgICAgICAgdGhpcy50cmlhbmdsZUJhc2UoXG4gICAgICAgICAgICBNYXRoLmFicyhwcmV2aW91c0J1Y2tldFJlZlBvaW50IC0gbmV4dEJ1Y2tldE1lYW4pLFxuICAgICAgICAgICAgY291bnRVbml0c0JldHdlZW5BdG9DXG4gICAgICAgICAgKVxuICAgICAgICApO1xuXG4gICAgICAgIGlmICh0cmlhbmdsZUFyZWEgPiBtYXhBcmVhKSB7XG4gICAgICAgICAgbWF4QXJlYSA9IHRyaWFuZ2xlQXJlYTtcbiAgICAgICAgICBtYXhBcmVhUG9pbnQgPSB0aGlzLndhdmVGb3JtRGF0YVtjdXJyZW50UG9pbnRJbmRleF07XG4gICAgICAgICAgbGFzdFNlbGVjdGVkUG9pbnRJbmRleCA9IGN1cnJlbnRQb2ludEluZGV4O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgbWF4QXJlYVBvaW50ICE9PSAndW5kZWZpbmVkJykgcmVzdWx0LnB1c2gobWF4QXJlYVBvaW50KTtcbiAgICB9XG5cbiAgICByZXN1bHQucHVzaCh0aGlzLndhdmVGb3JtRGF0YVt0aGlzLndhdmVGb3JtRGF0YS5sZW5ndGggLSAxXSk7IC8vIEFsd2F5cyBhZGQgdGhlIGxhc3QgcG9pbnRcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBwcml2YXRlIHVwc2FtcGxlID0gKCkgPT4ge1xuICAgIGlmICh0aGlzLnNhbXBsZVNpemUgPT09IHRoaXMud2F2ZUZvcm1EYXRhLmxlbmd0aCkgcmV0dXJuIHRoaXMud2F2ZUZvcm1EYXRhO1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lICBwcmVmZXItY29uc3RcbiAgICBsZXQgW2J1Y2tldFNpemUsIHJlbWFpbmRlcl0gPSB0aGlzLmRpdk1vZChcbiAgICAgIHRoaXMuc2FtcGxlU2l6ZSxcbiAgICAgIHRoaXMud2F2ZUZvcm1EYXRhLmxlbmd0aFxuICAgICk7XG4gICAgY29uc3QgcmVzdWx0OiBudW1iZXJbXSA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLndhdmVGb3JtRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZXh0cmEgPSByZW1haW5kZXIgJiYgcmVtYWluZGVyLS0gPyAxIDogMDtcbiAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAuLi5BcnJheTxudW1iZXI+KGJ1Y2tldFNpemUgKyBleHRyYSkuZmlsbCh0aGlzLndhdmVGb3JtRGF0YVtpXSlcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgcHJpdmF0ZSBnZXROZXh0QnVja2V0TWVhbiA9IChcbiAgICBkYXRhOiBudW1iZXJbXSxcbiAgICBjdXJyZW50QnVja2V0SW5kZXg6IG51bWJlcixcbiAgICBidWNrZXRTaXplOiBudW1iZXJcbiAgKSA9PiB7XG4gICAgY29uc3QgbmV4dEJ1Y2tldFN0YXJ0SW5kZXggPVxuICAgICAgTWF0aC5mbG9vcihjdXJyZW50QnVja2V0SW5kZXggKiBidWNrZXRTaXplKSArIDE7XG4gICAgbGV0IG5leHROZXh0QnVja2V0U3RhcnRJbmRleCA9XG4gICAgICBNYXRoLmZsb29yKChjdXJyZW50QnVja2V0SW5kZXggKyAxKSAqIGJ1Y2tldFNpemUpICsgMTtcbiAgICBuZXh0TmV4dEJ1Y2tldFN0YXJ0SW5kZXggPVxuICAgICAgbmV4dE5leHRCdWNrZXRTdGFydEluZGV4IDwgZGF0YS5sZW5ndGhcbiAgICAgICAgPyBuZXh0TmV4dEJ1Y2tldFN0YXJ0SW5kZXhcbiAgICAgICAgOiBkYXRhLmxlbmd0aDtcblxuICAgIHJldHVybiB0aGlzLm1lYW4oXG4gICAgICBkYXRhLnNsaWNlKG5leHRCdWNrZXRTdGFydEluZGV4LCBuZXh0TmV4dEJ1Y2tldFN0YXJ0SW5kZXgpXG4gICAgKTtcbiAgfTtcblxuICBwcml2YXRlIG1lYW4gPSAodmFsdWVzOiBudW1iZXJbXSkgPT5cbiAgICB2YWx1ZXMucmVkdWNlKChhY2MsIHZhbHVlKSA9PiBhY2MgKyB2YWx1ZSwgMCkgLyB2YWx1ZXMubGVuZ3RoO1xuXG4gIHByaXZhdGUgdHJpYW5nbGVBcmVhSGVyb24gPSAoYTogbnVtYmVyLCBiOiBudW1iZXIsIGM6IG51bWJlcikgPT4ge1xuICAgIGNvbnN0IHMgPSAoYSArIGIgKyBjKSAvIDI7XG4gICAgcmV0dXJuIE1hdGguc3FydChzICogKHMgLSBhKSAqIChzIC0gYikgKiAocyAtIGMpKTtcbiAgfTtcblxuICBwcml2YXRlIHRyaWFuZ2xlQmFzZSA9IChhOiBudW1iZXIsIGI6IG51bWJlcikgPT5cbiAgICBNYXRoLnNxcnQoTWF0aC5wb3coYSwgMikgKyBNYXRoLnBvdyhiLCAyKSk7XG5cbiAgcHJpdmF0ZSBkaXZNb2QgPSAobnVtOiBudW1iZXIsIGRpdmlzb3I6IG51bWJlcikgPT4ge1xuICAgIHJldHVybiBbTWF0aC5mbG9vcihudW0gLyBkaXZpc29yKSwgbnVtICUgZGl2aXNvcl07XG4gIH07XG59XG4iLCI8IS0tZXNsaW50LWRpc2FibGUgQGFuZ3VsYXItZXNsaW50L3RlbXBsYXRlL2NsaWNrLWV2ZW50cy1oYXZlLWtleS1ldmVudHMtLT5cbjxkaXZcbiAgI2NvbnRhaW5lclxuICBjbGFzcz1cInN0ci1jaGF0X193YXZlLXByb2dyZXNzLWJhcl9fdHJhY2tcIlxuICBkYXRhLXRlc3RpZD1cIndhdmUtcHJvZ3Jlc3MtYmFyLXRyYWNrXCJcbiAgcm9sZT1cInByb2dyZXNzYmFyXCJcbiAgKG1vdXNlZG93bik9XCJpc0RyYWdnaW5nID0gdHJ1ZVwiXG4gIChtb3VzZXVwKT1cImlzRHJhZ2dpbmcgPSBmYWxzZVwiXG4gIChtb3VzZWxlYXZlKT1cImlzRHJhZ2dpbmcgPSBmYWxzZVwiXG4gIChtb3VzZW1vdmUpPVwiaXNEcmFnZ2luZyA/IHNlZWsoJGV2ZW50KSA6IG51bGxcIlxuICAoY2xpY2spPVwic2VlaygkZXZlbnQpXCJcbj5cbiAgPCEtLWVzbGludC1lbmFibGUgQGFuZ3VsYXItZXNsaW50L3RlbXBsYXRlL2NsaWNrLWV2ZW50cy1oYXZlLWtleS1ldmVudHMtLT5cbiAgPGRpdlxuICAgICpuZ0Zvcj1cIlxuICAgICAgbGV0IGRhdGFQb2ludCBvZiByZXNhbXBsZWRXYXZlRm9ybURhdGE7XG4gICAgICBsZXQgaSA9IGluZGV4O1xuICAgICAgdHJhY2tCeTogdHJhY2tCeUluZGV4XG4gICAgXCJcbiAgICBjbGFzcz1cInN0ci1jaGF0X193YXZlLXByb2dyZXNzLWJhcl9fYW1wbGl0dWRlLWJhclwiXG4gICAgW2NsYXNzLnN0ci1jaGF0X193YXZlLXByb2dyZXNzLWJhcl9fYW1wbGl0dWRlLWJhci0tYWN0aXZlXT1cIlxuICAgICAgcHJvZ3Jlc3MgPiBpIC8gcmVzYW1wbGVkV2F2ZUZvcm1EYXRhLmxlbmd0aFxuICAgIFwiXG4gICAgW3N0eWxlLi0tc3RyLWNoYXRfX3dhdmUtcHJvZ3Jlc3MtYmFyX19hbXBsaXR1ZGUtYmFyLWhlaWdodF09XCJcbiAgICAgIGRhdGFQb2ludCA/IGRhdGFQb2ludCAqIDEwMCArICclJyA6ICcwJSdcbiAgICBcIlxuICA+PC9kaXY+XG4gIDxkaXZcbiAgICBjbGFzcz1cInN0ci1jaGF0X193YXZlLXByb2dyZXNzLWJhcl9fcHJvZ3Jlc3MtaW5kaWNhdG9yXCJcbiAgICBkYXRhLXRlc3RpZD1cIndhdmUtcHJvZ3Jlc3MtYmFyLXByb2dyZXNzLWluZGljYXRvclwiXG4gICAgW25nU3R5bGVdPVwieyAnaW5zZXQtaW5saW5lLXN0YXJ0JzogcHJvZ3Jlc3MgKiAxMDAgKyAnJScgfVwiXG4gID48L2Rpdj5cbjwvZGl2PlxuIl19